// This file is generated. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct GetBlockLocationsRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    offset: ::std::option::Option<u64>,
    length: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetBlockLocationsRequestProto {}

impl GetBlockLocationsRequestProto {
    pub fn new() -> GetBlockLocationsRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetBlockLocationsRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetBlockLocationsRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetBlockLocationsRequestProto,
        };
        unsafe {
            instance.get(GetBlockLocationsRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }

    // required uint64 offset = 2;

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u64) {
        self.offset = ::std::option::Option::Some(v);
    }

    pub fn get_offset(&self) -> u64 {
        self.offset.unwrap_or(0)
    }

    fn get_offset_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.offset
    }

    fn mut_offset_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.offset
    }

    // required uint64 length = 3;

    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: u64) {
        self.length = ::std::option::Option::Some(v);
    }

    pub fn get_length(&self) -> u64 {
        self.length.unwrap_or(0)
    }

    fn get_length_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.length
    }

    fn mut_length_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.length
    }
}

impl ::protobuf::Message for GetBlockLocationsRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.offset.is_none() {
            return false;
        }
        if self.length.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.offset = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.length = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.length {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetBlockLocationsRequestProto {
    fn new() -> GetBlockLocationsRequestProto {
        GetBlockLocationsRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetBlockLocationsRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    GetBlockLocationsRequestProto::get_src_for_reflect,
                    GetBlockLocationsRequestProto::mut_src_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "offset",
                    GetBlockLocationsRequestProto::get_offset_for_reflect,
                    GetBlockLocationsRequestProto::mut_offset_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "length",
                    GetBlockLocationsRequestProto::get_length_for_reflect,
                    GetBlockLocationsRequestProto::mut_length_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetBlockLocationsRequestProto>(
                    "GetBlockLocationsRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetBlockLocationsRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_offset();
        self.clear_length();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBlockLocationsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlockLocationsRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetBlockLocationsResponseProto {
    // message fields
    locations: ::protobuf::SingularPtrField<super::hdfs::LocatedBlocksProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetBlockLocationsResponseProto {}

impl GetBlockLocationsResponseProto {
    pub fn new() -> GetBlockLocationsResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetBlockLocationsResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetBlockLocationsResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetBlockLocationsResponseProto,
        };
        unsafe {
            instance.get(GetBlockLocationsResponseProto::new)
        }
    }

    // optional .hadoop.hdfs.LocatedBlocksProto locations = 1;

    pub fn clear_locations(&mut self) {
        self.locations.clear();
    }

    pub fn has_locations(&self) -> bool {
        self.locations.is_some()
    }

    // Param is passed by value, moved
    pub fn set_locations(&mut self, v: super::hdfs::LocatedBlocksProto) {
        self.locations = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_locations(&mut self) -> &mut super::hdfs::LocatedBlocksProto {
        if self.locations.is_none() {
            self.locations.set_default();
        }
        self.locations.as_mut().unwrap()
    }

    // Take field
    pub fn take_locations(&mut self) -> super::hdfs::LocatedBlocksProto {
        self.locations.take().unwrap_or_else(|| super::hdfs::LocatedBlocksProto::new())
    }

    pub fn get_locations(&self) -> &super::hdfs::LocatedBlocksProto {
        self.locations.as_ref().unwrap_or_else(|| super::hdfs::LocatedBlocksProto::default_instance())
    }

    fn get_locations_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::LocatedBlocksProto> {
        &self.locations
    }

    fn mut_locations_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::LocatedBlocksProto> {
        &mut self.locations
    }
}

impl ::protobuf::Message for GetBlockLocationsResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.locations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.locations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.locations.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.locations.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetBlockLocationsResponseProto {
    fn new() -> GetBlockLocationsResponseProto {
        GetBlockLocationsResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetBlockLocationsResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::LocatedBlocksProto>>(
                    "locations",
                    GetBlockLocationsResponseProto::get_locations_for_reflect,
                    GetBlockLocationsResponseProto::mut_locations_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetBlockLocationsResponseProto>(
                    "GetBlockLocationsResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetBlockLocationsResponseProto {
    fn clear(&mut self) {
        self.clear_locations();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBlockLocationsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlockLocationsResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetServerDefaultsRequestProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetServerDefaultsRequestProto {}

impl GetServerDefaultsRequestProto {
    pub fn new() -> GetServerDefaultsRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetServerDefaultsRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetServerDefaultsRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetServerDefaultsRequestProto,
        };
        unsafe {
            instance.get(GetServerDefaultsRequestProto::new)
        }
    }
}

impl ::protobuf::Message for GetServerDefaultsRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetServerDefaultsRequestProto {
    fn new() -> GetServerDefaultsRequestProto {
        GetServerDefaultsRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetServerDefaultsRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<GetServerDefaultsRequestProto>(
                    "GetServerDefaultsRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetServerDefaultsRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetServerDefaultsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetServerDefaultsRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetServerDefaultsResponseProto {
    // message fields
    serverDefaults: ::protobuf::SingularPtrField<super::hdfs::FsServerDefaultsProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetServerDefaultsResponseProto {}

impl GetServerDefaultsResponseProto {
    pub fn new() -> GetServerDefaultsResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetServerDefaultsResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetServerDefaultsResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetServerDefaultsResponseProto,
        };
        unsafe {
            instance.get(GetServerDefaultsResponseProto::new)
        }
    }

    // required .hadoop.hdfs.FsServerDefaultsProto serverDefaults = 1;

    pub fn clear_serverDefaults(&mut self) {
        self.serverDefaults.clear();
    }

    pub fn has_serverDefaults(&self) -> bool {
        self.serverDefaults.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverDefaults(&mut self, v: super::hdfs::FsServerDefaultsProto) {
        self.serverDefaults = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serverDefaults(&mut self) -> &mut super::hdfs::FsServerDefaultsProto {
        if self.serverDefaults.is_none() {
            self.serverDefaults.set_default();
        }
        self.serverDefaults.as_mut().unwrap()
    }

    // Take field
    pub fn take_serverDefaults(&mut self) -> super::hdfs::FsServerDefaultsProto {
        self.serverDefaults.take().unwrap_or_else(|| super::hdfs::FsServerDefaultsProto::new())
    }

    pub fn get_serverDefaults(&self) -> &super::hdfs::FsServerDefaultsProto {
        self.serverDefaults.as_ref().unwrap_or_else(|| super::hdfs::FsServerDefaultsProto::default_instance())
    }

    fn get_serverDefaults_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::FsServerDefaultsProto> {
        &self.serverDefaults
    }

    fn mut_serverDefaults_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::FsServerDefaultsProto> {
        &mut self.serverDefaults
    }
}

impl ::protobuf::Message for GetServerDefaultsResponseProto {
    fn is_initialized(&self) -> bool {
        if self.serverDefaults.is_none() {
            return false;
        }
        for v in &self.serverDefaults {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.serverDefaults)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.serverDefaults.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.serverDefaults.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetServerDefaultsResponseProto {
    fn new() -> GetServerDefaultsResponseProto {
        GetServerDefaultsResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetServerDefaultsResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::FsServerDefaultsProto>>(
                    "serverDefaults",
                    GetServerDefaultsResponseProto::get_serverDefaults_for_reflect,
                    GetServerDefaultsResponseProto::mut_serverDefaults_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetServerDefaultsResponseProto>(
                    "GetServerDefaultsResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetServerDefaultsResponseProto {
    fn clear(&mut self) {
        self.clear_serverDefaults();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetServerDefaultsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetServerDefaultsResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    masked: ::protobuf::SingularPtrField<super::hdfs::FsPermissionProto>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    createFlag: ::std::option::Option<u32>,
    createParent: ::std::option::Option<bool>,
    replication: ::std::option::Option<u32>,
    blockSize: ::std::option::Option<u64>,
    cryptoProtocolVersion: ::std::vec::Vec<super::hdfs::CryptoProtocolVersionProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CreateRequestProto {}

impl CreateRequestProto {
    pub fn new() -> CreateRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CreateRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<CreateRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateRequestProto,
        };
        unsafe {
            instance.get(CreateRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }

    // required .hadoop.hdfs.FsPermissionProto masked = 2;

    pub fn clear_masked(&mut self) {
        self.masked.clear();
    }

    pub fn has_masked(&self) -> bool {
        self.masked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_masked(&mut self, v: super::hdfs::FsPermissionProto) {
        self.masked = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_masked(&mut self) -> &mut super::hdfs::FsPermissionProto {
        if self.masked.is_none() {
            self.masked.set_default();
        }
        self.masked.as_mut().unwrap()
    }

    // Take field
    pub fn take_masked(&mut self) -> super::hdfs::FsPermissionProto {
        self.masked.take().unwrap_or_else(|| super::hdfs::FsPermissionProto::new())
    }

    pub fn get_masked(&self) -> &super::hdfs::FsPermissionProto {
        self.masked.as_ref().unwrap_or_else(|| super::hdfs::FsPermissionProto::default_instance())
    }

    fn get_masked_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::FsPermissionProto> {
        &self.masked
    }

    fn mut_masked_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::FsPermissionProto> {
        &mut self.masked
    }

    // required string clientName = 3;

    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_clientName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.clientName
    }

    fn mut_clientName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.clientName
    }

    // required uint32 createFlag = 4;

    pub fn clear_createFlag(&mut self) {
        self.createFlag = ::std::option::Option::None;
    }

    pub fn has_createFlag(&self) -> bool {
        self.createFlag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_createFlag(&mut self, v: u32) {
        self.createFlag = ::std::option::Option::Some(v);
    }

    pub fn get_createFlag(&self) -> u32 {
        self.createFlag.unwrap_or(0)
    }

    fn get_createFlag_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.createFlag
    }

    fn mut_createFlag_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.createFlag
    }

    // required bool createParent = 5;

    pub fn clear_createParent(&mut self) {
        self.createParent = ::std::option::Option::None;
    }

    pub fn has_createParent(&self) -> bool {
        self.createParent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_createParent(&mut self, v: bool) {
        self.createParent = ::std::option::Option::Some(v);
    }

    pub fn get_createParent(&self) -> bool {
        self.createParent.unwrap_or(false)
    }

    fn get_createParent_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.createParent
    }

    fn mut_createParent_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.createParent
    }

    // required uint32 replication = 6;

    pub fn clear_replication(&mut self) {
        self.replication = ::std::option::Option::None;
    }

    pub fn has_replication(&self) -> bool {
        self.replication.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replication(&mut self, v: u32) {
        self.replication = ::std::option::Option::Some(v);
    }

    pub fn get_replication(&self) -> u32 {
        self.replication.unwrap_or(0)
    }

    fn get_replication_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.replication
    }

    fn mut_replication_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.replication
    }

    // required uint64 blockSize = 7;

    pub fn clear_blockSize(&mut self) {
        self.blockSize = ::std::option::Option::None;
    }

    pub fn has_blockSize(&self) -> bool {
        self.blockSize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockSize(&mut self, v: u64) {
        self.blockSize = ::std::option::Option::Some(v);
    }

    pub fn get_blockSize(&self) -> u64 {
        self.blockSize.unwrap_or(0)
    }

    fn get_blockSize_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.blockSize
    }

    fn mut_blockSize_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.blockSize
    }

    // repeated .hadoop.hdfs.CryptoProtocolVersionProto cryptoProtocolVersion = 8;

    pub fn clear_cryptoProtocolVersion(&mut self) {
        self.cryptoProtocolVersion.clear();
    }

    // Param is passed by value, moved
    pub fn set_cryptoProtocolVersion(&mut self, v: ::std::vec::Vec<super::hdfs::CryptoProtocolVersionProto>) {
        self.cryptoProtocolVersion = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cryptoProtocolVersion(&mut self) -> &mut ::std::vec::Vec<super::hdfs::CryptoProtocolVersionProto> {
        &mut self.cryptoProtocolVersion
    }

    // Take field
    pub fn take_cryptoProtocolVersion(&mut self) -> ::std::vec::Vec<super::hdfs::CryptoProtocolVersionProto> {
        ::std::mem::replace(&mut self.cryptoProtocolVersion, ::std::vec::Vec::new())
    }

    pub fn get_cryptoProtocolVersion(&self) -> &[super::hdfs::CryptoProtocolVersionProto] {
        &self.cryptoProtocolVersion
    }

    fn get_cryptoProtocolVersion_for_reflect(&self) -> &::std::vec::Vec<super::hdfs::CryptoProtocolVersionProto> {
        &self.cryptoProtocolVersion
    }

    fn mut_cryptoProtocolVersion_for_reflect(&mut self) -> &mut ::std::vec::Vec<super::hdfs::CryptoProtocolVersionProto> {
        &mut self.cryptoProtocolVersion
    }
}

impl ::protobuf::Message for CreateRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.masked.is_none() {
            return false;
        }
        if self.clientName.is_none() {
            return false;
        }
        if self.createFlag.is_none() {
            return false;
        }
        if self.createParent.is_none() {
            return false;
        }
        if self.replication.is_none() {
            return false;
        }
        if self.blockSize.is_none() {
            return false;
        }
        for v in &self.masked {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.masked)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.createFlag = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.createParent = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.replication = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blockSize = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_repeated_enum_into(wire_type, is, &mut self.cryptoProtocolVersion)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.masked.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.createFlag {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.createParent {
            my_size += 2;
        }
        if let Some(v) = self.replication {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.blockSize {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.cryptoProtocolVersion {
            my_size += ::protobuf::rt::enum_size(8, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.masked.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.createFlag {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.createParent {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.replication {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.blockSize {
            os.write_uint64(7, v)?;
        }
        for v in &self.cryptoProtocolVersion {
            os.write_enum(8, v.value())?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CreateRequestProto {
    fn new() -> CreateRequestProto {
        CreateRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CreateRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    CreateRequestProto::get_src_for_reflect,
                    CreateRequestProto::mut_src_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::FsPermissionProto>>(
                    "masked",
                    CreateRequestProto::get_masked_for_reflect,
                    CreateRequestProto::mut_masked_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "clientName",
                    CreateRequestProto::get_clientName_for_reflect,
                    CreateRequestProto::mut_clientName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "createFlag",
                    CreateRequestProto::get_createFlag_for_reflect,
                    CreateRequestProto::mut_createFlag_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "createParent",
                    CreateRequestProto::get_createParent_for_reflect,
                    CreateRequestProto::mut_createParent_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "replication",
                    CreateRequestProto::get_replication_for_reflect,
                    CreateRequestProto::mut_replication_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "blockSize",
                    CreateRequestProto::get_blockSize_for_reflect,
                    CreateRequestProto::mut_blockSize_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::hdfs::CryptoProtocolVersionProto>>(
                    "cryptoProtocolVersion",
                    CreateRequestProto::get_cryptoProtocolVersion_for_reflect,
                    CreateRequestProto::mut_cryptoProtocolVersion_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateRequestProto>(
                    "CreateRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CreateRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_masked();
        self.clear_clientName();
        self.clear_createFlag();
        self.clear_createParent();
        self.clear_replication();
        self.clear_blockSize();
        self.clear_cryptoProtocolVersion();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateResponseProto {
    // message fields
    fs: ::protobuf::SingularPtrField<super::hdfs::HdfsFileStatusProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CreateResponseProto {}

impl CreateResponseProto {
    pub fn new() -> CreateResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CreateResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<CreateResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateResponseProto,
        };
        unsafe {
            instance.get(CreateResponseProto::new)
        }
    }

    // optional .hadoop.hdfs.HdfsFileStatusProto fs = 1;

    pub fn clear_fs(&mut self) {
        self.fs.clear();
    }

    pub fn has_fs(&self) -> bool {
        self.fs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fs(&mut self, v: super::hdfs::HdfsFileStatusProto) {
        self.fs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fs(&mut self) -> &mut super::hdfs::HdfsFileStatusProto {
        if self.fs.is_none() {
            self.fs.set_default();
        }
        self.fs.as_mut().unwrap()
    }

    // Take field
    pub fn take_fs(&mut self) -> super::hdfs::HdfsFileStatusProto {
        self.fs.take().unwrap_or_else(|| super::hdfs::HdfsFileStatusProto::new())
    }

    pub fn get_fs(&self) -> &super::hdfs::HdfsFileStatusProto {
        self.fs.as_ref().unwrap_or_else(|| super::hdfs::HdfsFileStatusProto::default_instance())
    }

    fn get_fs_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::HdfsFileStatusProto> {
        &self.fs
    }

    fn mut_fs_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::HdfsFileStatusProto> {
        &mut self.fs
    }
}

impl ::protobuf::Message for CreateResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.fs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.fs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.fs.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CreateResponseProto {
    fn new() -> CreateResponseProto {
        CreateResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CreateResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::HdfsFileStatusProto>>(
                    "fs",
                    CreateResponseProto::get_fs_for_reflect,
                    CreateResponseProto::mut_fs_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateResponseProto>(
                    "CreateResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CreateResponseProto {
    fn clear(&mut self) {
        self.clear_fs();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AppendRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for AppendRequestProto {}

impl AppendRequestProto {
    pub fn new() -> AppendRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AppendRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<AppendRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AppendRequestProto,
        };
        unsafe {
            instance.get(AppendRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }

    // required string clientName = 2;

    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_clientName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.clientName
    }

    fn mut_clientName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.clientName
    }
}

impl ::protobuf::Message for AppendRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.clientName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AppendRequestProto {
    fn new() -> AppendRequestProto {
        AppendRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<AppendRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    AppendRequestProto::get_src_for_reflect,
                    AppendRequestProto::mut_src_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "clientName",
                    AppendRequestProto::get_clientName_for_reflect,
                    AppendRequestProto::mut_clientName_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AppendRequestProto>(
                    "AppendRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AppendRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_clientName();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AppendRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppendRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AppendResponseProto {
    // message fields
    block: ::protobuf::SingularPtrField<super::hdfs::LocatedBlockProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for AppendResponseProto {}

impl AppendResponseProto {
    pub fn new() -> AppendResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AppendResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<AppendResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AppendResponseProto,
        };
        unsafe {
            instance.get(AppendResponseProto::new)
        }
    }

    // optional .hadoop.hdfs.LocatedBlockProto block = 1;

    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    pub fn has_block(&self) -> bool {
        self.block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: super::hdfs::LocatedBlockProto) {
        self.block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block(&mut self) -> &mut super::hdfs::LocatedBlockProto {
        if self.block.is_none() {
            self.block.set_default();
        }
        self.block.as_mut().unwrap()
    }

    // Take field
    pub fn take_block(&mut self) -> super::hdfs::LocatedBlockProto {
        self.block.take().unwrap_or_else(|| super::hdfs::LocatedBlockProto::new())
    }

    pub fn get_block(&self) -> &super::hdfs::LocatedBlockProto {
        self.block.as_ref().unwrap_or_else(|| super::hdfs::LocatedBlockProto::default_instance())
    }

    fn get_block_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::LocatedBlockProto> {
        &self.block
    }

    fn mut_block_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::LocatedBlockProto> {
        &mut self.block
    }
}

impl ::protobuf::Message for AppendResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.block {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.block)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.block.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AppendResponseProto {
    fn new() -> AppendResponseProto {
        AppendResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<AppendResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::LocatedBlockProto>>(
                    "block",
                    AppendResponseProto::get_block_for_reflect,
                    AppendResponseProto::mut_block_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AppendResponseProto>(
                    "AppendResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AppendResponseProto {
    fn clear(&mut self) {
        self.clear_block();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AppendResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppendResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetReplicationRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    replication: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SetReplicationRequestProto {}

impl SetReplicationRequestProto {
    pub fn new() -> SetReplicationRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetReplicationRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<SetReplicationRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetReplicationRequestProto,
        };
        unsafe {
            instance.get(SetReplicationRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }

    // required uint32 replication = 2;

    pub fn clear_replication(&mut self) {
        self.replication = ::std::option::Option::None;
    }

    pub fn has_replication(&self) -> bool {
        self.replication.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replication(&mut self, v: u32) {
        self.replication = ::std::option::Option::Some(v);
    }

    pub fn get_replication(&self) -> u32 {
        self.replication.unwrap_or(0)
    }

    fn get_replication_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.replication
    }

    fn mut_replication_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.replication
    }
}

impl ::protobuf::Message for SetReplicationRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.replication.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.replication = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.replication {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.replication {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetReplicationRequestProto {
    fn new() -> SetReplicationRequestProto {
        SetReplicationRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetReplicationRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    SetReplicationRequestProto::get_src_for_reflect,
                    SetReplicationRequestProto::mut_src_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "replication",
                    SetReplicationRequestProto::get_replication_for_reflect,
                    SetReplicationRequestProto::mut_replication_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetReplicationRequestProto>(
                    "SetReplicationRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetReplicationRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_replication();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetReplicationRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetReplicationRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetReplicationResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SetReplicationResponseProto {}

impl SetReplicationResponseProto {
    pub fn new() -> SetReplicationResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetReplicationResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<SetReplicationResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetReplicationResponseProto,
        };
        unsafe {
            instance.get(SetReplicationResponseProto::new)
        }
    }

    // required bool result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.result
    }
}

impl ::protobuf::Message for SetReplicationResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetReplicationResponseProto {
    fn new() -> SetReplicationResponseProto {
        SetReplicationResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetReplicationResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    SetReplicationResponseProto::get_result_for_reflect,
                    SetReplicationResponseProto::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetReplicationResponseProto>(
                    "SetReplicationResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetReplicationResponseProto {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetReplicationResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetReplicationResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetStoragePolicyRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    policyName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SetStoragePolicyRequestProto {}

impl SetStoragePolicyRequestProto {
    pub fn new() -> SetStoragePolicyRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetStoragePolicyRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<SetStoragePolicyRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetStoragePolicyRequestProto,
        };
        unsafe {
            instance.get(SetStoragePolicyRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }

    // required string policyName = 2;

    pub fn clear_policyName(&mut self) {
        self.policyName.clear();
    }

    pub fn has_policyName(&self) -> bool {
        self.policyName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_policyName(&mut self, v: ::std::string::String) {
        self.policyName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_policyName(&mut self) -> &mut ::std::string::String {
        if self.policyName.is_none() {
            self.policyName.set_default();
        }
        self.policyName.as_mut().unwrap()
    }

    // Take field
    pub fn take_policyName(&mut self) -> ::std::string::String {
        self.policyName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_policyName(&self) -> &str {
        match self.policyName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_policyName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.policyName
    }

    fn mut_policyName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.policyName
    }
}

impl ::protobuf::Message for SetStoragePolicyRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.policyName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.policyName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.policyName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.policyName.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetStoragePolicyRequestProto {
    fn new() -> SetStoragePolicyRequestProto {
        SetStoragePolicyRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetStoragePolicyRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    SetStoragePolicyRequestProto::get_src_for_reflect,
                    SetStoragePolicyRequestProto::mut_src_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "policyName",
                    SetStoragePolicyRequestProto::get_policyName_for_reflect,
                    SetStoragePolicyRequestProto::mut_policyName_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetStoragePolicyRequestProto>(
                    "SetStoragePolicyRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetStoragePolicyRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_policyName();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetStoragePolicyRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetStoragePolicyRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetStoragePolicyResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SetStoragePolicyResponseProto {}

impl SetStoragePolicyResponseProto {
    pub fn new() -> SetStoragePolicyResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetStoragePolicyResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<SetStoragePolicyResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetStoragePolicyResponseProto,
        };
        unsafe {
            instance.get(SetStoragePolicyResponseProto::new)
        }
    }
}

impl ::protobuf::Message for SetStoragePolicyResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetStoragePolicyResponseProto {
    fn new() -> SetStoragePolicyResponseProto {
        SetStoragePolicyResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetStoragePolicyResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SetStoragePolicyResponseProto>(
                    "SetStoragePolicyResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetStoragePolicyResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetStoragePolicyResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetStoragePolicyResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetStoragePoliciesRequestProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetStoragePoliciesRequestProto {}

impl GetStoragePoliciesRequestProto {
    pub fn new() -> GetStoragePoliciesRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetStoragePoliciesRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetStoragePoliciesRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetStoragePoliciesRequestProto,
        };
        unsafe {
            instance.get(GetStoragePoliciesRequestProto::new)
        }
    }
}

impl ::protobuf::Message for GetStoragePoliciesRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetStoragePoliciesRequestProto {
    fn new() -> GetStoragePoliciesRequestProto {
        GetStoragePoliciesRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetStoragePoliciesRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<GetStoragePoliciesRequestProto>(
                    "GetStoragePoliciesRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetStoragePoliciesRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetStoragePoliciesRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetStoragePoliciesRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetStoragePoliciesResponseProto {
    // message fields
    policies: ::protobuf::RepeatedField<super::hdfs::BlockStoragePolicyProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetStoragePoliciesResponseProto {}

impl GetStoragePoliciesResponseProto {
    pub fn new() -> GetStoragePoliciesResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetStoragePoliciesResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetStoragePoliciesResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetStoragePoliciesResponseProto,
        };
        unsafe {
            instance.get(GetStoragePoliciesResponseProto::new)
        }
    }

    // repeated .hadoop.hdfs.BlockStoragePolicyProto policies = 1;

    pub fn clear_policies(&mut self) {
        self.policies.clear();
    }

    // Param is passed by value, moved
    pub fn set_policies(&mut self, v: ::protobuf::RepeatedField<super::hdfs::BlockStoragePolicyProto>) {
        self.policies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_policies(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::BlockStoragePolicyProto> {
        &mut self.policies
    }

    // Take field
    pub fn take_policies(&mut self) -> ::protobuf::RepeatedField<super::hdfs::BlockStoragePolicyProto> {
        ::std::mem::replace(&mut self.policies, ::protobuf::RepeatedField::new())
    }

    pub fn get_policies(&self) -> &[super::hdfs::BlockStoragePolicyProto] {
        &self.policies
    }

    fn get_policies_for_reflect(&self) -> &::protobuf::RepeatedField<super::hdfs::BlockStoragePolicyProto> {
        &self.policies
    }

    fn mut_policies_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::BlockStoragePolicyProto> {
        &mut self.policies
    }
}

impl ::protobuf::Message for GetStoragePoliciesResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.policies {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.policies)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.policies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.policies {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetStoragePoliciesResponseProto {
    fn new() -> GetStoragePoliciesResponseProto {
        GetStoragePoliciesResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetStoragePoliciesResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::BlockStoragePolicyProto>>(
                    "policies",
                    GetStoragePoliciesResponseProto::get_policies_for_reflect,
                    GetStoragePoliciesResponseProto::mut_policies_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetStoragePoliciesResponseProto>(
                    "GetStoragePoliciesResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetStoragePoliciesResponseProto {
    fn clear(&mut self) {
        self.clear_policies();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetStoragePoliciesResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetStoragePoliciesResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetPermissionRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    permission: ::protobuf::SingularPtrField<super::hdfs::FsPermissionProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SetPermissionRequestProto {}

impl SetPermissionRequestProto {
    pub fn new() -> SetPermissionRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetPermissionRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<SetPermissionRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetPermissionRequestProto,
        };
        unsafe {
            instance.get(SetPermissionRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }

    // required .hadoop.hdfs.FsPermissionProto permission = 2;

    pub fn clear_permission(&mut self) {
        self.permission.clear();
    }

    pub fn has_permission(&self) -> bool {
        self.permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission(&mut self, v: super::hdfs::FsPermissionProto) {
        self.permission = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_permission(&mut self) -> &mut super::hdfs::FsPermissionProto {
        if self.permission.is_none() {
            self.permission.set_default();
        }
        self.permission.as_mut().unwrap()
    }

    // Take field
    pub fn take_permission(&mut self) -> super::hdfs::FsPermissionProto {
        self.permission.take().unwrap_or_else(|| super::hdfs::FsPermissionProto::new())
    }

    pub fn get_permission(&self) -> &super::hdfs::FsPermissionProto {
        self.permission.as_ref().unwrap_or_else(|| super::hdfs::FsPermissionProto::default_instance())
    }

    fn get_permission_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::FsPermissionProto> {
        &self.permission
    }

    fn mut_permission_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::FsPermissionProto> {
        &mut self.permission
    }
}

impl ::protobuf::Message for SetPermissionRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.permission.is_none() {
            return false;
        }
        for v in &self.permission {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.permission)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.permission.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.permission.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetPermissionRequestProto {
    fn new() -> SetPermissionRequestProto {
        SetPermissionRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetPermissionRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    SetPermissionRequestProto::get_src_for_reflect,
                    SetPermissionRequestProto::mut_src_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::FsPermissionProto>>(
                    "permission",
                    SetPermissionRequestProto::get_permission_for_reflect,
                    SetPermissionRequestProto::mut_permission_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetPermissionRequestProto>(
                    "SetPermissionRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetPermissionRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_permission();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetPermissionRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetPermissionRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetPermissionResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SetPermissionResponseProto {}

impl SetPermissionResponseProto {
    pub fn new() -> SetPermissionResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetPermissionResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<SetPermissionResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetPermissionResponseProto,
        };
        unsafe {
            instance.get(SetPermissionResponseProto::new)
        }
    }
}

impl ::protobuf::Message for SetPermissionResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetPermissionResponseProto {
    fn new() -> SetPermissionResponseProto {
        SetPermissionResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetPermissionResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SetPermissionResponseProto>(
                    "SetPermissionResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetPermissionResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetPermissionResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetPermissionResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetOwnerRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    username: ::protobuf::SingularField<::std::string::String>,
    groupname: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SetOwnerRequestProto {}

impl SetOwnerRequestProto {
    pub fn new() -> SetOwnerRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetOwnerRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<SetOwnerRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetOwnerRequestProto,
        };
        unsafe {
            instance.get(SetOwnerRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }

    // optional string username = 2;

    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    pub fn has_username(&self) -> bool {
        self.username.is_some()
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        if self.username.is_none() {
            self.username.set_default();
        }
        self.username.as_mut().unwrap()
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        self.username.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_username(&self) -> &str {
        match self.username.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_username_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.username
    }

    fn mut_username_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.username
    }

    // optional string groupname = 3;

    pub fn clear_groupname(&mut self) {
        self.groupname.clear();
    }

    pub fn has_groupname(&self) -> bool {
        self.groupname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupname(&mut self, v: ::std::string::String) {
        self.groupname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupname(&mut self) -> &mut ::std::string::String {
        if self.groupname.is_none() {
            self.groupname.set_default();
        }
        self.groupname.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupname(&mut self) -> ::std::string::String {
        self.groupname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_groupname(&self) -> &str {
        match self.groupname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_groupname_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.groupname
    }

    fn mut_groupname_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.groupname
    }
}

impl ::protobuf::Message for SetOwnerRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.username)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.groupname)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.username.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.groupname.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.username.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.groupname.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetOwnerRequestProto {
    fn new() -> SetOwnerRequestProto {
        SetOwnerRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetOwnerRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    SetOwnerRequestProto::get_src_for_reflect,
                    SetOwnerRequestProto::mut_src_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "username",
                    SetOwnerRequestProto::get_username_for_reflect,
                    SetOwnerRequestProto::mut_username_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "groupname",
                    SetOwnerRequestProto::get_groupname_for_reflect,
                    SetOwnerRequestProto::mut_groupname_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetOwnerRequestProto>(
                    "SetOwnerRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetOwnerRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_username();
        self.clear_groupname();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetOwnerRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetOwnerRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetOwnerResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SetOwnerResponseProto {}

impl SetOwnerResponseProto {
    pub fn new() -> SetOwnerResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetOwnerResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<SetOwnerResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetOwnerResponseProto,
        };
        unsafe {
            instance.get(SetOwnerResponseProto::new)
        }
    }
}

impl ::protobuf::Message for SetOwnerResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetOwnerResponseProto {
    fn new() -> SetOwnerResponseProto {
        SetOwnerResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetOwnerResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SetOwnerResponseProto>(
                    "SetOwnerResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetOwnerResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetOwnerResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetOwnerResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AbandonBlockRequestProto {
    // message fields
    b: ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto>,
    src: ::protobuf::SingularField<::std::string::String>,
    holder: ::protobuf::SingularField<::std::string::String>,
    fileId: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for AbandonBlockRequestProto {}

impl AbandonBlockRequestProto {
    pub fn new() -> AbandonBlockRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AbandonBlockRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<AbandonBlockRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AbandonBlockRequestProto,
        };
        unsafe {
            instance.get(AbandonBlockRequestProto::new)
        }
    }

    // required .hadoop.hdfs.ExtendedBlockProto b = 1;

    pub fn clear_b(&mut self) {
        self.b.clear();
    }

    pub fn has_b(&self) -> bool {
        self.b.is_some()
    }

    // Param is passed by value, moved
    pub fn set_b(&mut self, v: super::hdfs::ExtendedBlockProto) {
        self.b = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_b(&mut self) -> &mut super::hdfs::ExtendedBlockProto {
        if self.b.is_none() {
            self.b.set_default();
        }
        self.b.as_mut().unwrap()
    }

    // Take field
    pub fn take_b(&mut self) -> super::hdfs::ExtendedBlockProto {
        self.b.take().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::new())
    }

    pub fn get_b(&self) -> &super::hdfs::ExtendedBlockProto {
        self.b.as_ref().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::default_instance())
    }

    fn get_b_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto> {
        &self.b
    }

    fn mut_b_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto> {
        &mut self.b
    }

    // required string src = 2;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }

    // required string holder = 3;

    pub fn clear_holder(&mut self) {
        self.holder.clear();
    }

    pub fn has_holder(&self) -> bool {
        self.holder.is_some()
    }

    // Param is passed by value, moved
    pub fn set_holder(&mut self, v: ::std::string::String) {
        self.holder = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_holder(&mut self) -> &mut ::std::string::String {
        if self.holder.is_none() {
            self.holder.set_default();
        }
        self.holder.as_mut().unwrap()
    }

    // Take field
    pub fn take_holder(&mut self) -> ::std::string::String {
        self.holder.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_holder(&self) -> &str {
        match self.holder.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_holder_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.holder
    }

    fn mut_holder_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.holder
    }

    // optional uint64 fileId = 4;

    pub fn clear_fileId(&mut self) {
        self.fileId = ::std::option::Option::None;
    }

    pub fn has_fileId(&self) -> bool {
        self.fileId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileId(&mut self, v: u64) {
        self.fileId = ::std::option::Option::Some(v);
    }

    pub fn get_fileId(&self) -> u64 {
        self.fileId.unwrap_or(0u64)
    }

    fn get_fileId_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.fileId
    }

    fn mut_fileId_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.fileId
    }
}

impl ::protobuf::Message for AbandonBlockRequestProto {
    fn is_initialized(&self) -> bool {
        if self.b.is_none() {
            return false;
        }
        if self.src.is_none() {
            return false;
        }
        if self.holder.is_none() {
            return false;
        }
        for v in &self.b {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.b)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.holder)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fileId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.b.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.holder.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.fileId {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.b.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.holder.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.fileId {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AbandonBlockRequestProto {
    fn new() -> AbandonBlockRequestProto {
        AbandonBlockRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<AbandonBlockRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::ExtendedBlockProto>>(
                    "b",
                    AbandonBlockRequestProto::get_b_for_reflect,
                    AbandonBlockRequestProto::mut_b_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    AbandonBlockRequestProto::get_src_for_reflect,
                    AbandonBlockRequestProto::mut_src_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "holder",
                    AbandonBlockRequestProto::get_holder_for_reflect,
                    AbandonBlockRequestProto::mut_holder_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fileId",
                    AbandonBlockRequestProto::get_fileId_for_reflect,
                    AbandonBlockRequestProto::mut_fileId_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AbandonBlockRequestProto>(
                    "AbandonBlockRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AbandonBlockRequestProto {
    fn clear(&mut self) {
        self.clear_b();
        self.clear_src();
        self.clear_holder();
        self.clear_fileId();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AbandonBlockRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AbandonBlockRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AbandonBlockResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for AbandonBlockResponseProto {}

impl AbandonBlockResponseProto {
    pub fn new() -> AbandonBlockResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AbandonBlockResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<AbandonBlockResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AbandonBlockResponseProto,
        };
        unsafe {
            instance.get(AbandonBlockResponseProto::new)
        }
    }
}

impl ::protobuf::Message for AbandonBlockResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AbandonBlockResponseProto {
    fn new() -> AbandonBlockResponseProto {
        AbandonBlockResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<AbandonBlockResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<AbandonBlockResponseProto>(
                    "AbandonBlockResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AbandonBlockResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AbandonBlockResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AbandonBlockResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddBlockRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    previous: ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto>,
    excludeNodes: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>,
    fileId: ::std::option::Option<u64>,
    favoredNodes: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for AddBlockRequestProto {}

impl AddBlockRequestProto {
    pub fn new() -> AddBlockRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AddBlockRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<AddBlockRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddBlockRequestProto,
        };
        unsafe {
            instance.get(AddBlockRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }

    // required string clientName = 2;

    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_clientName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.clientName
    }

    fn mut_clientName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.clientName
    }

    // optional .hadoop.hdfs.ExtendedBlockProto previous = 3;

    pub fn clear_previous(&mut self) {
        self.previous.clear();
    }

    pub fn has_previous(&self) -> bool {
        self.previous.is_some()
    }

    // Param is passed by value, moved
    pub fn set_previous(&mut self, v: super::hdfs::ExtendedBlockProto) {
        self.previous = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_previous(&mut self) -> &mut super::hdfs::ExtendedBlockProto {
        if self.previous.is_none() {
            self.previous.set_default();
        }
        self.previous.as_mut().unwrap()
    }

    // Take field
    pub fn take_previous(&mut self) -> super::hdfs::ExtendedBlockProto {
        self.previous.take().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::new())
    }

    pub fn get_previous(&self) -> &super::hdfs::ExtendedBlockProto {
        self.previous.as_ref().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::default_instance())
    }

    fn get_previous_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto> {
        &self.previous
    }

    fn mut_previous_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto> {
        &mut self.previous
    }

    // repeated .hadoop.hdfs.DatanodeInfoProto excludeNodes = 4;

    pub fn clear_excludeNodes(&mut self) {
        self.excludeNodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_excludeNodes(&mut self, v: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>) {
        self.excludeNodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_excludeNodes(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        &mut self.excludeNodes
    }

    // Take field
    pub fn take_excludeNodes(&mut self) -> ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        ::std::mem::replace(&mut self.excludeNodes, ::protobuf::RepeatedField::new())
    }

    pub fn get_excludeNodes(&self) -> &[super::hdfs::DatanodeInfoProto] {
        &self.excludeNodes
    }

    fn get_excludeNodes_for_reflect(&self) -> &::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        &self.excludeNodes
    }

    fn mut_excludeNodes_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        &mut self.excludeNodes
    }

    // optional uint64 fileId = 5;

    pub fn clear_fileId(&mut self) {
        self.fileId = ::std::option::Option::None;
    }

    pub fn has_fileId(&self) -> bool {
        self.fileId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileId(&mut self, v: u64) {
        self.fileId = ::std::option::Option::Some(v);
    }

    pub fn get_fileId(&self) -> u64 {
        self.fileId.unwrap_or(0u64)
    }

    fn get_fileId_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.fileId
    }

    fn mut_fileId_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.fileId
    }

    // repeated string favoredNodes = 6;

    pub fn clear_favoredNodes(&mut self) {
        self.favoredNodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_favoredNodes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.favoredNodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_favoredNodes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.favoredNodes
    }

    // Take field
    pub fn take_favoredNodes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.favoredNodes, ::protobuf::RepeatedField::new())
    }

    pub fn get_favoredNodes(&self) -> &[::std::string::String] {
        &self.favoredNodes
    }

    fn get_favoredNodes_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.favoredNodes
    }

    fn mut_favoredNodes_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.favoredNodes
    }
}

impl ::protobuf::Message for AddBlockRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.clientName.is_none() {
            return false;
        }
        for v in &self.previous {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.excludeNodes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.previous)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.excludeNodes)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fileId = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.favoredNodes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.previous.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.excludeNodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.fileId {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.favoredNodes {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.previous.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.excludeNodes {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.fileId {
            os.write_uint64(5, v)?;
        }
        for v in &self.favoredNodes {
            os.write_string(6, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AddBlockRequestProto {
    fn new() -> AddBlockRequestProto {
        AddBlockRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<AddBlockRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    AddBlockRequestProto::get_src_for_reflect,
                    AddBlockRequestProto::mut_src_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "clientName",
                    AddBlockRequestProto::get_clientName_for_reflect,
                    AddBlockRequestProto::mut_clientName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::ExtendedBlockProto>>(
                    "previous",
                    AddBlockRequestProto::get_previous_for_reflect,
                    AddBlockRequestProto::mut_previous_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DatanodeInfoProto>>(
                    "excludeNodes",
                    AddBlockRequestProto::get_excludeNodes_for_reflect,
                    AddBlockRequestProto::mut_excludeNodes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fileId",
                    AddBlockRequestProto::get_fileId_for_reflect,
                    AddBlockRequestProto::mut_fileId_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "favoredNodes",
                    AddBlockRequestProto::get_favoredNodes_for_reflect,
                    AddBlockRequestProto::mut_favoredNodes_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddBlockRequestProto>(
                    "AddBlockRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AddBlockRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_clientName();
        self.clear_previous();
        self.clear_excludeNodes();
        self.clear_fileId();
        self.clear_favoredNodes();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddBlockRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddBlockRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddBlockResponseProto {
    // message fields
    block: ::protobuf::SingularPtrField<super::hdfs::LocatedBlockProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for AddBlockResponseProto {}

impl AddBlockResponseProto {
    pub fn new() -> AddBlockResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AddBlockResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<AddBlockResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddBlockResponseProto,
        };
        unsafe {
            instance.get(AddBlockResponseProto::new)
        }
    }

    // required .hadoop.hdfs.LocatedBlockProto block = 1;

    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    pub fn has_block(&self) -> bool {
        self.block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: super::hdfs::LocatedBlockProto) {
        self.block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block(&mut self) -> &mut super::hdfs::LocatedBlockProto {
        if self.block.is_none() {
            self.block.set_default();
        }
        self.block.as_mut().unwrap()
    }

    // Take field
    pub fn take_block(&mut self) -> super::hdfs::LocatedBlockProto {
        self.block.take().unwrap_or_else(|| super::hdfs::LocatedBlockProto::new())
    }

    pub fn get_block(&self) -> &super::hdfs::LocatedBlockProto {
        self.block.as_ref().unwrap_or_else(|| super::hdfs::LocatedBlockProto::default_instance())
    }

    fn get_block_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::LocatedBlockProto> {
        &self.block
    }

    fn mut_block_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::LocatedBlockProto> {
        &mut self.block
    }
}

impl ::protobuf::Message for AddBlockResponseProto {
    fn is_initialized(&self) -> bool {
        if self.block.is_none() {
            return false;
        }
        for v in &self.block {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.block)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.block.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AddBlockResponseProto {
    fn new() -> AddBlockResponseProto {
        AddBlockResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<AddBlockResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::LocatedBlockProto>>(
                    "block",
                    AddBlockResponseProto::get_block_for_reflect,
                    AddBlockResponseProto::mut_block_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddBlockResponseProto>(
                    "AddBlockResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AddBlockResponseProto {
    fn clear(&mut self) {
        self.clear_block();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddBlockResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddBlockResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetAdditionalDatanodeRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    blk: ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto>,
    existings: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>,
    excludes: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>,
    numAdditionalNodes: ::std::option::Option<u32>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    existingStorageUuids: ::protobuf::RepeatedField<::std::string::String>,
    fileId: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetAdditionalDatanodeRequestProto {}

impl GetAdditionalDatanodeRequestProto {
    pub fn new() -> GetAdditionalDatanodeRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetAdditionalDatanodeRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetAdditionalDatanodeRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetAdditionalDatanodeRequestProto,
        };
        unsafe {
            instance.get(GetAdditionalDatanodeRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }

    // required .hadoop.hdfs.ExtendedBlockProto blk = 2;

    pub fn clear_blk(&mut self) {
        self.blk.clear();
    }

    pub fn has_blk(&self) -> bool {
        self.blk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blk(&mut self, v: super::hdfs::ExtendedBlockProto) {
        self.blk = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blk(&mut self) -> &mut super::hdfs::ExtendedBlockProto {
        if self.blk.is_none() {
            self.blk.set_default();
        }
        self.blk.as_mut().unwrap()
    }

    // Take field
    pub fn take_blk(&mut self) -> super::hdfs::ExtendedBlockProto {
        self.blk.take().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::new())
    }

    pub fn get_blk(&self) -> &super::hdfs::ExtendedBlockProto {
        self.blk.as_ref().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::default_instance())
    }

    fn get_blk_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto> {
        &self.blk
    }

    fn mut_blk_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto> {
        &mut self.blk
    }

    // repeated .hadoop.hdfs.DatanodeInfoProto existings = 3;

    pub fn clear_existings(&mut self) {
        self.existings.clear();
    }

    // Param is passed by value, moved
    pub fn set_existings(&mut self, v: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>) {
        self.existings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_existings(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        &mut self.existings
    }

    // Take field
    pub fn take_existings(&mut self) -> ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        ::std::mem::replace(&mut self.existings, ::protobuf::RepeatedField::new())
    }

    pub fn get_existings(&self) -> &[super::hdfs::DatanodeInfoProto] {
        &self.existings
    }

    fn get_existings_for_reflect(&self) -> &::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        &self.existings
    }

    fn mut_existings_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        &mut self.existings
    }

    // repeated .hadoop.hdfs.DatanodeInfoProto excludes = 4;

    pub fn clear_excludes(&mut self) {
        self.excludes.clear();
    }

    // Param is passed by value, moved
    pub fn set_excludes(&mut self, v: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>) {
        self.excludes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_excludes(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        &mut self.excludes
    }

    // Take field
    pub fn take_excludes(&mut self) -> ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        ::std::mem::replace(&mut self.excludes, ::protobuf::RepeatedField::new())
    }

    pub fn get_excludes(&self) -> &[super::hdfs::DatanodeInfoProto] {
        &self.excludes
    }

    fn get_excludes_for_reflect(&self) -> &::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        &self.excludes
    }

    fn mut_excludes_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        &mut self.excludes
    }

    // required uint32 numAdditionalNodes = 5;

    pub fn clear_numAdditionalNodes(&mut self) {
        self.numAdditionalNodes = ::std::option::Option::None;
    }

    pub fn has_numAdditionalNodes(&self) -> bool {
        self.numAdditionalNodes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numAdditionalNodes(&mut self, v: u32) {
        self.numAdditionalNodes = ::std::option::Option::Some(v);
    }

    pub fn get_numAdditionalNodes(&self) -> u32 {
        self.numAdditionalNodes.unwrap_or(0)
    }

    fn get_numAdditionalNodes_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.numAdditionalNodes
    }

    fn mut_numAdditionalNodes_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.numAdditionalNodes
    }

    // required string clientName = 6;

    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_clientName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.clientName
    }

    fn mut_clientName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.clientName
    }

    // repeated string existingStorageUuids = 7;

    pub fn clear_existingStorageUuids(&mut self) {
        self.existingStorageUuids.clear();
    }

    // Param is passed by value, moved
    pub fn set_existingStorageUuids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.existingStorageUuids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_existingStorageUuids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.existingStorageUuids
    }

    // Take field
    pub fn take_existingStorageUuids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.existingStorageUuids, ::protobuf::RepeatedField::new())
    }

    pub fn get_existingStorageUuids(&self) -> &[::std::string::String] {
        &self.existingStorageUuids
    }

    fn get_existingStorageUuids_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.existingStorageUuids
    }

    fn mut_existingStorageUuids_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.existingStorageUuids
    }

    // optional uint64 fileId = 8;

    pub fn clear_fileId(&mut self) {
        self.fileId = ::std::option::Option::None;
    }

    pub fn has_fileId(&self) -> bool {
        self.fileId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileId(&mut self, v: u64) {
        self.fileId = ::std::option::Option::Some(v);
    }

    pub fn get_fileId(&self) -> u64 {
        self.fileId.unwrap_or(0u64)
    }

    fn get_fileId_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.fileId
    }

    fn mut_fileId_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.fileId
    }
}

impl ::protobuf::Message for GetAdditionalDatanodeRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.blk.is_none() {
            return false;
        }
        if self.numAdditionalNodes.is_none() {
            return false;
        }
        if self.clientName.is_none() {
            return false;
        }
        for v in &self.blk {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.existings {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.excludes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.blk)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.existings)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.excludes)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.numAdditionalNodes = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.existingStorageUuids)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fileId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.blk.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.existings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.excludes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.numAdditionalNodes {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        for value in &self.existingStorageUuids {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(v) = self.fileId {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.blk.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.existings {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.excludes {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.numAdditionalNodes {
            os.write_uint32(5, v)?;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(6, &v)?;
        }
        for v in &self.existingStorageUuids {
            os.write_string(7, &v)?;
        };
        if let Some(v) = self.fileId {
            os.write_uint64(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetAdditionalDatanodeRequestProto {
    fn new() -> GetAdditionalDatanodeRequestProto {
        GetAdditionalDatanodeRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetAdditionalDatanodeRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    GetAdditionalDatanodeRequestProto::get_src_for_reflect,
                    GetAdditionalDatanodeRequestProto::mut_src_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::ExtendedBlockProto>>(
                    "blk",
                    GetAdditionalDatanodeRequestProto::get_blk_for_reflect,
                    GetAdditionalDatanodeRequestProto::mut_blk_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DatanodeInfoProto>>(
                    "existings",
                    GetAdditionalDatanodeRequestProto::get_existings_for_reflect,
                    GetAdditionalDatanodeRequestProto::mut_existings_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DatanodeInfoProto>>(
                    "excludes",
                    GetAdditionalDatanodeRequestProto::get_excludes_for_reflect,
                    GetAdditionalDatanodeRequestProto::mut_excludes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "numAdditionalNodes",
                    GetAdditionalDatanodeRequestProto::get_numAdditionalNodes_for_reflect,
                    GetAdditionalDatanodeRequestProto::mut_numAdditionalNodes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "clientName",
                    GetAdditionalDatanodeRequestProto::get_clientName_for_reflect,
                    GetAdditionalDatanodeRequestProto::mut_clientName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "existingStorageUuids",
                    GetAdditionalDatanodeRequestProto::get_existingStorageUuids_for_reflect,
                    GetAdditionalDatanodeRequestProto::mut_existingStorageUuids_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fileId",
                    GetAdditionalDatanodeRequestProto::get_fileId_for_reflect,
                    GetAdditionalDatanodeRequestProto::mut_fileId_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetAdditionalDatanodeRequestProto>(
                    "GetAdditionalDatanodeRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetAdditionalDatanodeRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_blk();
        self.clear_existings();
        self.clear_excludes();
        self.clear_numAdditionalNodes();
        self.clear_clientName();
        self.clear_existingStorageUuids();
        self.clear_fileId();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAdditionalDatanodeRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAdditionalDatanodeRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetAdditionalDatanodeResponseProto {
    // message fields
    block: ::protobuf::SingularPtrField<super::hdfs::LocatedBlockProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetAdditionalDatanodeResponseProto {}

impl GetAdditionalDatanodeResponseProto {
    pub fn new() -> GetAdditionalDatanodeResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetAdditionalDatanodeResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetAdditionalDatanodeResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetAdditionalDatanodeResponseProto,
        };
        unsafe {
            instance.get(GetAdditionalDatanodeResponseProto::new)
        }
    }

    // required .hadoop.hdfs.LocatedBlockProto block = 1;

    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    pub fn has_block(&self) -> bool {
        self.block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: super::hdfs::LocatedBlockProto) {
        self.block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block(&mut self) -> &mut super::hdfs::LocatedBlockProto {
        if self.block.is_none() {
            self.block.set_default();
        }
        self.block.as_mut().unwrap()
    }

    // Take field
    pub fn take_block(&mut self) -> super::hdfs::LocatedBlockProto {
        self.block.take().unwrap_or_else(|| super::hdfs::LocatedBlockProto::new())
    }

    pub fn get_block(&self) -> &super::hdfs::LocatedBlockProto {
        self.block.as_ref().unwrap_or_else(|| super::hdfs::LocatedBlockProto::default_instance())
    }

    fn get_block_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::LocatedBlockProto> {
        &self.block
    }

    fn mut_block_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::LocatedBlockProto> {
        &mut self.block
    }
}

impl ::protobuf::Message for GetAdditionalDatanodeResponseProto {
    fn is_initialized(&self) -> bool {
        if self.block.is_none() {
            return false;
        }
        for v in &self.block {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.block)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.block.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetAdditionalDatanodeResponseProto {
    fn new() -> GetAdditionalDatanodeResponseProto {
        GetAdditionalDatanodeResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetAdditionalDatanodeResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::LocatedBlockProto>>(
                    "block",
                    GetAdditionalDatanodeResponseProto::get_block_for_reflect,
                    GetAdditionalDatanodeResponseProto::mut_block_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetAdditionalDatanodeResponseProto>(
                    "GetAdditionalDatanodeResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetAdditionalDatanodeResponseProto {
    fn clear(&mut self) {
        self.clear_block();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAdditionalDatanodeResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAdditionalDatanodeResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompleteRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    last: ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto>,
    fileId: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CompleteRequestProto {}

impl CompleteRequestProto {
    pub fn new() -> CompleteRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CompleteRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<CompleteRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CompleteRequestProto,
        };
        unsafe {
            instance.get(CompleteRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }

    // required string clientName = 2;

    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_clientName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.clientName
    }

    fn mut_clientName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.clientName
    }

    // optional .hadoop.hdfs.ExtendedBlockProto last = 3;

    pub fn clear_last(&mut self) {
        self.last.clear();
    }

    pub fn has_last(&self) -> bool {
        self.last.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last(&mut self, v: super::hdfs::ExtendedBlockProto) {
        self.last = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last(&mut self) -> &mut super::hdfs::ExtendedBlockProto {
        if self.last.is_none() {
            self.last.set_default();
        }
        self.last.as_mut().unwrap()
    }

    // Take field
    pub fn take_last(&mut self) -> super::hdfs::ExtendedBlockProto {
        self.last.take().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::new())
    }

    pub fn get_last(&self) -> &super::hdfs::ExtendedBlockProto {
        self.last.as_ref().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::default_instance())
    }

    fn get_last_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto> {
        &self.last
    }

    fn mut_last_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto> {
        &mut self.last
    }

    // optional uint64 fileId = 4;

    pub fn clear_fileId(&mut self) {
        self.fileId = ::std::option::Option::None;
    }

    pub fn has_fileId(&self) -> bool {
        self.fileId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileId(&mut self, v: u64) {
        self.fileId = ::std::option::Option::Some(v);
    }

    pub fn get_fileId(&self) -> u64 {
        self.fileId.unwrap_or(0u64)
    }

    fn get_fileId_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.fileId
    }

    fn mut_fileId_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.fileId
    }
}

impl ::protobuf::Message for CompleteRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.clientName.is_none() {
            return false;
        }
        for v in &self.last {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.last)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fileId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.last.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.fileId {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.last.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.fileId {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CompleteRequestProto {
    fn new() -> CompleteRequestProto {
        CompleteRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CompleteRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    CompleteRequestProto::get_src_for_reflect,
                    CompleteRequestProto::mut_src_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "clientName",
                    CompleteRequestProto::get_clientName_for_reflect,
                    CompleteRequestProto::mut_clientName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::ExtendedBlockProto>>(
                    "last",
                    CompleteRequestProto::get_last_for_reflect,
                    CompleteRequestProto::mut_last_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fileId",
                    CompleteRequestProto::get_fileId_for_reflect,
                    CompleteRequestProto::mut_fileId_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CompleteRequestProto>(
                    "CompleteRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CompleteRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_clientName();
        self.clear_last();
        self.clear_fileId();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CompleteRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompleteRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompleteResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CompleteResponseProto {}

impl CompleteResponseProto {
    pub fn new() -> CompleteResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CompleteResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<CompleteResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CompleteResponseProto,
        };
        unsafe {
            instance.get(CompleteResponseProto::new)
        }
    }

    // required bool result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.result
    }
}

impl ::protobuf::Message for CompleteResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CompleteResponseProto {
    fn new() -> CompleteResponseProto {
        CompleteResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CompleteResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    CompleteResponseProto::get_result_for_reflect,
                    CompleteResponseProto::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CompleteResponseProto>(
                    "CompleteResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CompleteResponseProto {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CompleteResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompleteResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReportBadBlocksRequestProto {
    // message fields
    blocks: ::protobuf::RepeatedField<super::hdfs::LocatedBlockProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ReportBadBlocksRequestProto {}

impl ReportBadBlocksRequestProto {
    pub fn new() -> ReportBadBlocksRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ReportBadBlocksRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<ReportBadBlocksRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReportBadBlocksRequestProto,
        };
        unsafe {
            instance.get(ReportBadBlocksRequestProto::new)
        }
    }

    // repeated .hadoop.hdfs.LocatedBlockProto blocks = 1;

    pub fn clear_blocks(&mut self) {
        self.blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_blocks(&mut self, v: ::protobuf::RepeatedField<super::hdfs::LocatedBlockProto>) {
        self.blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blocks(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::LocatedBlockProto> {
        &mut self.blocks
    }

    // Take field
    pub fn take_blocks(&mut self) -> ::protobuf::RepeatedField<super::hdfs::LocatedBlockProto> {
        ::std::mem::replace(&mut self.blocks, ::protobuf::RepeatedField::new())
    }

    pub fn get_blocks(&self) -> &[super::hdfs::LocatedBlockProto] {
        &self.blocks
    }

    fn get_blocks_for_reflect(&self) -> &::protobuf::RepeatedField<super::hdfs::LocatedBlockProto> {
        &self.blocks
    }

    fn mut_blocks_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::LocatedBlockProto> {
        &mut self.blocks
    }
}

impl ::protobuf::Message for ReportBadBlocksRequestProto {
    fn is_initialized(&self) -> bool {
        for v in &self.blocks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blocks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.blocks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.blocks {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ReportBadBlocksRequestProto {
    fn new() -> ReportBadBlocksRequestProto {
        ReportBadBlocksRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ReportBadBlocksRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::LocatedBlockProto>>(
                    "blocks",
                    ReportBadBlocksRequestProto::get_blocks_for_reflect,
                    ReportBadBlocksRequestProto::mut_blocks_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReportBadBlocksRequestProto>(
                    "ReportBadBlocksRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ReportBadBlocksRequestProto {
    fn clear(&mut self) {
        self.clear_blocks();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReportBadBlocksRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReportBadBlocksRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReportBadBlocksResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ReportBadBlocksResponseProto {}

impl ReportBadBlocksResponseProto {
    pub fn new() -> ReportBadBlocksResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ReportBadBlocksResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<ReportBadBlocksResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReportBadBlocksResponseProto,
        };
        unsafe {
            instance.get(ReportBadBlocksResponseProto::new)
        }
    }
}

impl ::protobuf::Message for ReportBadBlocksResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ReportBadBlocksResponseProto {
    fn new() -> ReportBadBlocksResponseProto {
        ReportBadBlocksResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ReportBadBlocksResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ReportBadBlocksResponseProto>(
                    "ReportBadBlocksResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ReportBadBlocksResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReportBadBlocksResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReportBadBlocksResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConcatRequestProto {
    // message fields
    trg: ::protobuf::SingularField<::std::string::String>,
    srcs: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ConcatRequestProto {}

impl ConcatRequestProto {
    pub fn new() -> ConcatRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ConcatRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<ConcatRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConcatRequestProto,
        };
        unsafe {
            instance.get(ConcatRequestProto::new)
        }
    }

    // required string trg = 1;

    pub fn clear_trg(&mut self) {
        self.trg.clear();
    }

    pub fn has_trg(&self) -> bool {
        self.trg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trg(&mut self, v: ::std::string::String) {
        self.trg = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trg(&mut self) -> &mut ::std::string::String {
        if self.trg.is_none() {
            self.trg.set_default();
        }
        self.trg.as_mut().unwrap()
    }

    // Take field
    pub fn take_trg(&mut self) -> ::std::string::String {
        self.trg.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_trg(&self) -> &str {
        match self.trg.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_trg_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.trg
    }

    fn mut_trg_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.trg
    }

    // repeated string srcs = 2;

    pub fn clear_srcs(&mut self) {
        self.srcs.clear();
    }

    // Param is passed by value, moved
    pub fn set_srcs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.srcs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_srcs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.srcs
    }

    // Take field
    pub fn take_srcs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.srcs, ::protobuf::RepeatedField::new())
    }

    pub fn get_srcs(&self) -> &[::std::string::String] {
        &self.srcs
    }

    fn get_srcs_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.srcs
    }

    fn mut_srcs_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.srcs
    }
}

impl ::protobuf::Message for ConcatRequestProto {
    fn is_initialized(&self) -> bool {
        if self.trg.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.trg)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.srcs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.trg.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.srcs {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.trg.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.srcs {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ConcatRequestProto {
    fn new() -> ConcatRequestProto {
        ConcatRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ConcatRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "trg",
                    ConcatRequestProto::get_trg_for_reflect,
                    ConcatRequestProto::mut_trg_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "srcs",
                    ConcatRequestProto::get_srcs_for_reflect,
                    ConcatRequestProto::mut_srcs_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConcatRequestProto>(
                    "ConcatRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ConcatRequestProto {
    fn clear(&mut self) {
        self.clear_trg();
        self.clear_srcs();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConcatRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConcatRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConcatResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ConcatResponseProto {}

impl ConcatResponseProto {
    pub fn new() -> ConcatResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ConcatResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<ConcatResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConcatResponseProto,
        };
        unsafe {
            instance.get(ConcatResponseProto::new)
        }
    }
}

impl ::protobuf::Message for ConcatResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ConcatResponseProto {
    fn new() -> ConcatResponseProto {
        ConcatResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ConcatResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ConcatResponseProto>(
                    "ConcatResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ConcatResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConcatResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConcatResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RenameRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    dst: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RenameRequestProto {}

impl RenameRequestProto {
    pub fn new() -> RenameRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RenameRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RenameRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RenameRequestProto,
        };
        unsafe {
            instance.get(RenameRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }

    // required string dst = 2;

    pub fn clear_dst(&mut self) {
        self.dst.clear();
    }

    pub fn has_dst(&self) -> bool {
        self.dst.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dst(&mut self, v: ::std::string::String) {
        self.dst = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dst(&mut self) -> &mut ::std::string::String {
        if self.dst.is_none() {
            self.dst.set_default();
        }
        self.dst.as_mut().unwrap()
    }

    // Take field
    pub fn take_dst(&mut self) -> ::std::string::String {
        self.dst.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_dst(&self) -> &str {
        match self.dst.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_dst_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.dst
    }

    fn mut_dst_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.dst
    }
}

impl ::protobuf::Message for RenameRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.dst.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.dst)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.dst.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.dst.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RenameRequestProto {
    fn new() -> RenameRequestProto {
        RenameRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RenameRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    RenameRequestProto::get_src_for_reflect,
                    RenameRequestProto::mut_src_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dst",
                    RenameRequestProto::get_dst_for_reflect,
                    RenameRequestProto::mut_dst_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RenameRequestProto>(
                    "RenameRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RenameRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_dst();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RenameRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RenameRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RenameResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RenameResponseProto {}

impl RenameResponseProto {
    pub fn new() -> RenameResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RenameResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RenameResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RenameResponseProto,
        };
        unsafe {
            instance.get(RenameResponseProto::new)
        }
    }

    // required bool result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.result
    }
}

impl ::protobuf::Message for RenameResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RenameResponseProto {
    fn new() -> RenameResponseProto {
        RenameResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RenameResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    RenameResponseProto::get_result_for_reflect,
                    RenameResponseProto::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RenameResponseProto>(
                    "RenameResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RenameResponseProto {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RenameResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RenameResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Rename2RequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    dst: ::protobuf::SingularField<::std::string::String>,
    overwriteDest: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Rename2RequestProto {}

impl Rename2RequestProto {
    pub fn new() -> Rename2RequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Rename2RequestProto {
        static mut instance: ::protobuf::lazy::Lazy<Rename2RequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Rename2RequestProto,
        };
        unsafe {
            instance.get(Rename2RequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }

    // required string dst = 2;

    pub fn clear_dst(&mut self) {
        self.dst.clear();
    }

    pub fn has_dst(&self) -> bool {
        self.dst.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dst(&mut self, v: ::std::string::String) {
        self.dst = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dst(&mut self) -> &mut ::std::string::String {
        if self.dst.is_none() {
            self.dst.set_default();
        }
        self.dst.as_mut().unwrap()
    }

    // Take field
    pub fn take_dst(&mut self) -> ::std::string::String {
        self.dst.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_dst(&self) -> &str {
        match self.dst.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_dst_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.dst
    }

    fn mut_dst_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.dst
    }

    // required bool overwriteDest = 3;

    pub fn clear_overwriteDest(&mut self) {
        self.overwriteDest = ::std::option::Option::None;
    }

    pub fn has_overwriteDest(&self) -> bool {
        self.overwriteDest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overwriteDest(&mut self, v: bool) {
        self.overwriteDest = ::std::option::Option::Some(v);
    }

    pub fn get_overwriteDest(&self) -> bool {
        self.overwriteDest.unwrap_or(false)
    }

    fn get_overwriteDest_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.overwriteDest
    }

    fn mut_overwriteDest_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.overwriteDest
    }
}

impl ::protobuf::Message for Rename2RequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.dst.is_none() {
            return false;
        }
        if self.overwriteDest.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.dst)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.overwriteDest = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.dst.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.overwriteDest {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.dst.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.overwriteDest {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Rename2RequestProto {
    fn new() -> Rename2RequestProto {
        Rename2RequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<Rename2RequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    Rename2RequestProto::get_src_for_reflect,
                    Rename2RequestProto::mut_src_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dst",
                    Rename2RequestProto::get_dst_for_reflect,
                    Rename2RequestProto::mut_dst_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "overwriteDest",
                    Rename2RequestProto::get_overwriteDest_for_reflect,
                    Rename2RequestProto::mut_overwriteDest_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Rename2RequestProto>(
                    "Rename2RequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Rename2RequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_dst();
        self.clear_overwriteDest();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Rename2RequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rename2RequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Rename2ResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Rename2ResponseProto {}

impl Rename2ResponseProto {
    pub fn new() -> Rename2ResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Rename2ResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<Rename2ResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Rename2ResponseProto,
        };
        unsafe {
            instance.get(Rename2ResponseProto::new)
        }
    }
}

impl ::protobuf::Message for Rename2ResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Rename2ResponseProto {
    fn new() -> Rename2ResponseProto {
        Rename2ResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<Rename2ResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Rename2ResponseProto>(
                    "Rename2ResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Rename2ResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Rename2ResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rename2ResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    recursive: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for DeleteRequestProto {}

impl DeleteRequestProto {
    pub fn new() -> DeleteRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DeleteRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<DeleteRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteRequestProto,
        };
        unsafe {
            instance.get(DeleteRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }

    // required bool recursive = 2;

    pub fn clear_recursive(&mut self) {
        self.recursive = ::std::option::Option::None;
    }

    pub fn has_recursive(&self) -> bool {
        self.recursive.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recursive(&mut self, v: bool) {
        self.recursive = ::std::option::Option::Some(v);
    }

    pub fn get_recursive(&self) -> bool {
        self.recursive.unwrap_or(false)
    }

    fn get_recursive_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.recursive
    }

    fn mut_recursive_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.recursive
    }
}

impl ::protobuf::Message for DeleteRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.recursive.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.recursive = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.recursive {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.recursive {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DeleteRequestProto {
    fn new() -> DeleteRequestProto {
        DeleteRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<DeleteRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    DeleteRequestProto::get_src_for_reflect,
                    DeleteRequestProto::mut_src_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "recursive",
                    DeleteRequestProto::get_recursive_for_reflect,
                    DeleteRequestProto::mut_recursive_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteRequestProto>(
                    "DeleteRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DeleteRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_recursive();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for DeleteResponseProto {}

impl DeleteResponseProto {
    pub fn new() -> DeleteResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DeleteResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<DeleteResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteResponseProto,
        };
        unsafe {
            instance.get(DeleteResponseProto::new)
        }
    }

    // required bool result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.result
    }
}

impl ::protobuf::Message for DeleteResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DeleteResponseProto {
    fn new() -> DeleteResponseProto {
        DeleteResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<DeleteResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    DeleteResponseProto::get_result_for_reflect,
                    DeleteResponseProto::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteResponseProto>(
                    "DeleteResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DeleteResponseProto {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MkdirsRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    masked: ::protobuf::SingularPtrField<super::hdfs::FsPermissionProto>,
    createParent: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for MkdirsRequestProto {}

impl MkdirsRequestProto {
    pub fn new() -> MkdirsRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static MkdirsRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<MkdirsRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MkdirsRequestProto,
        };
        unsafe {
            instance.get(MkdirsRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }

    // required .hadoop.hdfs.FsPermissionProto masked = 2;

    pub fn clear_masked(&mut self) {
        self.masked.clear();
    }

    pub fn has_masked(&self) -> bool {
        self.masked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_masked(&mut self, v: super::hdfs::FsPermissionProto) {
        self.masked = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_masked(&mut self) -> &mut super::hdfs::FsPermissionProto {
        if self.masked.is_none() {
            self.masked.set_default();
        }
        self.masked.as_mut().unwrap()
    }

    // Take field
    pub fn take_masked(&mut self) -> super::hdfs::FsPermissionProto {
        self.masked.take().unwrap_or_else(|| super::hdfs::FsPermissionProto::new())
    }

    pub fn get_masked(&self) -> &super::hdfs::FsPermissionProto {
        self.masked.as_ref().unwrap_or_else(|| super::hdfs::FsPermissionProto::default_instance())
    }

    fn get_masked_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::FsPermissionProto> {
        &self.masked
    }

    fn mut_masked_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::FsPermissionProto> {
        &mut self.masked
    }

    // required bool createParent = 3;

    pub fn clear_createParent(&mut self) {
        self.createParent = ::std::option::Option::None;
    }

    pub fn has_createParent(&self) -> bool {
        self.createParent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_createParent(&mut self, v: bool) {
        self.createParent = ::std::option::Option::Some(v);
    }

    pub fn get_createParent(&self) -> bool {
        self.createParent.unwrap_or(false)
    }

    fn get_createParent_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.createParent
    }

    fn mut_createParent_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.createParent
    }
}

impl ::protobuf::Message for MkdirsRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.masked.is_none() {
            return false;
        }
        if self.createParent.is_none() {
            return false;
        }
        for v in &self.masked {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.masked)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.createParent = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.masked.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.createParent {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.masked.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.createParent {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for MkdirsRequestProto {
    fn new() -> MkdirsRequestProto {
        MkdirsRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<MkdirsRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    MkdirsRequestProto::get_src_for_reflect,
                    MkdirsRequestProto::mut_src_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::FsPermissionProto>>(
                    "masked",
                    MkdirsRequestProto::get_masked_for_reflect,
                    MkdirsRequestProto::mut_masked_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "createParent",
                    MkdirsRequestProto::get_createParent_for_reflect,
                    MkdirsRequestProto::mut_createParent_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MkdirsRequestProto>(
                    "MkdirsRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for MkdirsRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_masked();
        self.clear_createParent();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MkdirsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MkdirsRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MkdirsResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for MkdirsResponseProto {}

impl MkdirsResponseProto {
    pub fn new() -> MkdirsResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static MkdirsResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<MkdirsResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MkdirsResponseProto,
        };
        unsafe {
            instance.get(MkdirsResponseProto::new)
        }
    }

    // required bool result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.result
    }
}

impl ::protobuf::Message for MkdirsResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for MkdirsResponseProto {
    fn new() -> MkdirsResponseProto {
        MkdirsResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<MkdirsResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    MkdirsResponseProto::get_result_for_reflect,
                    MkdirsResponseProto::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MkdirsResponseProto>(
                    "MkdirsResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for MkdirsResponseProto {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MkdirsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MkdirsResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetListingRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    startAfter: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    needLocation: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetListingRequestProto {}

impl GetListingRequestProto {
    pub fn new() -> GetListingRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetListingRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetListingRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetListingRequestProto,
        };
        unsafe {
            instance.get(GetListingRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }

    // required bytes startAfter = 2;

    pub fn clear_startAfter(&mut self) {
        self.startAfter.clear();
    }

    pub fn has_startAfter(&self) -> bool {
        self.startAfter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startAfter(&mut self, v: ::std::vec::Vec<u8>) {
        self.startAfter = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_startAfter(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.startAfter.is_none() {
            self.startAfter.set_default();
        }
        self.startAfter.as_mut().unwrap()
    }

    // Take field
    pub fn take_startAfter(&mut self) -> ::std::vec::Vec<u8> {
        self.startAfter.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_startAfter(&self) -> &[u8] {
        match self.startAfter.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_startAfter_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.startAfter
    }

    fn mut_startAfter_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.startAfter
    }

    // required bool needLocation = 3;

    pub fn clear_needLocation(&mut self) {
        self.needLocation = ::std::option::Option::None;
    }

    pub fn has_needLocation(&self) -> bool {
        self.needLocation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needLocation(&mut self, v: bool) {
        self.needLocation = ::std::option::Option::Some(v);
    }

    pub fn get_needLocation(&self) -> bool {
        self.needLocation.unwrap_or(false)
    }

    fn get_needLocation_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.needLocation
    }

    fn mut_needLocation_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.needLocation
    }
}

impl ::protobuf::Message for GetListingRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.startAfter.is_none() {
            return false;
        }
        if self.needLocation.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.startAfter)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.needLocation = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.startAfter.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.needLocation {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.startAfter.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.needLocation {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetListingRequestProto {
    fn new() -> GetListingRequestProto {
        GetListingRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetListingRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    GetListingRequestProto::get_src_for_reflect,
                    GetListingRequestProto::mut_src_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "startAfter",
                    GetListingRequestProto::get_startAfter_for_reflect,
                    GetListingRequestProto::mut_startAfter_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "needLocation",
                    GetListingRequestProto::get_needLocation_for_reflect,
                    GetListingRequestProto::mut_needLocation_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetListingRequestProto>(
                    "GetListingRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetListingRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_startAfter();
        self.clear_needLocation();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetListingRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetListingRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetListingResponseProto {
    // message fields
    dirList: ::protobuf::SingularPtrField<super::hdfs::DirectoryListingProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetListingResponseProto {}

impl GetListingResponseProto {
    pub fn new() -> GetListingResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetListingResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetListingResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetListingResponseProto,
        };
        unsafe {
            instance.get(GetListingResponseProto::new)
        }
    }

    // optional .hadoop.hdfs.DirectoryListingProto dirList = 1;

    pub fn clear_dirList(&mut self) {
        self.dirList.clear();
    }

    pub fn has_dirList(&self) -> bool {
        self.dirList.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dirList(&mut self, v: super::hdfs::DirectoryListingProto) {
        self.dirList = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dirList(&mut self) -> &mut super::hdfs::DirectoryListingProto {
        if self.dirList.is_none() {
            self.dirList.set_default();
        }
        self.dirList.as_mut().unwrap()
    }

    // Take field
    pub fn take_dirList(&mut self) -> super::hdfs::DirectoryListingProto {
        self.dirList.take().unwrap_or_else(|| super::hdfs::DirectoryListingProto::new())
    }

    pub fn get_dirList(&self) -> &super::hdfs::DirectoryListingProto {
        self.dirList.as_ref().unwrap_or_else(|| super::hdfs::DirectoryListingProto::default_instance())
    }

    fn get_dirList_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::DirectoryListingProto> {
        &self.dirList
    }

    fn mut_dirList_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::DirectoryListingProto> {
        &mut self.dirList
    }
}

impl ::protobuf::Message for GetListingResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.dirList {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dirList)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.dirList.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.dirList.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetListingResponseProto {
    fn new() -> GetListingResponseProto {
        GetListingResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetListingResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DirectoryListingProto>>(
                    "dirList",
                    GetListingResponseProto::get_dirList_for_reflect,
                    GetListingResponseProto::mut_dirList_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetListingResponseProto>(
                    "GetListingResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetListingResponseProto {
    fn clear(&mut self) {
        self.clear_dirList();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetListingResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetListingResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSnapshottableDirListingRequestProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetSnapshottableDirListingRequestProto {}

impl GetSnapshottableDirListingRequestProto {
    pub fn new() -> GetSnapshottableDirListingRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetSnapshottableDirListingRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetSnapshottableDirListingRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetSnapshottableDirListingRequestProto,
        };
        unsafe {
            instance.get(GetSnapshottableDirListingRequestProto::new)
        }
    }
}

impl ::protobuf::Message for GetSnapshottableDirListingRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetSnapshottableDirListingRequestProto {
    fn new() -> GetSnapshottableDirListingRequestProto {
        GetSnapshottableDirListingRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetSnapshottableDirListingRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<GetSnapshottableDirListingRequestProto>(
                    "GetSnapshottableDirListingRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetSnapshottableDirListingRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSnapshottableDirListingRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSnapshottableDirListingRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSnapshottableDirListingResponseProto {
    // message fields
    snapshottableDirList: ::protobuf::SingularPtrField<super::hdfs::SnapshottableDirectoryListingProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetSnapshottableDirListingResponseProto {}

impl GetSnapshottableDirListingResponseProto {
    pub fn new() -> GetSnapshottableDirListingResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetSnapshottableDirListingResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetSnapshottableDirListingResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetSnapshottableDirListingResponseProto,
        };
        unsafe {
            instance.get(GetSnapshottableDirListingResponseProto::new)
        }
    }

    // optional .hadoop.hdfs.SnapshottableDirectoryListingProto snapshottableDirList = 1;

    pub fn clear_snapshottableDirList(&mut self) {
        self.snapshottableDirList.clear();
    }

    pub fn has_snapshottableDirList(&self) -> bool {
        self.snapshottableDirList.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshottableDirList(&mut self, v: super::hdfs::SnapshottableDirectoryListingProto) {
        self.snapshottableDirList = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshottableDirList(&mut self) -> &mut super::hdfs::SnapshottableDirectoryListingProto {
        if self.snapshottableDirList.is_none() {
            self.snapshottableDirList.set_default();
        }
        self.snapshottableDirList.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshottableDirList(&mut self) -> super::hdfs::SnapshottableDirectoryListingProto {
        self.snapshottableDirList.take().unwrap_or_else(|| super::hdfs::SnapshottableDirectoryListingProto::new())
    }

    pub fn get_snapshottableDirList(&self) -> &super::hdfs::SnapshottableDirectoryListingProto {
        self.snapshottableDirList.as_ref().unwrap_or_else(|| super::hdfs::SnapshottableDirectoryListingProto::default_instance())
    }

    fn get_snapshottableDirList_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::SnapshottableDirectoryListingProto> {
        &self.snapshottableDirList
    }

    fn mut_snapshottableDirList_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::SnapshottableDirectoryListingProto> {
        &mut self.snapshottableDirList
    }
}

impl ::protobuf::Message for GetSnapshottableDirListingResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.snapshottableDirList {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.snapshottableDirList)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshottableDirList.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshottableDirList.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetSnapshottableDirListingResponseProto {
    fn new() -> GetSnapshottableDirListingResponseProto {
        GetSnapshottableDirListingResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetSnapshottableDirListingResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::SnapshottableDirectoryListingProto>>(
                    "snapshottableDirList",
                    GetSnapshottableDirListingResponseProto::get_snapshottableDirList_for_reflect,
                    GetSnapshottableDirListingResponseProto::mut_snapshottableDirList_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetSnapshottableDirListingResponseProto>(
                    "GetSnapshottableDirListingResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetSnapshottableDirListingResponseProto {
    fn clear(&mut self) {
        self.clear_snapshottableDirList();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSnapshottableDirListingResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSnapshottableDirListingResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSnapshotDiffReportRequestProto {
    // message fields
    snapshotRoot: ::protobuf::SingularField<::std::string::String>,
    fromSnapshot: ::protobuf::SingularField<::std::string::String>,
    toSnapshot: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetSnapshotDiffReportRequestProto {}

impl GetSnapshotDiffReportRequestProto {
    pub fn new() -> GetSnapshotDiffReportRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetSnapshotDiffReportRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetSnapshotDiffReportRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetSnapshotDiffReportRequestProto,
        };
        unsafe {
            instance.get(GetSnapshotDiffReportRequestProto::new)
        }
    }

    // required string snapshotRoot = 1;

    pub fn clear_snapshotRoot(&mut self) {
        self.snapshotRoot.clear();
    }

    pub fn has_snapshotRoot(&self) -> bool {
        self.snapshotRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotRoot(&mut self, v: ::std::string::String) {
        self.snapshotRoot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotRoot(&mut self) -> &mut ::std::string::String {
        if self.snapshotRoot.is_none() {
            self.snapshotRoot.set_default();
        }
        self.snapshotRoot.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotRoot(&mut self) -> ::std::string::String {
        self.snapshotRoot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_snapshotRoot(&self) -> &str {
        match self.snapshotRoot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_snapshotRoot_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.snapshotRoot
    }

    fn mut_snapshotRoot_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.snapshotRoot
    }

    // required string fromSnapshot = 2;

    pub fn clear_fromSnapshot(&mut self) {
        self.fromSnapshot.clear();
    }

    pub fn has_fromSnapshot(&self) -> bool {
        self.fromSnapshot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fromSnapshot(&mut self, v: ::std::string::String) {
        self.fromSnapshot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fromSnapshot(&mut self) -> &mut ::std::string::String {
        if self.fromSnapshot.is_none() {
            self.fromSnapshot.set_default();
        }
        self.fromSnapshot.as_mut().unwrap()
    }

    // Take field
    pub fn take_fromSnapshot(&mut self) -> ::std::string::String {
        self.fromSnapshot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_fromSnapshot(&self) -> &str {
        match self.fromSnapshot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_fromSnapshot_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.fromSnapshot
    }

    fn mut_fromSnapshot_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.fromSnapshot
    }

    // required string toSnapshot = 3;

    pub fn clear_toSnapshot(&mut self) {
        self.toSnapshot.clear();
    }

    pub fn has_toSnapshot(&self) -> bool {
        self.toSnapshot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_toSnapshot(&mut self, v: ::std::string::String) {
        self.toSnapshot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_toSnapshot(&mut self) -> &mut ::std::string::String {
        if self.toSnapshot.is_none() {
            self.toSnapshot.set_default();
        }
        self.toSnapshot.as_mut().unwrap()
    }

    // Take field
    pub fn take_toSnapshot(&mut self) -> ::std::string::String {
        self.toSnapshot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_toSnapshot(&self) -> &str {
        match self.toSnapshot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_toSnapshot_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.toSnapshot
    }

    fn mut_toSnapshot_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.toSnapshot
    }
}

impl ::protobuf::Message for GetSnapshotDiffReportRequestProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotRoot.is_none() {
            return false;
        }
        if self.fromSnapshot.is_none() {
            return false;
        }
        if self.toSnapshot.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotRoot)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fromSnapshot)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.toSnapshot)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.fromSnapshot.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.toSnapshot.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.fromSnapshot.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.toSnapshot.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetSnapshotDiffReportRequestProto {
    fn new() -> GetSnapshotDiffReportRequestProto {
        GetSnapshotDiffReportRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetSnapshotDiffReportRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "snapshotRoot",
                    GetSnapshotDiffReportRequestProto::get_snapshotRoot_for_reflect,
                    GetSnapshotDiffReportRequestProto::mut_snapshotRoot_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fromSnapshot",
                    GetSnapshotDiffReportRequestProto::get_fromSnapshot_for_reflect,
                    GetSnapshotDiffReportRequestProto::mut_fromSnapshot_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "toSnapshot",
                    GetSnapshotDiffReportRequestProto::get_toSnapshot_for_reflect,
                    GetSnapshotDiffReportRequestProto::mut_toSnapshot_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetSnapshotDiffReportRequestProto>(
                    "GetSnapshotDiffReportRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetSnapshotDiffReportRequestProto {
    fn clear(&mut self) {
        self.clear_snapshotRoot();
        self.clear_fromSnapshot();
        self.clear_toSnapshot();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSnapshotDiffReportRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSnapshotDiffReportRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSnapshotDiffReportResponseProto {
    // message fields
    diffReport: ::protobuf::SingularPtrField<super::hdfs::SnapshotDiffReportProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetSnapshotDiffReportResponseProto {}

impl GetSnapshotDiffReportResponseProto {
    pub fn new() -> GetSnapshotDiffReportResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetSnapshotDiffReportResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetSnapshotDiffReportResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetSnapshotDiffReportResponseProto,
        };
        unsafe {
            instance.get(GetSnapshotDiffReportResponseProto::new)
        }
    }

    // required .hadoop.hdfs.SnapshotDiffReportProto diffReport = 1;

    pub fn clear_diffReport(&mut self) {
        self.diffReport.clear();
    }

    pub fn has_diffReport(&self) -> bool {
        self.diffReport.is_some()
    }

    // Param is passed by value, moved
    pub fn set_diffReport(&mut self, v: super::hdfs::SnapshotDiffReportProto) {
        self.diffReport = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_diffReport(&mut self) -> &mut super::hdfs::SnapshotDiffReportProto {
        if self.diffReport.is_none() {
            self.diffReport.set_default();
        }
        self.diffReport.as_mut().unwrap()
    }

    // Take field
    pub fn take_diffReport(&mut self) -> super::hdfs::SnapshotDiffReportProto {
        self.diffReport.take().unwrap_or_else(|| super::hdfs::SnapshotDiffReportProto::new())
    }

    pub fn get_diffReport(&self) -> &super::hdfs::SnapshotDiffReportProto {
        self.diffReport.as_ref().unwrap_or_else(|| super::hdfs::SnapshotDiffReportProto::default_instance())
    }

    fn get_diffReport_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::SnapshotDiffReportProto> {
        &self.diffReport
    }

    fn mut_diffReport_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::SnapshotDiffReportProto> {
        &mut self.diffReport
    }
}

impl ::protobuf::Message for GetSnapshotDiffReportResponseProto {
    fn is_initialized(&self) -> bool {
        if self.diffReport.is_none() {
            return false;
        }
        for v in &self.diffReport {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.diffReport)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.diffReport.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.diffReport.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetSnapshotDiffReportResponseProto {
    fn new() -> GetSnapshotDiffReportResponseProto {
        GetSnapshotDiffReportResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetSnapshotDiffReportResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::SnapshotDiffReportProto>>(
                    "diffReport",
                    GetSnapshotDiffReportResponseProto::get_diffReport_for_reflect,
                    GetSnapshotDiffReportResponseProto::mut_diffReport_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetSnapshotDiffReportResponseProto>(
                    "GetSnapshotDiffReportResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetSnapshotDiffReportResponseProto {
    fn clear(&mut self) {
        self.clear_diffReport();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSnapshotDiffReportResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSnapshotDiffReportResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RenewLeaseRequestProto {
    // message fields
    clientName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RenewLeaseRequestProto {}

impl RenewLeaseRequestProto {
    pub fn new() -> RenewLeaseRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RenewLeaseRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RenewLeaseRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RenewLeaseRequestProto,
        };
        unsafe {
            instance.get(RenewLeaseRequestProto::new)
        }
    }

    // required string clientName = 1;

    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_clientName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.clientName
    }

    fn mut_clientName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.clientName
    }
}

impl ::protobuf::Message for RenewLeaseRequestProto {
    fn is_initialized(&self) -> bool {
        if self.clientName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RenewLeaseRequestProto {
    fn new() -> RenewLeaseRequestProto {
        RenewLeaseRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RenewLeaseRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "clientName",
                    RenewLeaseRequestProto::get_clientName_for_reflect,
                    RenewLeaseRequestProto::mut_clientName_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RenewLeaseRequestProto>(
                    "RenewLeaseRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RenewLeaseRequestProto {
    fn clear(&mut self) {
        self.clear_clientName();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RenewLeaseRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RenewLeaseRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RenewLeaseResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RenewLeaseResponseProto {}

impl RenewLeaseResponseProto {
    pub fn new() -> RenewLeaseResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RenewLeaseResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RenewLeaseResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RenewLeaseResponseProto,
        };
        unsafe {
            instance.get(RenewLeaseResponseProto::new)
        }
    }
}

impl ::protobuf::Message for RenewLeaseResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RenewLeaseResponseProto {
    fn new() -> RenewLeaseResponseProto {
        RenewLeaseResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RenewLeaseResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RenewLeaseResponseProto>(
                    "RenewLeaseResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RenewLeaseResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RenewLeaseResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RenewLeaseResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RecoverLeaseRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RecoverLeaseRequestProto {}

impl RecoverLeaseRequestProto {
    pub fn new() -> RecoverLeaseRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RecoverLeaseRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RecoverLeaseRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RecoverLeaseRequestProto,
        };
        unsafe {
            instance.get(RecoverLeaseRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }

    // required string clientName = 2;

    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_clientName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.clientName
    }

    fn mut_clientName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.clientName
    }
}

impl ::protobuf::Message for RecoverLeaseRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.clientName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RecoverLeaseRequestProto {
    fn new() -> RecoverLeaseRequestProto {
        RecoverLeaseRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RecoverLeaseRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    RecoverLeaseRequestProto::get_src_for_reflect,
                    RecoverLeaseRequestProto::mut_src_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "clientName",
                    RecoverLeaseRequestProto::get_clientName_for_reflect,
                    RecoverLeaseRequestProto::mut_clientName_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RecoverLeaseRequestProto>(
                    "RecoverLeaseRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RecoverLeaseRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_clientName();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RecoverLeaseRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecoverLeaseRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RecoverLeaseResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RecoverLeaseResponseProto {}

impl RecoverLeaseResponseProto {
    pub fn new() -> RecoverLeaseResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RecoverLeaseResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RecoverLeaseResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RecoverLeaseResponseProto,
        };
        unsafe {
            instance.get(RecoverLeaseResponseProto::new)
        }
    }

    // required bool result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.result
    }
}

impl ::protobuf::Message for RecoverLeaseResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RecoverLeaseResponseProto {
    fn new() -> RecoverLeaseResponseProto {
        RecoverLeaseResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RecoverLeaseResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    RecoverLeaseResponseProto::get_result_for_reflect,
                    RecoverLeaseResponseProto::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RecoverLeaseResponseProto>(
                    "RecoverLeaseResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RecoverLeaseResponseProto {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RecoverLeaseResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecoverLeaseResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFsStatusRequestProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetFsStatusRequestProto {}

impl GetFsStatusRequestProto {
    pub fn new() -> GetFsStatusRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetFsStatusRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetFsStatusRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetFsStatusRequestProto,
        };
        unsafe {
            instance.get(GetFsStatusRequestProto::new)
        }
    }
}

impl ::protobuf::Message for GetFsStatusRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetFsStatusRequestProto {
    fn new() -> GetFsStatusRequestProto {
        GetFsStatusRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetFsStatusRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<GetFsStatusRequestProto>(
                    "GetFsStatusRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetFsStatusRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFsStatusRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFsStatusRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFsStatsResponseProto {
    // message fields
    capacity: ::std::option::Option<u64>,
    used: ::std::option::Option<u64>,
    remaining: ::std::option::Option<u64>,
    under_replicated: ::std::option::Option<u64>,
    corrupt_blocks: ::std::option::Option<u64>,
    missing_blocks: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetFsStatsResponseProto {}

impl GetFsStatsResponseProto {
    pub fn new() -> GetFsStatsResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetFsStatsResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetFsStatsResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetFsStatsResponseProto,
        };
        unsafe {
            instance.get(GetFsStatsResponseProto::new)
        }
    }

    // required uint64 capacity = 1;

    pub fn clear_capacity(&mut self) {
        self.capacity = ::std::option::Option::None;
    }

    pub fn has_capacity(&self) -> bool {
        self.capacity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: u64) {
        self.capacity = ::std::option::Option::Some(v);
    }

    pub fn get_capacity(&self) -> u64 {
        self.capacity.unwrap_or(0)
    }

    fn get_capacity_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.capacity
    }

    fn mut_capacity_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.capacity
    }

    // required uint64 used = 2;

    pub fn clear_used(&mut self) {
        self.used = ::std::option::Option::None;
    }

    pub fn has_used(&self) -> bool {
        self.used.is_some()
    }

    // Param is passed by value, moved
    pub fn set_used(&mut self, v: u64) {
        self.used = ::std::option::Option::Some(v);
    }

    pub fn get_used(&self) -> u64 {
        self.used.unwrap_or(0)
    }

    fn get_used_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.used
    }

    fn mut_used_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.used
    }

    // required uint64 remaining = 3;

    pub fn clear_remaining(&mut self) {
        self.remaining = ::std::option::Option::None;
    }

    pub fn has_remaining(&self) -> bool {
        self.remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remaining(&mut self, v: u64) {
        self.remaining = ::std::option::Option::Some(v);
    }

    pub fn get_remaining(&self) -> u64 {
        self.remaining.unwrap_or(0)
    }

    fn get_remaining_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.remaining
    }

    fn mut_remaining_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.remaining
    }

    // required uint64 under_replicated = 4;

    pub fn clear_under_replicated(&mut self) {
        self.under_replicated = ::std::option::Option::None;
    }

    pub fn has_under_replicated(&self) -> bool {
        self.under_replicated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_under_replicated(&mut self, v: u64) {
        self.under_replicated = ::std::option::Option::Some(v);
    }

    pub fn get_under_replicated(&self) -> u64 {
        self.under_replicated.unwrap_or(0)
    }

    fn get_under_replicated_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.under_replicated
    }

    fn mut_under_replicated_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.under_replicated
    }

    // required uint64 corrupt_blocks = 5;

    pub fn clear_corrupt_blocks(&mut self) {
        self.corrupt_blocks = ::std::option::Option::None;
    }

    pub fn has_corrupt_blocks(&self) -> bool {
        self.corrupt_blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_corrupt_blocks(&mut self, v: u64) {
        self.corrupt_blocks = ::std::option::Option::Some(v);
    }

    pub fn get_corrupt_blocks(&self) -> u64 {
        self.corrupt_blocks.unwrap_or(0)
    }

    fn get_corrupt_blocks_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.corrupt_blocks
    }

    fn mut_corrupt_blocks_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.corrupt_blocks
    }

    // required uint64 missing_blocks = 6;

    pub fn clear_missing_blocks(&mut self) {
        self.missing_blocks = ::std::option::Option::None;
    }

    pub fn has_missing_blocks(&self) -> bool {
        self.missing_blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_missing_blocks(&mut self, v: u64) {
        self.missing_blocks = ::std::option::Option::Some(v);
    }

    pub fn get_missing_blocks(&self) -> u64 {
        self.missing_blocks.unwrap_or(0)
    }

    fn get_missing_blocks_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.missing_blocks
    }

    fn mut_missing_blocks_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.missing_blocks
    }
}

impl ::protobuf::Message for GetFsStatsResponseProto {
    fn is_initialized(&self) -> bool {
        if self.capacity.is_none() {
            return false;
        }
        if self.used.is_none() {
            return false;
        }
        if self.remaining.is_none() {
            return false;
        }
        if self.under_replicated.is_none() {
            return false;
        }
        if self.corrupt_blocks.is_none() {
            return false;
        }
        if self.missing_blocks.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.capacity = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.used = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.remaining = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.under_replicated = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.corrupt_blocks = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.missing_blocks = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.capacity {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.used {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.remaining {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.under_replicated {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.corrupt_blocks {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.missing_blocks {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.capacity {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.used {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.remaining {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.under_replicated {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.corrupt_blocks {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.missing_blocks {
            os.write_uint64(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetFsStatsResponseProto {
    fn new() -> GetFsStatsResponseProto {
        GetFsStatsResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetFsStatsResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "capacity",
                    GetFsStatsResponseProto::get_capacity_for_reflect,
                    GetFsStatsResponseProto::mut_capacity_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "used",
                    GetFsStatsResponseProto::get_used_for_reflect,
                    GetFsStatsResponseProto::mut_used_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "remaining",
                    GetFsStatsResponseProto::get_remaining_for_reflect,
                    GetFsStatsResponseProto::mut_remaining_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "under_replicated",
                    GetFsStatsResponseProto::get_under_replicated_for_reflect,
                    GetFsStatsResponseProto::mut_under_replicated_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "corrupt_blocks",
                    GetFsStatsResponseProto::get_corrupt_blocks_for_reflect,
                    GetFsStatsResponseProto::mut_corrupt_blocks_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "missing_blocks",
                    GetFsStatsResponseProto::get_missing_blocks_for_reflect,
                    GetFsStatsResponseProto::mut_missing_blocks_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetFsStatsResponseProto>(
                    "GetFsStatsResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetFsStatsResponseProto {
    fn clear(&mut self) {
        self.clear_capacity();
        self.clear_used();
        self.clear_remaining();
        self.clear_under_replicated();
        self.clear_corrupt_blocks();
        self.clear_missing_blocks();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFsStatsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFsStatsResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDatanodeReportRequestProto {
    // message fields
    field_type: ::std::option::Option<DatanodeReportTypeProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetDatanodeReportRequestProto {}

impl GetDatanodeReportRequestProto {
    pub fn new() -> GetDatanodeReportRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetDatanodeReportRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetDatanodeReportRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetDatanodeReportRequestProto,
        };
        unsafe {
            instance.get(GetDatanodeReportRequestProto::new)
        }
    }

    // required .hadoop.hdfs.DatanodeReportTypeProto type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: DatanodeReportTypeProto) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> DatanodeReportTypeProto {
        self.field_type.unwrap_or(DatanodeReportTypeProto::ALL)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<DatanodeReportTypeProto> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<DatanodeReportTypeProto> {
        &mut self.field_type
    }
}

impl ::protobuf::Message for GetDatanodeReportRequestProto {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetDatanodeReportRequestProto {
    fn new() -> GetDatanodeReportRequestProto {
        GetDatanodeReportRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetDatanodeReportRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DatanodeReportTypeProto>>(
                    "type",
                    GetDatanodeReportRequestProto::get_field_type_for_reflect,
                    GetDatanodeReportRequestProto::mut_field_type_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetDatanodeReportRequestProto>(
                    "GetDatanodeReportRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetDatanodeReportRequestProto {
    fn clear(&mut self) {
        self.clear_field_type();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDatanodeReportRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDatanodeReportRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDatanodeReportResponseProto {
    // message fields
    di: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetDatanodeReportResponseProto {}

impl GetDatanodeReportResponseProto {
    pub fn new() -> GetDatanodeReportResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetDatanodeReportResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetDatanodeReportResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetDatanodeReportResponseProto,
        };
        unsafe {
            instance.get(GetDatanodeReportResponseProto::new)
        }
    }

    // repeated .hadoop.hdfs.DatanodeInfoProto di = 1;

    pub fn clear_di(&mut self) {
        self.di.clear();
    }

    // Param is passed by value, moved
    pub fn set_di(&mut self, v: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>) {
        self.di = v;
    }

    // Mutable pointer to the field.
    pub fn mut_di(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        &mut self.di
    }

    // Take field
    pub fn take_di(&mut self) -> ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        ::std::mem::replace(&mut self.di, ::protobuf::RepeatedField::new())
    }

    pub fn get_di(&self) -> &[super::hdfs::DatanodeInfoProto] {
        &self.di
    }

    fn get_di_for_reflect(&self) -> &::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        &self.di
    }

    fn mut_di_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        &mut self.di
    }
}

impl ::protobuf::Message for GetDatanodeReportResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.di {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.di)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.di {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.di {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetDatanodeReportResponseProto {
    fn new() -> GetDatanodeReportResponseProto {
        GetDatanodeReportResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetDatanodeReportResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DatanodeInfoProto>>(
                    "di",
                    GetDatanodeReportResponseProto::get_di_for_reflect,
                    GetDatanodeReportResponseProto::mut_di_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetDatanodeReportResponseProto>(
                    "GetDatanodeReportResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetDatanodeReportResponseProto {
    fn clear(&mut self) {
        self.clear_di();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDatanodeReportResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDatanodeReportResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDatanodeStorageReportRequestProto {
    // message fields
    field_type: ::std::option::Option<DatanodeReportTypeProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetDatanodeStorageReportRequestProto {}

impl GetDatanodeStorageReportRequestProto {
    pub fn new() -> GetDatanodeStorageReportRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetDatanodeStorageReportRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetDatanodeStorageReportRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetDatanodeStorageReportRequestProto,
        };
        unsafe {
            instance.get(GetDatanodeStorageReportRequestProto::new)
        }
    }

    // required .hadoop.hdfs.DatanodeReportTypeProto type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: DatanodeReportTypeProto) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> DatanodeReportTypeProto {
        self.field_type.unwrap_or(DatanodeReportTypeProto::ALL)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<DatanodeReportTypeProto> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<DatanodeReportTypeProto> {
        &mut self.field_type
    }
}

impl ::protobuf::Message for GetDatanodeStorageReportRequestProto {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetDatanodeStorageReportRequestProto {
    fn new() -> GetDatanodeStorageReportRequestProto {
        GetDatanodeStorageReportRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetDatanodeStorageReportRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DatanodeReportTypeProto>>(
                    "type",
                    GetDatanodeStorageReportRequestProto::get_field_type_for_reflect,
                    GetDatanodeStorageReportRequestProto::mut_field_type_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetDatanodeStorageReportRequestProto>(
                    "GetDatanodeStorageReportRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetDatanodeStorageReportRequestProto {
    fn clear(&mut self) {
        self.clear_field_type();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDatanodeStorageReportRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDatanodeStorageReportRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DatanodeStorageReportProto {
    // message fields
    datanodeInfo: ::protobuf::SingularPtrField<super::hdfs::DatanodeInfoProto>,
    storageReports: ::protobuf::RepeatedField<super::hdfs::StorageReportProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for DatanodeStorageReportProto {}

impl DatanodeStorageReportProto {
    pub fn new() -> DatanodeStorageReportProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DatanodeStorageReportProto {
        static mut instance: ::protobuf::lazy::Lazy<DatanodeStorageReportProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DatanodeStorageReportProto,
        };
        unsafe {
            instance.get(DatanodeStorageReportProto::new)
        }
    }

    // required .hadoop.hdfs.DatanodeInfoProto datanodeInfo = 1;

    pub fn clear_datanodeInfo(&mut self) {
        self.datanodeInfo.clear();
    }

    pub fn has_datanodeInfo(&self) -> bool {
        self.datanodeInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_datanodeInfo(&mut self, v: super::hdfs::DatanodeInfoProto) {
        self.datanodeInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_datanodeInfo(&mut self) -> &mut super::hdfs::DatanodeInfoProto {
        if self.datanodeInfo.is_none() {
            self.datanodeInfo.set_default();
        }
        self.datanodeInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_datanodeInfo(&mut self) -> super::hdfs::DatanodeInfoProto {
        self.datanodeInfo.take().unwrap_or_else(|| super::hdfs::DatanodeInfoProto::new())
    }

    pub fn get_datanodeInfo(&self) -> &super::hdfs::DatanodeInfoProto {
        self.datanodeInfo.as_ref().unwrap_or_else(|| super::hdfs::DatanodeInfoProto::default_instance())
    }

    fn get_datanodeInfo_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::DatanodeInfoProto> {
        &self.datanodeInfo
    }

    fn mut_datanodeInfo_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::DatanodeInfoProto> {
        &mut self.datanodeInfo
    }

    // repeated .hadoop.hdfs.StorageReportProto storageReports = 2;

    pub fn clear_storageReports(&mut self) {
        self.storageReports.clear();
    }

    // Param is passed by value, moved
    pub fn set_storageReports(&mut self, v: ::protobuf::RepeatedField<super::hdfs::StorageReportProto>) {
        self.storageReports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_storageReports(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::StorageReportProto> {
        &mut self.storageReports
    }

    // Take field
    pub fn take_storageReports(&mut self) -> ::protobuf::RepeatedField<super::hdfs::StorageReportProto> {
        ::std::mem::replace(&mut self.storageReports, ::protobuf::RepeatedField::new())
    }

    pub fn get_storageReports(&self) -> &[super::hdfs::StorageReportProto] {
        &self.storageReports
    }

    fn get_storageReports_for_reflect(&self) -> &::protobuf::RepeatedField<super::hdfs::StorageReportProto> {
        &self.storageReports
    }

    fn mut_storageReports_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::StorageReportProto> {
        &mut self.storageReports
    }
}

impl ::protobuf::Message for DatanodeStorageReportProto {
    fn is_initialized(&self) -> bool {
        if self.datanodeInfo.is_none() {
            return false;
        }
        for v in &self.datanodeInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.storageReports {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.datanodeInfo)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.storageReports)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.datanodeInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.storageReports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.datanodeInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.storageReports {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DatanodeStorageReportProto {
    fn new() -> DatanodeStorageReportProto {
        DatanodeStorageReportProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<DatanodeStorageReportProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DatanodeInfoProto>>(
                    "datanodeInfo",
                    DatanodeStorageReportProto::get_datanodeInfo_for_reflect,
                    DatanodeStorageReportProto::mut_datanodeInfo_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::StorageReportProto>>(
                    "storageReports",
                    DatanodeStorageReportProto::get_storageReports_for_reflect,
                    DatanodeStorageReportProto::mut_storageReports_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DatanodeStorageReportProto>(
                    "DatanodeStorageReportProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DatanodeStorageReportProto {
    fn clear(&mut self) {
        self.clear_datanodeInfo();
        self.clear_storageReports();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DatanodeStorageReportProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DatanodeStorageReportProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDatanodeStorageReportResponseProto {
    // message fields
    datanodeStorageReports: ::protobuf::RepeatedField<DatanodeStorageReportProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetDatanodeStorageReportResponseProto {}

impl GetDatanodeStorageReportResponseProto {
    pub fn new() -> GetDatanodeStorageReportResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetDatanodeStorageReportResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetDatanodeStorageReportResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetDatanodeStorageReportResponseProto,
        };
        unsafe {
            instance.get(GetDatanodeStorageReportResponseProto::new)
        }
    }

    // repeated .hadoop.hdfs.DatanodeStorageReportProto datanodeStorageReports = 1;

    pub fn clear_datanodeStorageReports(&mut self) {
        self.datanodeStorageReports.clear();
    }

    // Param is passed by value, moved
    pub fn set_datanodeStorageReports(&mut self, v: ::protobuf::RepeatedField<DatanodeStorageReportProto>) {
        self.datanodeStorageReports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_datanodeStorageReports(&mut self) -> &mut ::protobuf::RepeatedField<DatanodeStorageReportProto> {
        &mut self.datanodeStorageReports
    }

    // Take field
    pub fn take_datanodeStorageReports(&mut self) -> ::protobuf::RepeatedField<DatanodeStorageReportProto> {
        ::std::mem::replace(&mut self.datanodeStorageReports, ::protobuf::RepeatedField::new())
    }

    pub fn get_datanodeStorageReports(&self) -> &[DatanodeStorageReportProto] {
        &self.datanodeStorageReports
    }

    fn get_datanodeStorageReports_for_reflect(&self) -> &::protobuf::RepeatedField<DatanodeStorageReportProto> {
        &self.datanodeStorageReports
    }

    fn mut_datanodeStorageReports_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<DatanodeStorageReportProto> {
        &mut self.datanodeStorageReports
    }
}

impl ::protobuf::Message for GetDatanodeStorageReportResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.datanodeStorageReports {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.datanodeStorageReports)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.datanodeStorageReports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.datanodeStorageReports {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetDatanodeStorageReportResponseProto {
    fn new() -> GetDatanodeStorageReportResponseProto {
        GetDatanodeStorageReportResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetDatanodeStorageReportResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DatanodeStorageReportProto>>(
                    "datanodeStorageReports",
                    GetDatanodeStorageReportResponseProto::get_datanodeStorageReports_for_reflect,
                    GetDatanodeStorageReportResponseProto::mut_datanodeStorageReports_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetDatanodeStorageReportResponseProto>(
                    "GetDatanodeStorageReportResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetDatanodeStorageReportResponseProto {
    fn clear(&mut self) {
        self.clear_datanodeStorageReports();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDatanodeStorageReportResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDatanodeStorageReportResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetPreferredBlockSizeRequestProto {
    // message fields
    filename: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetPreferredBlockSizeRequestProto {}

impl GetPreferredBlockSizeRequestProto {
    pub fn new() -> GetPreferredBlockSizeRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetPreferredBlockSizeRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetPreferredBlockSizeRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetPreferredBlockSizeRequestProto,
        };
        unsafe {
            instance.get(GetPreferredBlockSizeRequestProto::new)
        }
    }

    // required string filename = 1;

    pub fn clear_filename(&mut self) {
        self.filename.clear();
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename.set_default();
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_filename_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.filename
    }

    fn mut_filename_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.filename
    }
}

impl ::protobuf::Message for GetPreferredBlockSizeRequestProto {
    fn is_initialized(&self) -> bool {
        if self.filename.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filename)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.filename.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetPreferredBlockSizeRequestProto {
    fn new() -> GetPreferredBlockSizeRequestProto {
        GetPreferredBlockSizeRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetPreferredBlockSizeRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "filename",
                    GetPreferredBlockSizeRequestProto::get_filename_for_reflect,
                    GetPreferredBlockSizeRequestProto::mut_filename_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetPreferredBlockSizeRequestProto>(
                    "GetPreferredBlockSizeRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetPreferredBlockSizeRequestProto {
    fn clear(&mut self) {
        self.clear_filename();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetPreferredBlockSizeRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPreferredBlockSizeRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetPreferredBlockSizeResponseProto {
    // message fields
    bsize: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetPreferredBlockSizeResponseProto {}

impl GetPreferredBlockSizeResponseProto {
    pub fn new() -> GetPreferredBlockSizeResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetPreferredBlockSizeResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetPreferredBlockSizeResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetPreferredBlockSizeResponseProto,
        };
        unsafe {
            instance.get(GetPreferredBlockSizeResponseProto::new)
        }
    }

    // required uint64 bsize = 1;

    pub fn clear_bsize(&mut self) {
        self.bsize = ::std::option::Option::None;
    }

    pub fn has_bsize(&self) -> bool {
        self.bsize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bsize(&mut self, v: u64) {
        self.bsize = ::std::option::Option::Some(v);
    }

    pub fn get_bsize(&self) -> u64 {
        self.bsize.unwrap_or(0)
    }

    fn get_bsize_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.bsize
    }

    fn mut_bsize_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.bsize
    }
}

impl ::protobuf::Message for GetPreferredBlockSizeResponseProto {
    fn is_initialized(&self) -> bool {
        if self.bsize.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.bsize = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bsize {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bsize {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetPreferredBlockSizeResponseProto {
    fn new() -> GetPreferredBlockSizeResponseProto {
        GetPreferredBlockSizeResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetPreferredBlockSizeResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "bsize",
                    GetPreferredBlockSizeResponseProto::get_bsize_for_reflect,
                    GetPreferredBlockSizeResponseProto::mut_bsize_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetPreferredBlockSizeResponseProto>(
                    "GetPreferredBlockSizeResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetPreferredBlockSizeResponseProto {
    fn clear(&mut self) {
        self.clear_bsize();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetPreferredBlockSizeResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPreferredBlockSizeResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetSafeModeRequestProto {
    // message fields
    action: ::std::option::Option<SafeModeActionProto>,
    checked: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SetSafeModeRequestProto {}

impl SetSafeModeRequestProto {
    pub fn new() -> SetSafeModeRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetSafeModeRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<SetSafeModeRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetSafeModeRequestProto,
        };
        unsafe {
            instance.get(SetSafeModeRequestProto::new)
        }
    }

    // required .hadoop.hdfs.SafeModeActionProto action = 1;

    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: SafeModeActionProto) {
        self.action = ::std::option::Option::Some(v);
    }

    pub fn get_action(&self) -> SafeModeActionProto {
        self.action.unwrap_or(SafeModeActionProto::SAFEMODE_LEAVE)
    }

    fn get_action_for_reflect(&self) -> &::std::option::Option<SafeModeActionProto> {
        &self.action
    }

    fn mut_action_for_reflect(&mut self) -> &mut ::std::option::Option<SafeModeActionProto> {
        &mut self.action
    }

    // optional bool checked = 2;

    pub fn clear_checked(&mut self) {
        self.checked = ::std::option::Option::None;
    }

    pub fn has_checked(&self) -> bool {
        self.checked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checked(&mut self, v: bool) {
        self.checked = ::std::option::Option::Some(v);
    }

    pub fn get_checked(&self) -> bool {
        self.checked.unwrap_or(false)
    }

    fn get_checked_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.checked
    }

    fn mut_checked_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.checked
    }
}

impl ::protobuf::Message for SetSafeModeRequestProto {
    fn is_initialized(&self) -> bool {
        if self.action.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.action = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.checked = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.checked {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.action {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.checked {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetSafeModeRequestProto {
    fn new() -> SetSafeModeRequestProto {
        SetSafeModeRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetSafeModeRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SafeModeActionProto>>(
                    "action",
                    SetSafeModeRequestProto::get_action_for_reflect,
                    SetSafeModeRequestProto::mut_action_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "checked",
                    SetSafeModeRequestProto::get_checked_for_reflect,
                    SetSafeModeRequestProto::mut_checked_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetSafeModeRequestProto>(
                    "SetSafeModeRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetSafeModeRequestProto {
    fn clear(&mut self) {
        self.clear_action();
        self.clear_checked();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetSafeModeRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetSafeModeRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetSafeModeResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SetSafeModeResponseProto {}

impl SetSafeModeResponseProto {
    pub fn new() -> SetSafeModeResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetSafeModeResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<SetSafeModeResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetSafeModeResponseProto,
        };
        unsafe {
            instance.get(SetSafeModeResponseProto::new)
        }
    }

    // required bool result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.result
    }
}

impl ::protobuf::Message for SetSafeModeResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetSafeModeResponseProto {
    fn new() -> SetSafeModeResponseProto {
        SetSafeModeResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetSafeModeResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    SetSafeModeResponseProto::get_result_for_reflect,
                    SetSafeModeResponseProto::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetSafeModeResponseProto>(
                    "SetSafeModeResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetSafeModeResponseProto {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetSafeModeResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetSafeModeResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SaveNamespaceRequestProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SaveNamespaceRequestProto {}

impl SaveNamespaceRequestProto {
    pub fn new() -> SaveNamespaceRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SaveNamespaceRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<SaveNamespaceRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SaveNamespaceRequestProto,
        };
        unsafe {
            instance.get(SaveNamespaceRequestProto::new)
        }
    }
}

impl ::protobuf::Message for SaveNamespaceRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SaveNamespaceRequestProto {
    fn new() -> SaveNamespaceRequestProto {
        SaveNamespaceRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SaveNamespaceRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SaveNamespaceRequestProto>(
                    "SaveNamespaceRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SaveNamespaceRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SaveNamespaceRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SaveNamespaceRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SaveNamespaceResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SaveNamespaceResponseProto {}

impl SaveNamespaceResponseProto {
    pub fn new() -> SaveNamespaceResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SaveNamespaceResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<SaveNamespaceResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SaveNamespaceResponseProto,
        };
        unsafe {
            instance.get(SaveNamespaceResponseProto::new)
        }
    }
}

impl ::protobuf::Message for SaveNamespaceResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SaveNamespaceResponseProto {
    fn new() -> SaveNamespaceResponseProto {
        SaveNamespaceResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SaveNamespaceResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SaveNamespaceResponseProto>(
                    "SaveNamespaceResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SaveNamespaceResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SaveNamespaceResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SaveNamespaceResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RollEditsRequestProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RollEditsRequestProto {}

impl RollEditsRequestProto {
    pub fn new() -> RollEditsRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RollEditsRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RollEditsRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RollEditsRequestProto,
        };
        unsafe {
            instance.get(RollEditsRequestProto::new)
        }
    }
}

impl ::protobuf::Message for RollEditsRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RollEditsRequestProto {
    fn new() -> RollEditsRequestProto {
        RollEditsRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RollEditsRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RollEditsRequestProto>(
                    "RollEditsRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RollEditsRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RollEditsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RollEditsRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RollEditsResponseProto {
    // message fields
    newSegmentTxId: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RollEditsResponseProto {}

impl RollEditsResponseProto {
    pub fn new() -> RollEditsResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RollEditsResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RollEditsResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RollEditsResponseProto,
        };
        unsafe {
            instance.get(RollEditsResponseProto::new)
        }
    }

    // required uint64 newSegmentTxId = 1;

    pub fn clear_newSegmentTxId(&mut self) {
        self.newSegmentTxId = ::std::option::Option::None;
    }

    pub fn has_newSegmentTxId(&self) -> bool {
        self.newSegmentTxId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newSegmentTxId(&mut self, v: u64) {
        self.newSegmentTxId = ::std::option::Option::Some(v);
    }

    pub fn get_newSegmentTxId(&self) -> u64 {
        self.newSegmentTxId.unwrap_or(0)
    }

    fn get_newSegmentTxId_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.newSegmentTxId
    }

    fn mut_newSegmentTxId_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.newSegmentTxId
    }
}

impl ::protobuf::Message for RollEditsResponseProto {
    fn is_initialized(&self) -> bool {
        if self.newSegmentTxId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.newSegmentTxId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.newSegmentTxId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.newSegmentTxId {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RollEditsResponseProto {
    fn new() -> RollEditsResponseProto {
        RollEditsResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RollEditsResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "newSegmentTxId",
                    RollEditsResponseProto::get_newSegmentTxId_for_reflect,
                    RollEditsResponseProto::mut_newSegmentTxId_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RollEditsResponseProto>(
                    "RollEditsResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RollEditsResponseProto {
    fn clear(&mut self) {
        self.clear_newSegmentTxId();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RollEditsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RollEditsResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RestoreFailedStorageRequestProto {
    // message fields
    arg: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RestoreFailedStorageRequestProto {}

impl RestoreFailedStorageRequestProto {
    pub fn new() -> RestoreFailedStorageRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RestoreFailedStorageRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RestoreFailedStorageRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RestoreFailedStorageRequestProto,
        };
        unsafe {
            instance.get(RestoreFailedStorageRequestProto::new)
        }
    }

    // required string arg = 1;

    pub fn clear_arg(&mut self) {
        self.arg.clear();
    }

    pub fn has_arg(&self) -> bool {
        self.arg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_arg(&mut self, v: ::std::string::String) {
        self.arg = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_arg(&mut self) -> &mut ::std::string::String {
        if self.arg.is_none() {
            self.arg.set_default();
        }
        self.arg.as_mut().unwrap()
    }

    // Take field
    pub fn take_arg(&mut self) -> ::std::string::String {
        self.arg.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_arg(&self) -> &str {
        match self.arg.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_arg_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.arg
    }

    fn mut_arg_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.arg
    }
}

impl ::protobuf::Message for RestoreFailedStorageRequestProto {
    fn is_initialized(&self) -> bool {
        if self.arg.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.arg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.arg.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.arg.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RestoreFailedStorageRequestProto {
    fn new() -> RestoreFailedStorageRequestProto {
        RestoreFailedStorageRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RestoreFailedStorageRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "arg",
                    RestoreFailedStorageRequestProto::get_arg_for_reflect,
                    RestoreFailedStorageRequestProto::mut_arg_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RestoreFailedStorageRequestProto>(
                    "RestoreFailedStorageRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RestoreFailedStorageRequestProto {
    fn clear(&mut self) {
        self.clear_arg();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RestoreFailedStorageRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RestoreFailedStorageRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RestoreFailedStorageResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RestoreFailedStorageResponseProto {}

impl RestoreFailedStorageResponseProto {
    pub fn new() -> RestoreFailedStorageResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RestoreFailedStorageResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RestoreFailedStorageResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RestoreFailedStorageResponseProto,
        };
        unsafe {
            instance.get(RestoreFailedStorageResponseProto::new)
        }
    }

    // required bool result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.result
    }
}

impl ::protobuf::Message for RestoreFailedStorageResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RestoreFailedStorageResponseProto {
    fn new() -> RestoreFailedStorageResponseProto {
        RestoreFailedStorageResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RestoreFailedStorageResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    RestoreFailedStorageResponseProto::get_result_for_reflect,
                    RestoreFailedStorageResponseProto::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RestoreFailedStorageResponseProto>(
                    "RestoreFailedStorageResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RestoreFailedStorageResponseProto {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RestoreFailedStorageResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RestoreFailedStorageResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RefreshNodesRequestProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RefreshNodesRequestProto {}

impl RefreshNodesRequestProto {
    pub fn new() -> RefreshNodesRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RefreshNodesRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RefreshNodesRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RefreshNodesRequestProto,
        };
        unsafe {
            instance.get(RefreshNodesRequestProto::new)
        }
    }
}

impl ::protobuf::Message for RefreshNodesRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RefreshNodesRequestProto {
    fn new() -> RefreshNodesRequestProto {
        RefreshNodesRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RefreshNodesRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RefreshNodesRequestProto>(
                    "RefreshNodesRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RefreshNodesRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RefreshNodesRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RefreshNodesRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RefreshNodesResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RefreshNodesResponseProto {}

impl RefreshNodesResponseProto {
    pub fn new() -> RefreshNodesResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RefreshNodesResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RefreshNodesResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RefreshNodesResponseProto,
        };
        unsafe {
            instance.get(RefreshNodesResponseProto::new)
        }
    }
}

impl ::protobuf::Message for RefreshNodesResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RefreshNodesResponseProto {
    fn new() -> RefreshNodesResponseProto {
        RefreshNodesResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RefreshNodesResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RefreshNodesResponseProto>(
                    "RefreshNodesResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RefreshNodesResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RefreshNodesResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RefreshNodesResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FinalizeUpgradeRequestProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for FinalizeUpgradeRequestProto {}

impl FinalizeUpgradeRequestProto {
    pub fn new() -> FinalizeUpgradeRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static FinalizeUpgradeRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<FinalizeUpgradeRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FinalizeUpgradeRequestProto,
        };
        unsafe {
            instance.get(FinalizeUpgradeRequestProto::new)
        }
    }
}

impl ::protobuf::Message for FinalizeUpgradeRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for FinalizeUpgradeRequestProto {
    fn new() -> FinalizeUpgradeRequestProto {
        FinalizeUpgradeRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<FinalizeUpgradeRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<FinalizeUpgradeRequestProto>(
                    "FinalizeUpgradeRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for FinalizeUpgradeRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FinalizeUpgradeRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FinalizeUpgradeRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FinalizeUpgradeResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for FinalizeUpgradeResponseProto {}

impl FinalizeUpgradeResponseProto {
    pub fn new() -> FinalizeUpgradeResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static FinalizeUpgradeResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<FinalizeUpgradeResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FinalizeUpgradeResponseProto,
        };
        unsafe {
            instance.get(FinalizeUpgradeResponseProto::new)
        }
    }
}

impl ::protobuf::Message for FinalizeUpgradeResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for FinalizeUpgradeResponseProto {
    fn new() -> FinalizeUpgradeResponseProto {
        FinalizeUpgradeResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<FinalizeUpgradeResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<FinalizeUpgradeResponseProto>(
                    "FinalizeUpgradeResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for FinalizeUpgradeResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FinalizeUpgradeResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FinalizeUpgradeResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RollingUpgradeRequestProto {
    // message fields
    action: ::std::option::Option<RollingUpgradeActionProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RollingUpgradeRequestProto {}

impl RollingUpgradeRequestProto {
    pub fn new() -> RollingUpgradeRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RollingUpgradeRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RollingUpgradeRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RollingUpgradeRequestProto,
        };
        unsafe {
            instance.get(RollingUpgradeRequestProto::new)
        }
    }

    // required .hadoop.hdfs.RollingUpgradeActionProto action = 1;

    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: RollingUpgradeActionProto) {
        self.action = ::std::option::Option::Some(v);
    }

    pub fn get_action(&self) -> RollingUpgradeActionProto {
        self.action.unwrap_or(RollingUpgradeActionProto::QUERY)
    }

    fn get_action_for_reflect(&self) -> &::std::option::Option<RollingUpgradeActionProto> {
        &self.action
    }

    fn mut_action_for_reflect(&mut self) -> &mut ::std::option::Option<RollingUpgradeActionProto> {
        &mut self.action
    }
}

impl ::protobuf::Message for RollingUpgradeRequestProto {
    fn is_initialized(&self) -> bool {
        if self.action.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.action = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.action {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RollingUpgradeRequestProto {
    fn new() -> RollingUpgradeRequestProto {
        RollingUpgradeRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RollingUpgradeRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RollingUpgradeActionProto>>(
                    "action",
                    RollingUpgradeRequestProto::get_action_for_reflect,
                    RollingUpgradeRequestProto::mut_action_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RollingUpgradeRequestProto>(
                    "RollingUpgradeRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RollingUpgradeRequestProto {
    fn clear(&mut self) {
        self.clear_action();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RollingUpgradeRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RollingUpgradeRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RollingUpgradeInfoProto {
    // message fields
    status: ::protobuf::SingularPtrField<super::hdfs::RollingUpgradeStatusProto>,
    startTime: ::std::option::Option<u64>,
    finalizeTime: ::std::option::Option<u64>,
    createdRollbackImages: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RollingUpgradeInfoProto {}

impl RollingUpgradeInfoProto {
    pub fn new() -> RollingUpgradeInfoProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RollingUpgradeInfoProto {
        static mut instance: ::protobuf::lazy::Lazy<RollingUpgradeInfoProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RollingUpgradeInfoProto,
        };
        unsafe {
            instance.get(RollingUpgradeInfoProto::new)
        }
    }

    // required .hadoop.hdfs.RollingUpgradeStatusProto status = 1;

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::hdfs::RollingUpgradeStatusProto) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::hdfs::RollingUpgradeStatusProto {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::hdfs::RollingUpgradeStatusProto {
        self.status.take().unwrap_or_else(|| super::hdfs::RollingUpgradeStatusProto::new())
    }

    pub fn get_status(&self) -> &super::hdfs::RollingUpgradeStatusProto {
        self.status.as_ref().unwrap_or_else(|| super::hdfs::RollingUpgradeStatusProto::default_instance())
    }

    fn get_status_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::RollingUpgradeStatusProto> {
        &self.status
    }

    fn mut_status_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::RollingUpgradeStatusProto> {
        &mut self.status
    }

    // required uint64 startTime = 2;

    pub fn clear_startTime(&mut self) {
        self.startTime = ::std::option::Option::None;
    }

    pub fn has_startTime(&self) -> bool {
        self.startTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startTime(&mut self, v: u64) {
        self.startTime = ::std::option::Option::Some(v);
    }

    pub fn get_startTime(&self) -> u64 {
        self.startTime.unwrap_or(0)
    }

    fn get_startTime_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.startTime
    }

    fn mut_startTime_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.startTime
    }

    // required uint64 finalizeTime = 3;

    pub fn clear_finalizeTime(&mut self) {
        self.finalizeTime = ::std::option::Option::None;
    }

    pub fn has_finalizeTime(&self) -> bool {
        self.finalizeTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_finalizeTime(&mut self, v: u64) {
        self.finalizeTime = ::std::option::Option::Some(v);
    }

    pub fn get_finalizeTime(&self) -> u64 {
        self.finalizeTime.unwrap_or(0)
    }

    fn get_finalizeTime_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.finalizeTime
    }

    fn mut_finalizeTime_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.finalizeTime
    }

    // required bool createdRollbackImages = 4;

    pub fn clear_createdRollbackImages(&mut self) {
        self.createdRollbackImages = ::std::option::Option::None;
    }

    pub fn has_createdRollbackImages(&self) -> bool {
        self.createdRollbackImages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_createdRollbackImages(&mut self, v: bool) {
        self.createdRollbackImages = ::std::option::Option::Some(v);
    }

    pub fn get_createdRollbackImages(&self) -> bool {
        self.createdRollbackImages.unwrap_or(false)
    }

    fn get_createdRollbackImages_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.createdRollbackImages
    }

    fn mut_createdRollbackImages_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.createdRollbackImages
    }
}

impl ::protobuf::Message for RollingUpgradeInfoProto {
    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        }
        if self.startTime.is_none() {
            return false;
        }
        if self.finalizeTime.is_none() {
            return false;
        }
        if self.createdRollbackImages.is_none() {
            return false;
        }
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.startTime = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.finalizeTime = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.createdRollbackImages = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.startTime {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.finalizeTime {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.createdRollbackImages {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.startTime {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.finalizeTime {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.createdRollbackImages {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RollingUpgradeInfoProto {
    fn new() -> RollingUpgradeInfoProto {
        RollingUpgradeInfoProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RollingUpgradeInfoProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::RollingUpgradeStatusProto>>(
                    "status",
                    RollingUpgradeInfoProto::get_status_for_reflect,
                    RollingUpgradeInfoProto::mut_status_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "startTime",
                    RollingUpgradeInfoProto::get_startTime_for_reflect,
                    RollingUpgradeInfoProto::mut_startTime_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "finalizeTime",
                    RollingUpgradeInfoProto::get_finalizeTime_for_reflect,
                    RollingUpgradeInfoProto::mut_finalizeTime_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "createdRollbackImages",
                    RollingUpgradeInfoProto::get_createdRollbackImages_for_reflect,
                    RollingUpgradeInfoProto::mut_createdRollbackImages_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RollingUpgradeInfoProto>(
                    "RollingUpgradeInfoProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RollingUpgradeInfoProto {
    fn clear(&mut self) {
        self.clear_status();
        self.clear_startTime();
        self.clear_finalizeTime();
        self.clear_createdRollbackImages();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RollingUpgradeInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RollingUpgradeInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RollingUpgradeResponseProto {
    // message fields
    rollingUpgradeInfo: ::protobuf::SingularPtrField<RollingUpgradeInfoProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RollingUpgradeResponseProto {}

impl RollingUpgradeResponseProto {
    pub fn new() -> RollingUpgradeResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RollingUpgradeResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RollingUpgradeResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RollingUpgradeResponseProto,
        };
        unsafe {
            instance.get(RollingUpgradeResponseProto::new)
        }
    }

    // optional .hadoop.hdfs.RollingUpgradeInfoProto rollingUpgradeInfo = 1;

    pub fn clear_rollingUpgradeInfo(&mut self) {
        self.rollingUpgradeInfo.clear();
    }

    pub fn has_rollingUpgradeInfo(&self) -> bool {
        self.rollingUpgradeInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rollingUpgradeInfo(&mut self, v: RollingUpgradeInfoProto) {
        self.rollingUpgradeInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rollingUpgradeInfo(&mut self) -> &mut RollingUpgradeInfoProto {
        if self.rollingUpgradeInfo.is_none() {
            self.rollingUpgradeInfo.set_default();
        }
        self.rollingUpgradeInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_rollingUpgradeInfo(&mut self) -> RollingUpgradeInfoProto {
        self.rollingUpgradeInfo.take().unwrap_or_else(|| RollingUpgradeInfoProto::new())
    }

    pub fn get_rollingUpgradeInfo(&self) -> &RollingUpgradeInfoProto {
        self.rollingUpgradeInfo.as_ref().unwrap_or_else(|| RollingUpgradeInfoProto::default_instance())
    }

    fn get_rollingUpgradeInfo_for_reflect(&self) -> &::protobuf::SingularPtrField<RollingUpgradeInfoProto> {
        &self.rollingUpgradeInfo
    }

    fn mut_rollingUpgradeInfo_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<RollingUpgradeInfoProto> {
        &mut self.rollingUpgradeInfo
    }
}

impl ::protobuf::Message for RollingUpgradeResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.rollingUpgradeInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rollingUpgradeInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.rollingUpgradeInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.rollingUpgradeInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RollingUpgradeResponseProto {
    fn new() -> RollingUpgradeResponseProto {
        RollingUpgradeResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RollingUpgradeResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RollingUpgradeInfoProto>>(
                    "rollingUpgradeInfo",
                    RollingUpgradeResponseProto::get_rollingUpgradeInfo_for_reflect,
                    RollingUpgradeResponseProto::mut_rollingUpgradeInfo_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RollingUpgradeResponseProto>(
                    "RollingUpgradeResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RollingUpgradeResponseProto {
    fn clear(&mut self) {
        self.clear_rollingUpgradeInfo();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RollingUpgradeResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RollingUpgradeResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListCorruptFileBlocksRequestProto {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    cookie: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ListCorruptFileBlocksRequestProto {}

impl ListCorruptFileBlocksRequestProto {
    pub fn new() -> ListCorruptFileBlocksRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ListCorruptFileBlocksRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<ListCorruptFileBlocksRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListCorruptFileBlocksRequestProto,
        };
        unsafe {
            instance.get(ListCorruptFileBlocksRequestProto::new)
        }
    }

    // required string path = 1;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_path_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.path
    }

    fn mut_path_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.path
    }

    // optional string cookie = 2;

    pub fn clear_cookie(&mut self) {
        self.cookie.clear();
    }

    pub fn has_cookie(&self) -> bool {
        self.cookie.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cookie(&mut self, v: ::std::string::String) {
        self.cookie = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cookie(&mut self) -> &mut ::std::string::String {
        if self.cookie.is_none() {
            self.cookie.set_default();
        }
        self.cookie.as_mut().unwrap()
    }

    // Take field
    pub fn take_cookie(&mut self) -> ::std::string::String {
        self.cookie.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_cookie(&self) -> &str {
        match self.cookie.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_cookie_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.cookie
    }

    fn mut_cookie_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.cookie
    }
}

impl ::protobuf::Message for ListCorruptFileBlocksRequestProto {
    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.cookie)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.cookie.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.cookie.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ListCorruptFileBlocksRequestProto {
    fn new() -> ListCorruptFileBlocksRequestProto {
        ListCorruptFileBlocksRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ListCorruptFileBlocksRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    ListCorruptFileBlocksRequestProto::get_path_for_reflect,
                    ListCorruptFileBlocksRequestProto::mut_path_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cookie",
                    ListCorruptFileBlocksRequestProto::get_cookie_for_reflect,
                    ListCorruptFileBlocksRequestProto::mut_cookie_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListCorruptFileBlocksRequestProto>(
                    "ListCorruptFileBlocksRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ListCorruptFileBlocksRequestProto {
    fn clear(&mut self) {
        self.clear_path();
        self.clear_cookie();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListCorruptFileBlocksRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCorruptFileBlocksRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListCorruptFileBlocksResponseProto {
    // message fields
    corrupt: ::protobuf::SingularPtrField<super::hdfs::CorruptFileBlocksProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ListCorruptFileBlocksResponseProto {}

impl ListCorruptFileBlocksResponseProto {
    pub fn new() -> ListCorruptFileBlocksResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ListCorruptFileBlocksResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<ListCorruptFileBlocksResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListCorruptFileBlocksResponseProto,
        };
        unsafe {
            instance.get(ListCorruptFileBlocksResponseProto::new)
        }
    }

    // required .hadoop.hdfs.CorruptFileBlocksProto corrupt = 1;

    pub fn clear_corrupt(&mut self) {
        self.corrupt.clear();
    }

    pub fn has_corrupt(&self) -> bool {
        self.corrupt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_corrupt(&mut self, v: super::hdfs::CorruptFileBlocksProto) {
        self.corrupt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_corrupt(&mut self) -> &mut super::hdfs::CorruptFileBlocksProto {
        if self.corrupt.is_none() {
            self.corrupt.set_default();
        }
        self.corrupt.as_mut().unwrap()
    }

    // Take field
    pub fn take_corrupt(&mut self) -> super::hdfs::CorruptFileBlocksProto {
        self.corrupt.take().unwrap_or_else(|| super::hdfs::CorruptFileBlocksProto::new())
    }

    pub fn get_corrupt(&self) -> &super::hdfs::CorruptFileBlocksProto {
        self.corrupt.as_ref().unwrap_or_else(|| super::hdfs::CorruptFileBlocksProto::default_instance())
    }

    fn get_corrupt_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::CorruptFileBlocksProto> {
        &self.corrupt
    }

    fn mut_corrupt_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::CorruptFileBlocksProto> {
        &mut self.corrupt
    }
}

impl ::protobuf::Message for ListCorruptFileBlocksResponseProto {
    fn is_initialized(&self) -> bool {
        if self.corrupt.is_none() {
            return false;
        }
        for v in &self.corrupt {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.corrupt)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.corrupt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.corrupt.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ListCorruptFileBlocksResponseProto {
    fn new() -> ListCorruptFileBlocksResponseProto {
        ListCorruptFileBlocksResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ListCorruptFileBlocksResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::CorruptFileBlocksProto>>(
                    "corrupt",
                    ListCorruptFileBlocksResponseProto::get_corrupt_for_reflect,
                    ListCorruptFileBlocksResponseProto::mut_corrupt_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListCorruptFileBlocksResponseProto>(
                    "ListCorruptFileBlocksResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ListCorruptFileBlocksResponseProto {
    fn clear(&mut self) {
        self.clear_corrupt();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListCorruptFileBlocksResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCorruptFileBlocksResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MetaSaveRequestProto {
    // message fields
    filename: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for MetaSaveRequestProto {}

impl MetaSaveRequestProto {
    pub fn new() -> MetaSaveRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static MetaSaveRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<MetaSaveRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MetaSaveRequestProto,
        };
        unsafe {
            instance.get(MetaSaveRequestProto::new)
        }
    }

    // required string filename = 1;

    pub fn clear_filename(&mut self) {
        self.filename.clear();
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename.set_default();
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_filename_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.filename
    }

    fn mut_filename_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.filename
    }
}

impl ::protobuf::Message for MetaSaveRequestProto {
    fn is_initialized(&self) -> bool {
        if self.filename.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filename)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.filename.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for MetaSaveRequestProto {
    fn new() -> MetaSaveRequestProto {
        MetaSaveRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<MetaSaveRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "filename",
                    MetaSaveRequestProto::get_filename_for_reflect,
                    MetaSaveRequestProto::mut_filename_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MetaSaveRequestProto>(
                    "MetaSaveRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for MetaSaveRequestProto {
    fn clear(&mut self) {
        self.clear_filename();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MetaSaveRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetaSaveRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MetaSaveResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for MetaSaveResponseProto {}

impl MetaSaveResponseProto {
    pub fn new() -> MetaSaveResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static MetaSaveResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<MetaSaveResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MetaSaveResponseProto,
        };
        unsafe {
            instance.get(MetaSaveResponseProto::new)
        }
    }
}

impl ::protobuf::Message for MetaSaveResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for MetaSaveResponseProto {
    fn new() -> MetaSaveResponseProto {
        MetaSaveResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<MetaSaveResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<MetaSaveResponseProto>(
                    "MetaSaveResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for MetaSaveResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MetaSaveResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetaSaveResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFileInfoRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetFileInfoRequestProto {}

impl GetFileInfoRequestProto {
    pub fn new() -> GetFileInfoRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetFileInfoRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetFileInfoRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetFileInfoRequestProto,
        };
        unsafe {
            instance.get(GetFileInfoRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }
}

impl ::protobuf::Message for GetFileInfoRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetFileInfoRequestProto {
    fn new() -> GetFileInfoRequestProto {
        GetFileInfoRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetFileInfoRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    GetFileInfoRequestProto::get_src_for_reflect,
                    GetFileInfoRequestProto::mut_src_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetFileInfoRequestProto>(
                    "GetFileInfoRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetFileInfoRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFileInfoRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFileInfoRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFileInfoResponseProto {
    // message fields
    fs: ::protobuf::SingularPtrField<super::hdfs::HdfsFileStatusProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetFileInfoResponseProto {}

impl GetFileInfoResponseProto {
    pub fn new() -> GetFileInfoResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetFileInfoResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetFileInfoResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetFileInfoResponseProto,
        };
        unsafe {
            instance.get(GetFileInfoResponseProto::new)
        }
    }

    // optional .hadoop.hdfs.HdfsFileStatusProto fs = 1;

    pub fn clear_fs(&mut self) {
        self.fs.clear();
    }

    pub fn has_fs(&self) -> bool {
        self.fs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fs(&mut self, v: super::hdfs::HdfsFileStatusProto) {
        self.fs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fs(&mut self) -> &mut super::hdfs::HdfsFileStatusProto {
        if self.fs.is_none() {
            self.fs.set_default();
        }
        self.fs.as_mut().unwrap()
    }

    // Take field
    pub fn take_fs(&mut self) -> super::hdfs::HdfsFileStatusProto {
        self.fs.take().unwrap_or_else(|| super::hdfs::HdfsFileStatusProto::new())
    }

    pub fn get_fs(&self) -> &super::hdfs::HdfsFileStatusProto {
        self.fs.as_ref().unwrap_or_else(|| super::hdfs::HdfsFileStatusProto::default_instance())
    }

    fn get_fs_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::HdfsFileStatusProto> {
        &self.fs
    }

    fn mut_fs_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::HdfsFileStatusProto> {
        &mut self.fs
    }
}

impl ::protobuf::Message for GetFileInfoResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.fs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.fs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.fs.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetFileInfoResponseProto {
    fn new() -> GetFileInfoResponseProto {
        GetFileInfoResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetFileInfoResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::HdfsFileStatusProto>>(
                    "fs",
                    GetFileInfoResponseProto::get_fs_for_reflect,
                    GetFileInfoResponseProto::mut_fs_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetFileInfoResponseProto>(
                    "GetFileInfoResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetFileInfoResponseProto {
    fn clear(&mut self) {
        self.clear_fs();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFileInfoResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFileInfoResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IsFileClosedRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for IsFileClosedRequestProto {}

impl IsFileClosedRequestProto {
    pub fn new() -> IsFileClosedRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static IsFileClosedRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<IsFileClosedRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IsFileClosedRequestProto,
        };
        unsafe {
            instance.get(IsFileClosedRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }
}

impl ::protobuf::Message for IsFileClosedRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for IsFileClosedRequestProto {
    fn new() -> IsFileClosedRequestProto {
        IsFileClosedRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<IsFileClosedRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    IsFileClosedRequestProto::get_src_for_reflect,
                    IsFileClosedRequestProto::mut_src_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<IsFileClosedRequestProto>(
                    "IsFileClosedRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for IsFileClosedRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IsFileClosedRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IsFileClosedRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IsFileClosedResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for IsFileClosedResponseProto {}

impl IsFileClosedResponseProto {
    pub fn new() -> IsFileClosedResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static IsFileClosedResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<IsFileClosedResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IsFileClosedResponseProto,
        };
        unsafe {
            instance.get(IsFileClosedResponseProto::new)
        }
    }

    // required bool result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.result
    }
}

impl ::protobuf::Message for IsFileClosedResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for IsFileClosedResponseProto {
    fn new() -> IsFileClosedResponseProto {
        IsFileClosedResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<IsFileClosedResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    IsFileClosedResponseProto::get_result_for_reflect,
                    IsFileClosedResponseProto::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<IsFileClosedResponseProto>(
                    "IsFileClosedResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for IsFileClosedResponseProto {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IsFileClosedResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IsFileClosedResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CacheDirectiveInfoProto {
    // message fields
    id: ::std::option::Option<i64>,
    path: ::protobuf::SingularField<::std::string::String>,
    replication: ::std::option::Option<u32>,
    pool: ::protobuf::SingularField<::std::string::String>,
    expiration: ::protobuf::SingularPtrField<CacheDirectiveInfoExpirationProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CacheDirectiveInfoProto {}

impl CacheDirectiveInfoProto {
    pub fn new() -> CacheDirectiveInfoProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CacheDirectiveInfoProto {
        static mut instance: ::protobuf::lazy::Lazy<CacheDirectiveInfoProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CacheDirectiveInfoProto,
        };
        unsafe {
            instance.get(CacheDirectiveInfoProto::new)
        }
    }

    // optional int64 id = 1;

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }

    pub fn get_id(&self) -> i64 {
        self.id.unwrap_or(0)
    }

    fn get_id_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.id
    }

    fn mut_id_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.id
    }

    // optional string path = 2;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_path_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.path
    }

    fn mut_path_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.path
    }

    // optional uint32 replication = 3;

    pub fn clear_replication(&mut self) {
        self.replication = ::std::option::Option::None;
    }

    pub fn has_replication(&self) -> bool {
        self.replication.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replication(&mut self, v: u32) {
        self.replication = ::std::option::Option::Some(v);
    }

    pub fn get_replication(&self) -> u32 {
        self.replication.unwrap_or(0)
    }

    fn get_replication_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.replication
    }

    fn mut_replication_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.replication
    }

    // optional string pool = 4;

    pub fn clear_pool(&mut self) {
        self.pool.clear();
    }

    pub fn has_pool(&self) -> bool {
        self.pool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pool(&mut self, v: ::std::string::String) {
        self.pool = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pool(&mut self) -> &mut ::std::string::String {
        if self.pool.is_none() {
            self.pool.set_default();
        }
        self.pool.as_mut().unwrap()
    }

    // Take field
    pub fn take_pool(&mut self) -> ::std::string::String {
        self.pool.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_pool(&self) -> &str {
        match self.pool.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_pool_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.pool
    }

    fn mut_pool_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.pool
    }

    // optional .hadoop.hdfs.CacheDirectiveInfoExpirationProto expiration = 5;

    pub fn clear_expiration(&mut self) {
        self.expiration.clear();
    }

    pub fn has_expiration(&self) -> bool {
        self.expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration(&mut self, v: CacheDirectiveInfoExpirationProto) {
        self.expiration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expiration(&mut self) -> &mut CacheDirectiveInfoExpirationProto {
        if self.expiration.is_none() {
            self.expiration.set_default();
        }
        self.expiration.as_mut().unwrap()
    }

    // Take field
    pub fn take_expiration(&mut self) -> CacheDirectiveInfoExpirationProto {
        self.expiration.take().unwrap_or_else(|| CacheDirectiveInfoExpirationProto::new())
    }

    pub fn get_expiration(&self) -> &CacheDirectiveInfoExpirationProto {
        self.expiration.as_ref().unwrap_or_else(|| CacheDirectiveInfoExpirationProto::default_instance())
    }

    fn get_expiration_for_reflect(&self) -> &::protobuf::SingularPtrField<CacheDirectiveInfoExpirationProto> {
        &self.expiration
    }

    fn mut_expiration_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CacheDirectiveInfoExpirationProto> {
        &mut self.expiration
    }
}

impl ::protobuf::Message for CacheDirectiveInfoProto {
    fn is_initialized(&self) -> bool {
        for v in &self.expiration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.replication = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.pool)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.expiration)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.replication {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.pool.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.expiration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_int64(1, v)?;
        }
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.replication {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.pool.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.expiration.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CacheDirectiveInfoProto {
    fn new() -> CacheDirectiveInfoProto {
        CacheDirectiveInfoProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CacheDirectiveInfoProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "id",
                    CacheDirectiveInfoProto::get_id_for_reflect,
                    CacheDirectiveInfoProto::mut_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    CacheDirectiveInfoProto::get_path_for_reflect,
                    CacheDirectiveInfoProto::mut_path_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "replication",
                    CacheDirectiveInfoProto::get_replication_for_reflect,
                    CacheDirectiveInfoProto::mut_replication_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pool",
                    CacheDirectiveInfoProto::get_pool_for_reflect,
                    CacheDirectiveInfoProto::mut_pool_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CacheDirectiveInfoExpirationProto>>(
                    "expiration",
                    CacheDirectiveInfoProto::get_expiration_for_reflect,
                    CacheDirectiveInfoProto::mut_expiration_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CacheDirectiveInfoProto>(
                    "CacheDirectiveInfoProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CacheDirectiveInfoProto {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_path();
        self.clear_replication();
        self.clear_pool();
        self.clear_expiration();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CacheDirectiveInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CacheDirectiveInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CacheDirectiveInfoExpirationProto {
    // message fields
    millis: ::std::option::Option<i64>,
    isRelative: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CacheDirectiveInfoExpirationProto {}

impl CacheDirectiveInfoExpirationProto {
    pub fn new() -> CacheDirectiveInfoExpirationProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CacheDirectiveInfoExpirationProto {
        static mut instance: ::protobuf::lazy::Lazy<CacheDirectiveInfoExpirationProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CacheDirectiveInfoExpirationProto,
        };
        unsafe {
            instance.get(CacheDirectiveInfoExpirationProto::new)
        }
    }

    // required int64 millis = 1;

    pub fn clear_millis(&mut self) {
        self.millis = ::std::option::Option::None;
    }

    pub fn has_millis(&self) -> bool {
        self.millis.is_some()
    }

    // Param is passed by value, moved
    pub fn set_millis(&mut self, v: i64) {
        self.millis = ::std::option::Option::Some(v);
    }

    pub fn get_millis(&self) -> i64 {
        self.millis.unwrap_or(0)
    }

    fn get_millis_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.millis
    }

    fn mut_millis_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.millis
    }

    // required bool isRelative = 2;

    pub fn clear_isRelative(&mut self) {
        self.isRelative = ::std::option::Option::None;
    }

    pub fn has_isRelative(&self) -> bool {
        self.isRelative.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isRelative(&mut self, v: bool) {
        self.isRelative = ::std::option::Option::Some(v);
    }

    pub fn get_isRelative(&self) -> bool {
        self.isRelative.unwrap_or(false)
    }

    fn get_isRelative_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.isRelative
    }

    fn mut_isRelative_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.isRelative
    }
}

impl ::protobuf::Message for CacheDirectiveInfoExpirationProto {
    fn is_initialized(&self) -> bool {
        if self.millis.is_none() {
            return false;
        }
        if self.isRelative.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.millis = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isRelative = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.millis {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.isRelative {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.millis {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.isRelative {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CacheDirectiveInfoExpirationProto {
    fn new() -> CacheDirectiveInfoExpirationProto {
        CacheDirectiveInfoExpirationProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CacheDirectiveInfoExpirationProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "millis",
                    CacheDirectiveInfoExpirationProto::get_millis_for_reflect,
                    CacheDirectiveInfoExpirationProto::mut_millis_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "isRelative",
                    CacheDirectiveInfoExpirationProto::get_isRelative_for_reflect,
                    CacheDirectiveInfoExpirationProto::mut_isRelative_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CacheDirectiveInfoExpirationProto>(
                    "CacheDirectiveInfoExpirationProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CacheDirectiveInfoExpirationProto {
    fn clear(&mut self) {
        self.clear_millis();
        self.clear_isRelative();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CacheDirectiveInfoExpirationProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CacheDirectiveInfoExpirationProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CacheDirectiveStatsProto {
    // message fields
    bytesNeeded: ::std::option::Option<i64>,
    bytesCached: ::std::option::Option<i64>,
    filesNeeded: ::std::option::Option<i64>,
    filesCached: ::std::option::Option<i64>,
    hasExpired: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CacheDirectiveStatsProto {}

impl CacheDirectiveStatsProto {
    pub fn new() -> CacheDirectiveStatsProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CacheDirectiveStatsProto {
        static mut instance: ::protobuf::lazy::Lazy<CacheDirectiveStatsProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CacheDirectiveStatsProto,
        };
        unsafe {
            instance.get(CacheDirectiveStatsProto::new)
        }
    }

    // required int64 bytesNeeded = 1;

    pub fn clear_bytesNeeded(&mut self) {
        self.bytesNeeded = ::std::option::Option::None;
    }

    pub fn has_bytesNeeded(&self) -> bool {
        self.bytesNeeded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytesNeeded(&mut self, v: i64) {
        self.bytesNeeded = ::std::option::Option::Some(v);
    }

    pub fn get_bytesNeeded(&self) -> i64 {
        self.bytesNeeded.unwrap_or(0)
    }

    fn get_bytesNeeded_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.bytesNeeded
    }

    fn mut_bytesNeeded_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.bytesNeeded
    }

    // required int64 bytesCached = 2;

    pub fn clear_bytesCached(&mut self) {
        self.bytesCached = ::std::option::Option::None;
    }

    pub fn has_bytesCached(&self) -> bool {
        self.bytesCached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytesCached(&mut self, v: i64) {
        self.bytesCached = ::std::option::Option::Some(v);
    }

    pub fn get_bytesCached(&self) -> i64 {
        self.bytesCached.unwrap_or(0)
    }

    fn get_bytesCached_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.bytesCached
    }

    fn mut_bytesCached_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.bytesCached
    }

    // required int64 filesNeeded = 3;

    pub fn clear_filesNeeded(&mut self) {
        self.filesNeeded = ::std::option::Option::None;
    }

    pub fn has_filesNeeded(&self) -> bool {
        self.filesNeeded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesNeeded(&mut self, v: i64) {
        self.filesNeeded = ::std::option::Option::Some(v);
    }

    pub fn get_filesNeeded(&self) -> i64 {
        self.filesNeeded.unwrap_or(0)
    }

    fn get_filesNeeded_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.filesNeeded
    }

    fn mut_filesNeeded_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.filesNeeded
    }

    // required int64 filesCached = 4;

    pub fn clear_filesCached(&mut self) {
        self.filesCached = ::std::option::Option::None;
    }

    pub fn has_filesCached(&self) -> bool {
        self.filesCached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesCached(&mut self, v: i64) {
        self.filesCached = ::std::option::Option::Some(v);
    }

    pub fn get_filesCached(&self) -> i64 {
        self.filesCached.unwrap_or(0)
    }

    fn get_filesCached_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.filesCached
    }

    fn mut_filesCached_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.filesCached
    }

    // required bool hasExpired = 5;

    pub fn clear_hasExpired(&mut self) {
        self.hasExpired = ::std::option::Option::None;
    }

    pub fn has_hasExpired(&self) -> bool {
        self.hasExpired.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hasExpired(&mut self, v: bool) {
        self.hasExpired = ::std::option::Option::Some(v);
    }

    pub fn get_hasExpired(&self) -> bool {
        self.hasExpired.unwrap_or(false)
    }

    fn get_hasExpired_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.hasExpired
    }

    fn mut_hasExpired_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.hasExpired
    }
}

impl ::protobuf::Message for CacheDirectiveStatsProto {
    fn is_initialized(&self) -> bool {
        if self.bytesNeeded.is_none() {
            return false;
        }
        if self.bytesCached.is_none() {
            return false;
        }
        if self.filesNeeded.is_none() {
            return false;
        }
        if self.filesCached.is_none() {
            return false;
        }
        if self.hasExpired.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.bytesNeeded = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.bytesCached = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.filesNeeded = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.filesCached = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hasExpired = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bytesNeeded {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bytesCached {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filesNeeded {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filesCached {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hasExpired {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bytesNeeded {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.bytesCached {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.filesNeeded {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.filesCached {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.hasExpired {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CacheDirectiveStatsProto {
    fn new() -> CacheDirectiveStatsProto {
        CacheDirectiveStatsProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CacheDirectiveStatsProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "bytesNeeded",
                    CacheDirectiveStatsProto::get_bytesNeeded_for_reflect,
                    CacheDirectiveStatsProto::mut_bytesNeeded_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "bytesCached",
                    CacheDirectiveStatsProto::get_bytesCached_for_reflect,
                    CacheDirectiveStatsProto::mut_bytesCached_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "filesNeeded",
                    CacheDirectiveStatsProto::get_filesNeeded_for_reflect,
                    CacheDirectiveStatsProto::mut_filesNeeded_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "filesCached",
                    CacheDirectiveStatsProto::get_filesCached_for_reflect,
                    CacheDirectiveStatsProto::mut_filesCached_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "hasExpired",
                    CacheDirectiveStatsProto::get_hasExpired_for_reflect,
                    CacheDirectiveStatsProto::mut_hasExpired_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CacheDirectiveStatsProto>(
                    "CacheDirectiveStatsProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CacheDirectiveStatsProto {
    fn clear(&mut self) {
        self.clear_bytesNeeded();
        self.clear_bytesCached();
        self.clear_filesNeeded();
        self.clear_filesCached();
        self.clear_hasExpired();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CacheDirectiveStatsProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CacheDirectiveStatsProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddCacheDirectiveRequestProto {
    // message fields
    info: ::protobuf::SingularPtrField<CacheDirectiveInfoProto>,
    cacheFlags: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for AddCacheDirectiveRequestProto {}

impl AddCacheDirectiveRequestProto {
    pub fn new() -> AddCacheDirectiveRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AddCacheDirectiveRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<AddCacheDirectiveRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddCacheDirectiveRequestProto,
        };
        unsafe {
            instance.get(AddCacheDirectiveRequestProto::new)
        }
    }

    // required .hadoop.hdfs.CacheDirectiveInfoProto info = 1;

    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: CacheDirectiveInfoProto) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut CacheDirectiveInfoProto {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> CacheDirectiveInfoProto {
        self.info.take().unwrap_or_else(|| CacheDirectiveInfoProto::new())
    }

    pub fn get_info(&self) -> &CacheDirectiveInfoProto {
        self.info.as_ref().unwrap_or_else(|| CacheDirectiveInfoProto::default_instance())
    }

    fn get_info_for_reflect(&self) -> &::protobuf::SingularPtrField<CacheDirectiveInfoProto> {
        &self.info
    }

    fn mut_info_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CacheDirectiveInfoProto> {
        &mut self.info
    }

    // optional uint32 cacheFlags = 2;

    pub fn clear_cacheFlags(&mut self) {
        self.cacheFlags = ::std::option::Option::None;
    }

    pub fn has_cacheFlags(&self) -> bool {
        self.cacheFlags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cacheFlags(&mut self, v: u32) {
        self.cacheFlags = ::std::option::Option::Some(v);
    }

    pub fn get_cacheFlags(&self) -> u32 {
        self.cacheFlags.unwrap_or(0)
    }

    fn get_cacheFlags_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.cacheFlags
    }

    fn mut_cacheFlags_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.cacheFlags
    }
}

impl ::protobuf::Message for AddCacheDirectiveRequestProto {
    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cacheFlags = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.cacheFlags {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.cacheFlags {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AddCacheDirectiveRequestProto {
    fn new() -> AddCacheDirectiveRequestProto {
        AddCacheDirectiveRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<AddCacheDirectiveRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CacheDirectiveInfoProto>>(
                    "info",
                    AddCacheDirectiveRequestProto::get_info_for_reflect,
                    AddCacheDirectiveRequestProto::mut_info_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cacheFlags",
                    AddCacheDirectiveRequestProto::get_cacheFlags_for_reflect,
                    AddCacheDirectiveRequestProto::mut_cacheFlags_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddCacheDirectiveRequestProto>(
                    "AddCacheDirectiveRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AddCacheDirectiveRequestProto {
    fn clear(&mut self) {
        self.clear_info();
        self.clear_cacheFlags();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddCacheDirectiveRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddCacheDirectiveRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddCacheDirectiveResponseProto {
    // message fields
    id: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for AddCacheDirectiveResponseProto {}

impl AddCacheDirectiveResponseProto {
    pub fn new() -> AddCacheDirectiveResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AddCacheDirectiveResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<AddCacheDirectiveResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddCacheDirectiveResponseProto,
        };
        unsafe {
            instance.get(AddCacheDirectiveResponseProto::new)
        }
    }

    // required int64 id = 1;

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }

    pub fn get_id(&self) -> i64 {
        self.id.unwrap_or(0)
    }

    fn get_id_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.id
    }

    fn mut_id_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.id
    }
}

impl ::protobuf::Message for AddCacheDirectiveResponseProto {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AddCacheDirectiveResponseProto {
    fn new() -> AddCacheDirectiveResponseProto {
        AddCacheDirectiveResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<AddCacheDirectiveResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "id",
                    AddCacheDirectiveResponseProto::get_id_for_reflect,
                    AddCacheDirectiveResponseProto::mut_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddCacheDirectiveResponseProto>(
                    "AddCacheDirectiveResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AddCacheDirectiveResponseProto {
    fn clear(&mut self) {
        self.clear_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddCacheDirectiveResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddCacheDirectiveResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModifyCacheDirectiveRequestProto {
    // message fields
    info: ::protobuf::SingularPtrField<CacheDirectiveInfoProto>,
    cacheFlags: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ModifyCacheDirectiveRequestProto {}

impl ModifyCacheDirectiveRequestProto {
    pub fn new() -> ModifyCacheDirectiveRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ModifyCacheDirectiveRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<ModifyCacheDirectiveRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ModifyCacheDirectiveRequestProto,
        };
        unsafe {
            instance.get(ModifyCacheDirectiveRequestProto::new)
        }
    }

    // required .hadoop.hdfs.CacheDirectiveInfoProto info = 1;

    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: CacheDirectiveInfoProto) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut CacheDirectiveInfoProto {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> CacheDirectiveInfoProto {
        self.info.take().unwrap_or_else(|| CacheDirectiveInfoProto::new())
    }

    pub fn get_info(&self) -> &CacheDirectiveInfoProto {
        self.info.as_ref().unwrap_or_else(|| CacheDirectiveInfoProto::default_instance())
    }

    fn get_info_for_reflect(&self) -> &::protobuf::SingularPtrField<CacheDirectiveInfoProto> {
        &self.info
    }

    fn mut_info_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CacheDirectiveInfoProto> {
        &mut self.info
    }

    // optional uint32 cacheFlags = 2;

    pub fn clear_cacheFlags(&mut self) {
        self.cacheFlags = ::std::option::Option::None;
    }

    pub fn has_cacheFlags(&self) -> bool {
        self.cacheFlags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cacheFlags(&mut self, v: u32) {
        self.cacheFlags = ::std::option::Option::Some(v);
    }

    pub fn get_cacheFlags(&self) -> u32 {
        self.cacheFlags.unwrap_or(0)
    }

    fn get_cacheFlags_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.cacheFlags
    }

    fn mut_cacheFlags_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.cacheFlags
    }
}

impl ::protobuf::Message for ModifyCacheDirectiveRequestProto {
    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cacheFlags = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.cacheFlags {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.cacheFlags {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ModifyCacheDirectiveRequestProto {
    fn new() -> ModifyCacheDirectiveRequestProto {
        ModifyCacheDirectiveRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ModifyCacheDirectiveRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CacheDirectiveInfoProto>>(
                    "info",
                    ModifyCacheDirectiveRequestProto::get_info_for_reflect,
                    ModifyCacheDirectiveRequestProto::mut_info_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cacheFlags",
                    ModifyCacheDirectiveRequestProto::get_cacheFlags_for_reflect,
                    ModifyCacheDirectiveRequestProto::mut_cacheFlags_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ModifyCacheDirectiveRequestProto>(
                    "ModifyCacheDirectiveRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ModifyCacheDirectiveRequestProto {
    fn clear(&mut self) {
        self.clear_info();
        self.clear_cacheFlags();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModifyCacheDirectiveRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModifyCacheDirectiveRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModifyCacheDirectiveResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ModifyCacheDirectiveResponseProto {}

impl ModifyCacheDirectiveResponseProto {
    pub fn new() -> ModifyCacheDirectiveResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ModifyCacheDirectiveResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<ModifyCacheDirectiveResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ModifyCacheDirectiveResponseProto,
        };
        unsafe {
            instance.get(ModifyCacheDirectiveResponseProto::new)
        }
    }
}

impl ::protobuf::Message for ModifyCacheDirectiveResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ModifyCacheDirectiveResponseProto {
    fn new() -> ModifyCacheDirectiveResponseProto {
        ModifyCacheDirectiveResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ModifyCacheDirectiveResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ModifyCacheDirectiveResponseProto>(
                    "ModifyCacheDirectiveResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ModifyCacheDirectiveResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModifyCacheDirectiveResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModifyCacheDirectiveResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveCacheDirectiveRequestProto {
    // message fields
    id: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RemoveCacheDirectiveRequestProto {}

impl RemoveCacheDirectiveRequestProto {
    pub fn new() -> RemoveCacheDirectiveRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RemoveCacheDirectiveRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RemoveCacheDirectiveRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RemoveCacheDirectiveRequestProto,
        };
        unsafe {
            instance.get(RemoveCacheDirectiveRequestProto::new)
        }
    }

    // required int64 id = 1;

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }

    pub fn get_id(&self) -> i64 {
        self.id.unwrap_or(0)
    }

    fn get_id_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.id
    }

    fn mut_id_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.id
    }
}

impl ::protobuf::Message for RemoveCacheDirectiveRequestProto {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RemoveCacheDirectiveRequestProto {
    fn new() -> RemoveCacheDirectiveRequestProto {
        RemoveCacheDirectiveRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RemoveCacheDirectiveRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "id",
                    RemoveCacheDirectiveRequestProto::get_id_for_reflect,
                    RemoveCacheDirectiveRequestProto::mut_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RemoveCacheDirectiveRequestProto>(
                    "RemoveCacheDirectiveRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RemoveCacheDirectiveRequestProto {
    fn clear(&mut self) {
        self.clear_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveCacheDirectiveRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveCacheDirectiveRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveCacheDirectiveResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RemoveCacheDirectiveResponseProto {}

impl RemoveCacheDirectiveResponseProto {
    pub fn new() -> RemoveCacheDirectiveResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RemoveCacheDirectiveResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RemoveCacheDirectiveResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RemoveCacheDirectiveResponseProto,
        };
        unsafe {
            instance.get(RemoveCacheDirectiveResponseProto::new)
        }
    }
}

impl ::protobuf::Message for RemoveCacheDirectiveResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RemoveCacheDirectiveResponseProto {
    fn new() -> RemoveCacheDirectiveResponseProto {
        RemoveCacheDirectiveResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RemoveCacheDirectiveResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RemoveCacheDirectiveResponseProto>(
                    "RemoveCacheDirectiveResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RemoveCacheDirectiveResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveCacheDirectiveResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveCacheDirectiveResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListCacheDirectivesRequestProto {
    // message fields
    prevId: ::std::option::Option<i64>,
    filter: ::protobuf::SingularPtrField<CacheDirectiveInfoProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ListCacheDirectivesRequestProto {}

impl ListCacheDirectivesRequestProto {
    pub fn new() -> ListCacheDirectivesRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ListCacheDirectivesRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<ListCacheDirectivesRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListCacheDirectivesRequestProto,
        };
        unsafe {
            instance.get(ListCacheDirectivesRequestProto::new)
        }
    }

    // required int64 prevId = 1;

    pub fn clear_prevId(&mut self) {
        self.prevId = ::std::option::Option::None;
    }

    pub fn has_prevId(&self) -> bool {
        self.prevId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prevId(&mut self, v: i64) {
        self.prevId = ::std::option::Option::Some(v);
    }

    pub fn get_prevId(&self) -> i64 {
        self.prevId.unwrap_or(0)
    }

    fn get_prevId_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.prevId
    }

    fn mut_prevId_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.prevId
    }

    // required .hadoop.hdfs.CacheDirectiveInfoProto filter = 2;

    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    pub fn has_filter(&self) -> bool {
        self.filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: CacheDirectiveInfoProto) {
        self.filter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut CacheDirectiveInfoProto {
        if self.filter.is_none() {
            self.filter.set_default();
        }
        self.filter.as_mut().unwrap()
    }

    // Take field
    pub fn take_filter(&mut self) -> CacheDirectiveInfoProto {
        self.filter.take().unwrap_or_else(|| CacheDirectiveInfoProto::new())
    }

    pub fn get_filter(&self) -> &CacheDirectiveInfoProto {
        self.filter.as_ref().unwrap_or_else(|| CacheDirectiveInfoProto::default_instance())
    }

    fn get_filter_for_reflect(&self) -> &::protobuf::SingularPtrField<CacheDirectiveInfoProto> {
        &self.filter
    }

    fn mut_filter_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CacheDirectiveInfoProto> {
        &mut self.filter
    }
}

impl ::protobuf::Message for ListCacheDirectivesRequestProto {
    fn is_initialized(&self) -> bool {
        if self.prevId.is_none() {
            return false;
        }
        if self.filter.is_none() {
            return false;
        }
        for v in &self.filter {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.prevId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.filter)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.prevId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.prevId {
            os.write_int64(1, v)?;
        }
        if let Some(ref v) = self.filter.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ListCacheDirectivesRequestProto {
    fn new() -> ListCacheDirectivesRequestProto {
        ListCacheDirectivesRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ListCacheDirectivesRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "prevId",
                    ListCacheDirectivesRequestProto::get_prevId_for_reflect,
                    ListCacheDirectivesRequestProto::mut_prevId_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CacheDirectiveInfoProto>>(
                    "filter",
                    ListCacheDirectivesRequestProto::get_filter_for_reflect,
                    ListCacheDirectivesRequestProto::mut_filter_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListCacheDirectivesRequestProto>(
                    "ListCacheDirectivesRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ListCacheDirectivesRequestProto {
    fn clear(&mut self) {
        self.clear_prevId();
        self.clear_filter();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListCacheDirectivesRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCacheDirectivesRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CacheDirectiveEntryProto {
    // message fields
    info: ::protobuf::SingularPtrField<CacheDirectiveInfoProto>,
    stats: ::protobuf::SingularPtrField<CacheDirectiveStatsProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CacheDirectiveEntryProto {}

impl CacheDirectiveEntryProto {
    pub fn new() -> CacheDirectiveEntryProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CacheDirectiveEntryProto {
        static mut instance: ::protobuf::lazy::Lazy<CacheDirectiveEntryProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CacheDirectiveEntryProto,
        };
        unsafe {
            instance.get(CacheDirectiveEntryProto::new)
        }
    }

    // required .hadoop.hdfs.CacheDirectiveInfoProto info = 1;

    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: CacheDirectiveInfoProto) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut CacheDirectiveInfoProto {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> CacheDirectiveInfoProto {
        self.info.take().unwrap_or_else(|| CacheDirectiveInfoProto::new())
    }

    pub fn get_info(&self) -> &CacheDirectiveInfoProto {
        self.info.as_ref().unwrap_or_else(|| CacheDirectiveInfoProto::default_instance())
    }

    fn get_info_for_reflect(&self) -> &::protobuf::SingularPtrField<CacheDirectiveInfoProto> {
        &self.info
    }

    fn mut_info_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CacheDirectiveInfoProto> {
        &mut self.info
    }

    // required .hadoop.hdfs.CacheDirectiveStatsProto stats = 2;

    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    pub fn has_stats(&self) -> bool {
        self.stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: CacheDirectiveStatsProto) {
        self.stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats(&mut self) -> &mut CacheDirectiveStatsProto {
        if self.stats.is_none() {
            self.stats.set_default();
        }
        self.stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_stats(&mut self) -> CacheDirectiveStatsProto {
        self.stats.take().unwrap_or_else(|| CacheDirectiveStatsProto::new())
    }

    pub fn get_stats(&self) -> &CacheDirectiveStatsProto {
        self.stats.as_ref().unwrap_or_else(|| CacheDirectiveStatsProto::default_instance())
    }

    fn get_stats_for_reflect(&self) -> &::protobuf::SingularPtrField<CacheDirectiveStatsProto> {
        &self.stats
    }

    fn mut_stats_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CacheDirectiveStatsProto> {
        &mut self.stats
    }
}

impl ::protobuf::Message for CacheDirectiveEntryProto {
    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        }
        if self.stats.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.stats.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CacheDirectiveEntryProto {
    fn new() -> CacheDirectiveEntryProto {
        CacheDirectiveEntryProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CacheDirectiveEntryProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CacheDirectiveInfoProto>>(
                    "info",
                    CacheDirectiveEntryProto::get_info_for_reflect,
                    CacheDirectiveEntryProto::mut_info_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CacheDirectiveStatsProto>>(
                    "stats",
                    CacheDirectiveEntryProto::get_stats_for_reflect,
                    CacheDirectiveEntryProto::mut_stats_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CacheDirectiveEntryProto>(
                    "CacheDirectiveEntryProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CacheDirectiveEntryProto {
    fn clear(&mut self) {
        self.clear_info();
        self.clear_stats();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CacheDirectiveEntryProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CacheDirectiveEntryProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListCacheDirectivesResponseProto {
    // message fields
    elements: ::protobuf::RepeatedField<CacheDirectiveEntryProto>,
    hasMore: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ListCacheDirectivesResponseProto {}

impl ListCacheDirectivesResponseProto {
    pub fn new() -> ListCacheDirectivesResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ListCacheDirectivesResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<ListCacheDirectivesResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListCacheDirectivesResponseProto,
        };
        unsafe {
            instance.get(ListCacheDirectivesResponseProto::new)
        }
    }

    // repeated .hadoop.hdfs.CacheDirectiveEntryProto elements = 1;

    pub fn clear_elements(&mut self) {
        self.elements.clear();
    }

    // Param is passed by value, moved
    pub fn set_elements(&mut self, v: ::protobuf::RepeatedField<CacheDirectiveEntryProto>) {
        self.elements = v;
    }

    // Mutable pointer to the field.
    pub fn mut_elements(&mut self) -> &mut ::protobuf::RepeatedField<CacheDirectiveEntryProto> {
        &mut self.elements
    }

    // Take field
    pub fn take_elements(&mut self) -> ::protobuf::RepeatedField<CacheDirectiveEntryProto> {
        ::std::mem::replace(&mut self.elements, ::protobuf::RepeatedField::new())
    }

    pub fn get_elements(&self) -> &[CacheDirectiveEntryProto] {
        &self.elements
    }

    fn get_elements_for_reflect(&self) -> &::protobuf::RepeatedField<CacheDirectiveEntryProto> {
        &self.elements
    }

    fn mut_elements_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CacheDirectiveEntryProto> {
        &mut self.elements
    }

    // required bool hasMore = 2;

    pub fn clear_hasMore(&mut self) {
        self.hasMore = ::std::option::Option::None;
    }

    pub fn has_hasMore(&self) -> bool {
        self.hasMore.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hasMore(&mut self, v: bool) {
        self.hasMore = ::std::option::Option::Some(v);
    }

    pub fn get_hasMore(&self) -> bool {
        self.hasMore.unwrap_or(false)
    }

    fn get_hasMore_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.hasMore
    }

    fn mut_hasMore_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.hasMore
    }
}

impl ::protobuf::Message for ListCacheDirectivesResponseProto {
    fn is_initialized(&self) -> bool {
        if self.hasMore.is_none() {
            return false;
        }
        for v in &self.elements {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.elements)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hasMore = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.elements {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.hasMore {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.elements {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.hasMore {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ListCacheDirectivesResponseProto {
    fn new() -> ListCacheDirectivesResponseProto {
        ListCacheDirectivesResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ListCacheDirectivesResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CacheDirectiveEntryProto>>(
                    "elements",
                    ListCacheDirectivesResponseProto::get_elements_for_reflect,
                    ListCacheDirectivesResponseProto::mut_elements_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "hasMore",
                    ListCacheDirectivesResponseProto::get_hasMore_for_reflect,
                    ListCacheDirectivesResponseProto::mut_hasMore_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListCacheDirectivesResponseProto>(
                    "ListCacheDirectivesResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ListCacheDirectivesResponseProto {
    fn clear(&mut self) {
        self.clear_elements();
        self.clear_hasMore();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListCacheDirectivesResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCacheDirectivesResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CachePoolInfoProto {
    // message fields
    poolName: ::protobuf::SingularField<::std::string::String>,
    ownerName: ::protobuf::SingularField<::std::string::String>,
    groupName: ::protobuf::SingularField<::std::string::String>,
    mode: ::std::option::Option<i32>,
    limit: ::std::option::Option<i64>,
    maxRelativeExpiry: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CachePoolInfoProto {}

impl CachePoolInfoProto {
    pub fn new() -> CachePoolInfoProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CachePoolInfoProto {
        static mut instance: ::protobuf::lazy::Lazy<CachePoolInfoProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CachePoolInfoProto,
        };
        unsafe {
            instance.get(CachePoolInfoProto::new)
        }
    }

    // optional string poolName = 1;

    pub fn clear_poolName(&mut self) {
        self.poolName.clear();
    }

    pub fn has_poolName(&self) -> bool {
        self.poolName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_poolName(&mut self, v: ::std::string::String) {
        self.poolName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_poolName(&mut self) -> &mut ::std::string::String {
        if self.poolName.is_none() {
            self.poolName.set_default();
        }
        self.poolName.as_mut().unwrap()
    }

    // Take field
    pub fn take_poolName(&mut self) -> ::std::string::String {
        self.poolName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_poolName(&self) -> &str {
        match self.poolName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_poolName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.poolName
    }

    fn mut_poolName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.poolName
    }

    // optional string ownerName = 2;

    pub fn clear_ownerName(&mut self) {
        self.ownerName.clear();
    }

    pub fn has_ownerName(&self) -> bool {
        self.ownerName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ownerName(&mut self, v: ::std::string::String) {
        self.ownerName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ownerName(&mut self) -> &mut ::std::string::String {
        if self.ownerName.is_none() {
            self.ownerName.set_default();
        }
        self.ownerName.as_mut().unwrap()
    }

    // Take field
    pub fn take_ownerName(&mut self) -> ::std::string::String {
        self.ownerName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_ownerName(&self) -> &str {
        match self.ownerName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_ownerName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.ownerName
    }

    fn mut_ownerName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.ownerName
    }

    // optional string groupName = 3;

    pub fn clear_groupName(&mut self) {
        self.groupName.clear();
    }

    pub fn has_groupName(&self) -> bool {
        self.groupName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupName(&mut self, v: ::std::string::String) {
        self.groupName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupName(&mut self) -> &mut ::std::string::String {
        if self.groupName.is_none() {
            self.groupName.set_default();
        }
        self.groupName.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupName(&mut self) -> ::std::string::String {
        self.groupName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_groupName(&self) -> &str {
        match self.groupName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_groupName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.groupName
    }

    fn mut_groupName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.groupName
    }

    // optional int32 mode = 4;

    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: i32) {
        self.mode = ::std::option::Option::Some(v);
    }

    pub fn get_mode(&self) -> i32 {
        self.mode.unwrap_or(0)
    }

    fn get_mode_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.mode
    }

    fn mut_mode_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.mode
    }

    // optional int64 limit = 5;

    pub fn clear_limit(&mut self) {
        self.limit = ::std::option::Option::None;
    }

    pub fn has_limit(&self) -> bool {
        self.limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i64) {
        self.limit = ::std::option::Option::Some(v);
    }

    pub fn get_limit(&self) -> i64 {
        self.limit.unwrap_or(0)
    }

    fn get_limit_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.limit
    }

    fn mut_limit_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.limit
    }

    // optional int64 maxRelativeExpiry = 6;

    pub fn clear_maxRelativeExpiry(&mut self) {
        self.maxRelativeExpiry = ::std::option::Option::None;
    }

    pub fn has_maxRelativeExpiry(&self) -> bool {
        self.maxRelativeExpiry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxRelativeExpiry(&mut self, v: i64) {
        self.maxRelativeExpiry = ::std::option::Option::Some(v);
    }

    pub fn get_maxRelativeExpiry(&self) -> i64 {
        self.maxRelativeExpiry.unwrap_or(0)
    }

    fn get_maxRelativeExpiry_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.maxRelativeExpiry
    }

    fn mut_maxRelativeExpiry_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.maxRelativeExpiry
    }
}

impl ::protobuf::Message for CachePoolInfoProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.poolName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ownerName)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.groupName)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mode = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.limit = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.maxRelativeExpiry = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.poolName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.ownerName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.groupName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.limit {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maxRelativeExpiry {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.poolName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.ownerName.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.groupName.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.mode {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.limit {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.maxRelativeExpiry {
            os.write_int64(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CachePoolInfoProto {
    fn new() -> CachePoolInfoProto {
        CachePoolInfoProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CachePoolInfoProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "poolName",
                    CachePoolInfoProto::get_poolName_for_reflect,
                    CachePoolInfoProto::mut_poolName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ownerName",
                    CachePoolInfoProto::get_ownerName_for_reflect,
                    CachePoolInfoProto::mut_ownerName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "groupName",
                    CachePoolInfoProto::get_groupName_for_reflect,
                    CachePoolInfoProto::mut_groupName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "mode",
                    CachePoolInfoProto::get_mode_for_reflect,
                    CachePoolInfoProto::mut_mode_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "limit",
                    CachePoolInfoProto::get_limit_for_reflect,
                    CachePoolInfoProto::mut_limit_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "maxRelativeExpiry",
                    CachePoolInfoProto::get_maxRelativeExpiry_for_reflect,
                    CachePoolInfoProto::mut_maxRelativeExpiry_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CachePoolInfoProto>(
                    "CachePoolInfoProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CachePoolInfoProto {
    fn clear(&mut self) {
        self.clear_poolName();
        self.clear_ownerName();
        self.clear_groupName();
        self.clear_mode();
        self.clear_limit();
        self.clear_maxRelativeExpiry();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CachePoolInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CachePoolInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CachePoolStatsProto {
    // message fields
    bytesNeeded: ::std::option::Option<i64>,
    bytesCached: ::std::option::Option<i64>,
    bytesOverlimit: ::std::option::Option<i64>,
    filesNeeded: ::std::option::Option<i64>,
    filesCached: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CachePoolStatsProto {}

impl CachePoolStatsProto {
    pub fn new() -> CachePoolStatsProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CachePoolStatsProto {
        static mut instance: ::protobuf::lazy::Lazy<CachePoolStatsProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CachePoolStatsProto,
        };
        unsafe {
            instance.get(CachePoolStatsProto::new)
        }
    }

    // required int64 bytesNeeded = 1;

    pub fn clear_bytesNeeded(&mut self) {
        self.bytesNeeded = ::std::option::Option::None;
    }

    pub fn has_bytesNeeded(&self) -> bool {
        self.bytesNeeded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytesNeeded(&mut self, v: i64) {
        self.bytesNeeded = ::std::option::Option::Some(v);
    }

    pub fn get_bytesNeeded(&self) -> i64 {
        self.bytesNeeded.unwrap_or(0)
    }

    fn get_bytesNeeded_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.bytesNeeded
    }

    fn mut_bytesNeeded_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.bytesNeeded
    }

    // required int64 bytesCached = 2;

    pub fn clear_bytesCached(&mut self) {
        self.bytesCached = ::std::option::Option::None;
    }

    pub fn has_bytesCached(&self) -> bool {
        self.bytesCached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytesCached(&mut self, v: i64) {
        self.bytesCached = ::std::option::Option::Some(v);
    }

    pub fn get_bytesCached(&self) -> i64 {
        self.bytesCached.unwrap_or(0)
    }

    fn get_bytesCached_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.bytesCached
    }

    fn mut_bytesCached_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.bytesCached
    }

    // required int64 bytesOverlimit = 3;

    pub fn clear_bytesOverlimit(&mut self) {
        self.bytesOverlimit = ::std::option::Option::None;
    }

    pub fn has_bytesOverlimit(&self) -> bool {
        self.bytesOverlimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytesOverlimit(&mut self, v: i64) {
        self.bytesOverlimit = ::std::option::Option::Some(v);
    }

    pub fn get_bytesOverlimit(&self) -> i64 {
        self.bytesOverlimit.unwrap_or(0)
    }

    fn get_bytesOverlimit_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.bytesOverlimit
    }

    fn mut_bytesOverlimit_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.bytesOverlimit
    }

    // required int64 filesNeeded = 4;

    pub fn clear_filesNeeded(&mut self) {
        self.filesNeeded = ::std::option::Option::None;
    }

    pub fn has_filesNeeded(&self) -> bool {
        self.filesNeeded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesNeeded(&mut self, v: i64) {
        self.filesNeeded = ::std::option::Option::Some(v);
    }

    pub fn get_filesNeeded(&self) -> i64 {
        self.filesNeeded.unwrap_or(0)
    }

    fn get_filesNeeded_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.filesNeeded
    }

    fn mut_filesNeeded_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.filesNeeded
    }

    // required int64 filesCached = 5;

    pub fn clear_filesCached(&mut self) {
        self.filesCached = ::std::option::Option::None;
    }

    pub fn has_filesCached(&self) -> bool {
        self.filesCached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesCached(&mut self, v: i64) {
        self.filesCached = ::std::option::Option::Some(v);
    }

    pub fn get_filesCached(&self) -> i64 {
        self.filesCached.unwrap_or(0)
    }

    fn get_filesCached_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.filesCached
    }

    fn mut_filesCached_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.filesCached
    }
}

impl ::protobuf::Message for CachePoolStatsProto {
    fn is_initialized(&self) -> bool {
        if self.bytesNeeded.is_none() {
            return false;
        }
        if self.bytesCached.is_none() {
            return false;
        }
        if self.bytesOverlimit.is_none() {
            return false;
        }
        if self.filesNeeded.is_none() {
            return false;
        }
        if self.filesCached.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.bytesNeeded = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.bytesCached = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.bytesOverlimit = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.filesNeeded = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.filesCached = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bytesNeeded {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bytesCached {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bytesOverlimit {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filesNeeded {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filesCached {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bytesNeeded {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.bytesCached {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.bytesOverlimit {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.filesNeeded {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.filesCached {
            os.write_int64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CachePoolStatsProto {
    fn new() -> CachePoolStatsProto {
        CachePoolStatsProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CachePoolStatsProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "bytesNeeded",
                    CachePoolStatsProto::get_bytesNeeded_for_reflect,
                    CachePoolStatsProto::mut_bytesNeeded_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "bytesCached",
                    CachePoolStatsProto::get_bytesCached_for_reflect,
                    CachePoolStatsProto::mut_bytesCached_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "bytesOverlimit",
                    CachePoolStatsProto::get_bytesOverlimit_for_reflect,
                    CachePoolStatsProto::mut_bytesOverlimit_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "filesNeeded",
                    CachePoolStatsProto::get_filesNeeded_for_reflect,
                    CachePoolStatsProto::mut_filesNeeded_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "filesCached",
                    CachePoolStatsProto::get_filesCached_for_reflect,
                    CachePoolStatsProto::mut_filesCached_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CachePoolStatsProto>(
                    "CachePoolStatsProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CachePoolStatsProto {
    fn clear(&mut self) {
        self.clear_bytesNeeded();
        self.clear_bytesCached();
        self.clear_bytesOverlimit();
        self.clear_filesNeeded();
        self.clear_filesCached();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CachePoolStatsProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CachePoolStatsProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddCachePoolRequestProto {
    // message fields
    info: ::protobuf::SingularPtrField<CachePoolInfoProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for AddCachePoolRequestProto {}

impl AddCachePoolRequestProto {
    pub fn new() -> AddCachePoolRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AddCachePoolRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<AddCachePoolRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddCachePoolRequestProto,
        };
        unsafe {
            instance.get(AddCachePoolRequestProto::new)
        }
    }

    // required .hadoop.hdfs.CachePoolInfoProto info = 1;

    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: CachePoolInfoProto) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut CachePoolInfoProto {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> CachePoolInfoProto {
        self.info.take().unwrap_or_else(|| CachePoolInfoProto::new())
    }

    pub fn get_info(&self) -> &CachePoolInfoProto {
        self.info.as_ref().unwrap_or_else(|| CachePoolInfoProto::default_instance())
    }

    fn get_info_for_reflect(&self) -> &::protobuf::SingularPtrField<CachePoolInfoProto> {
        &self.info
    }

    fn mut_info_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CachePoolInfoProto> {
        &mut self.info
    }
}

impl ::protobuf::Message for AddCachePoolRequestProto {
    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AddCachePoolRequestProto {
    fn new() -> AddCachePoolRequestProto {
        AddCachePoolRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<AddCachePoolRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CachePoolInfoProto>>(
                    "info",
                    AddCachePoolRequestProto::get_info_for_reflect,
                    AddCachePoolRequestProto::mut_info_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddCachePoolRequestProto>(
                    "AddCachePoolRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AddCachePoolRequestProto {
    fn clear(&mut self) {
        self.clear_info();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddCachePoolRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddCachePoolRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddCachePoolResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for AddCachePoolResponseProto {}

impl AddCachePoolResponseProto {
    pub fn new() -> AddCachePoolResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AddCachePoolResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<AddCachePoolResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddCachePoolResponseProto,
        };
        unsafe {
            instance.get(AddCachePoolResponseProto::new)
        }
    }
}

impl ::protobuf::Message for AddCachePoolResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AddCachePoolResponseProto {
    fn new() -> AddCachePoolResponseProto {
        AddCachePoolResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<AddCachePoolResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<AddCachePoolResponseProto>(
                    "AddCachePoolResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AddCachePoolResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddCachePoolResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddCachePoolResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModifyCachePoolRequestProto {
    // message fields
    info: ::protobuf::SingularPtrField<CachePoolInfoProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ModifyCachePoolRequestProto {}

impl ModifyCachePoolRequestProto {
    pub fn new() -> ModifyCachePoolRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ModifyCachePoolRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<ModifyCachePoolRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ModifyCachePoolRequestProto,
        };
        unsafe {
            instance.get(ModifyCachePoolRequestProto::new)
        }
    }

    // required .hadoop.hdfs.CachePoolInfoProto info = 1;

    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: CachePoolInfoProto) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut CachePoolInfoProto {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> CachePoolInfoProto {
        self.info.take().unwrap_or_else(|| CachePoolInfoProto::new())
    }

    pub fn get_info(&self) -> &CachePoolInfoProto {
        self.info.as_ref().unwrap_or_else(|| CachePoolInfoProto::default_instance())
    }

    fn get_info_for_reflect(&self) -> &::protobuf::SingularPtrField<CachePoolInfoProto> {
        &self.info
    }

    fn mut_info_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CachePoolInfoProto> {
        &mut self.info
    }
}

impl ::protobuf::Message for ModifyCachePoolRequestProto {
    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ModifyCachePoolRequestProto {
    fn new() -> ModifyCachePoolRequestProto {
        ModifyCachePoolRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ModifyCachePoolRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CachePoolInfoProto>>(
                    "info",
                    ModifyCachePoolRequestProto::get_info_for_reflect,
                    ModifyCachePoolRequestProto::mut_info_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ModifyCachePoolRequestProto>(
                    "ModifyCachePoolRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ModifyCachePoolRequestProto {
    fn clear(&mut self) {
        self.clear_info();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModifyCachePoolRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModifyCachePoolRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModifyCachePoolResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ModifyCachePoolResponseProto {}

impl ModifyCachePoolResponseProto {
    pub fn new() -> ModifyCachePoolResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ModifyCachePoolResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<ModifyCachePoolResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ModifyCachePoolResponseProto,
        };
        unsafe {
            instance.get(ModifyCachePoolResponseProto::new)
        }
    }
}

impl ::protobuf::Message for ModifyCachePoolResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ModifyCachePoolResponseProto {
    fn new() -> ModifyCachePoolResponseProto {
        ModifyCachePoolResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ModifyCachePoolResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ModifyCachePoolResponseProto>(
                    "ModifyCachePoolResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ModifyCachePoolResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModifyCachePoolResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModifyCachePoolResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveCachePoolRequestProto {
    // message fields
    poolName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RemoveCachePoolRequestProto {}

impl RemoveCachePoolRequestProto {
    pub fn new() -> RemoveCachePoolRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RemoveCachePoolRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RemoveCachePoolRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RemoveCachePoolRequestProto,
        };
        unsafe {
            instance.get(RemoveCachePoolRequestProto::new)
        }
    }

    // required string poolName = 1;

    pub fn clear_poolName(&mut self) {
        self.poolName.clear();
    }

    pub fn has_poolName(&self) -> bool {
        self.poolName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_poolName(&mut self, v: ::std::string::String) {
        self.poolName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_poolName(&mut self) -> &mut ::std::string::String {
        if self.poolName.is_none() {
            self.poolName.set_default();
        }
        self.poolName.as_mut().unwrap()
    }

    // Take field
    pub fn take_poolName(&mut self) -> ::std::string::String {
        self.poolName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_poolName(&self) -> &str {
        match self.poolName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_poolName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.poolName
    }

    fn mut_poolName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.poolName
    }
}

impl ::protobuf::Message for RemoveCachePoolRequestProto {
    fn is_initialized(&self) -> bool {
        if self.poolName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.poolName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.poolName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.poolName.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RemoveCachePoolRequestProto {
    fn new() -> RemoveCachePoolRequestProto {
        RemoveCachePoolRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RemoveCachePoolRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "poolName",
                    RemoveCachePoolRequestProto::get_poolName_for_reflect,
                    RemoveCachePoolRequestProto::mut_poolName_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RemoveCachePoolRequestProto>(
                    "RemoveCachePoolRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RemoveCachePoolRequestProto {
    fn clear(&mut self) {
        self.clear_poolName();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveCachePoolRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveCachePoolRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveCachePoolResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RemoveCachePoolResponseProto {}

impl RemoveCachePoolResponseProto {
    pub fn new() -> RemoveCachePoolResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RemoveCachePoolResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RemoveCachePoolResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RemoveCachePoolResponseProto,
        };
        unsafe {
            instance.get(RemoveCachePoolResponseProto::new)
        }
    }
}

impl ::protobuf::Message for RemoveCachePoolResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RemoveCachePoolResponseProto {
    fn new() -> RemoveCachePoolResponseProto {
        RemoveCachePoolResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RemoveCachePoolResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RemoveCachePoolResponseProto>(
                    "RemoveCachePoolResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RemoveCachePoolResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveCachePoolResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveCachePoolResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListCachePoolsRequestProto {
    // message fields
    prevPoolName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ListCachePoolsRequestProto {}

impl ListCachePoolsRequestProto {
    pub fn new() -> ListCachePoolsRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ListCachePoolsRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<ListCachePoolsRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListCachePoolsRequestProto,
        };
        unsafe {
            instance.get(ListCachePoolsRequestProto::new)
        }
    }

    // required string prevPoolName = 1;

    pub fn clear_prevPoolName(&mut self) {
        self.prevPoolName.clear();
    }

    pub fn has_prevPoolName(&self) -> bool {
        self.prevPoolName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prevPoolName(&mut self, v: ::std::string::String) {
        self.prevPoolName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prevPoolName(&mut self) -> &mut ::std::string::String {
        if self.prevPoolName.is_none() {
            self.prevPoolName.set_default();
        }
        self.prevPoolName.as_mut().unwrap()
    }

    // Take field
    pub fn take_prevPoolName(&mut self) -> ::std::string::String {
        self.prevPoolName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_prevPoolName(&self) -> &str {
        match self.prevPoolName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_prevPoolName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.prevPoolName
    }

    fn mut_prevPoolName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.prevPoolName
    }
}

impl ::protobuf::Message for ListCachePoolsRequestProto {
    fn is_initialized(&self) -> bool {
        if self.prevPoolName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.prevPoolName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.prevPoolName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.prevPoolName.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ListCachePoolsRequestProto {
    fn new() -> ListCachePoolsRequestProto {
        ListCachePoolsRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ListCachePoolsRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "prevPoolName",
                    ListCachePoolsRequestProto::get_prevPoolName_for_reflect,
                    ListCachePoolsRequestProto::mut_prevPoolName_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListCachePoolsRequestProto>(
                    "ListCachePoolsRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ListCachePoolsRequestProto {
    fn clear(&mut self) {
        self.clear_prevPoolName();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListCachePoolsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCachePoolsRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListCachePoolsResponseProto {
    // message fields
    entries: ::protobuf::RepeatedField<CachePoolEntryProto>,
    hasMore: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ListCachePoolsResponseProto {}

impl ListCachePoolsResponseProto {
    pub fn new() -> ListCachePoolsResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ListCachePoolsResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<ListCachePoolsResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListCachePoolsResponseProto,
        };
        unsafe {
            instance.get(ListCachePoolsResponseProto::new)
        }
    }

    // repeated .hadoop.hdfs.CachePoolEntryProto entries = 1;

    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<CachePoolEntryProto>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<CachePoolEntryProto> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<CachePoolEntryProto> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }

    pub fn get_entries(&self) -> &[CachePoolEntryProto] {
        &self.entries
    }

    fn get_entries_for_reflect(&self) -> &::protobuf::RepeatedField<CachePoolEntryProto> {
        &self.entries
    }

    fn mut_entries_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CachePoolEntryProto> {
        &mut self.entries
    }

    // required bool hasMore = 2;

    pub fn clear_hasMore(&mut self) {
        self.hasMore = ::std::option::Option::None;
    }

    pub fn has_hasMore(&self) -> bool {
        self.hasMore.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hasMore(&mut self, v: bool) {
        self.hasMore = ::std::option::Option::Some(v);
    }

    pub fn get_hasMore(&self) -> bool {
        self.hasMore.unwrap_or(false)
    }

    fn get_hasMore_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.hasMore
    }

    fn mut_hasMore_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.hasMore
    }
}

impl ::protobuf::Message for ListCachePoolsResponseProto {
    fn is_initialized(&self) -> bool {
        if self.hasMore.is_none() {
            return false;
        }
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hasMore = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.hasMore {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entries {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.hasMore {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ListCachePoolsResponseProto {
    fn new() -> ListCachePoolsResponseProto {
        ListCachePoolsResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ListCachePoolsResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CachePoolEntryProto>>(
                    "entries",
                    ListCachePoolsResponseProto::get_entries_for_reflect,
                    ListCachePoolsResponseProto::mut_entries_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "hasMore",
                    ListCachePoolsResponseProto::get_hasMore_for_reflect,
                    ListCachePoolsResponseProto::mut_hasMore_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListCachePoolsResponseProto>(
                    "ListCachePoolsResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ListCachePoolsResponseProto {
    fn clear(&mut self) {
        self.clear_entries();
        self.clear_hasMore();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListCachePoolsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCachePoolsResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CachePoolEntryProto {
    // message fields
    info: ::protobuf::SingularPtrField<CachePoolInfoProto>,
    stats: ::protobuf::SingularPtrField<CachePoolStatsProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CachePoolEntryProto {}

impl CachePoolEntryProto {
    pub fn new() -> CachePoolEntryProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CachePoolEntryProto {
        static mut instance: ::protobuf::lazy::Lazy<CachePoolEntryProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CachePoolEntryProto,
        };
        unsafe {
            instance.get(CachePoolEntryProto::new)
        }
    }

    // required .hadoop.hdfs.CachePoolInfoProto info = 1;

    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: CachePoolInfoProto) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut CachePoolInfoProto {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> CachePoolInfoProto {
        self.info.take().unwrap_or_else(|| CachePoolInfoProto::new())
    }

    pub fn get_info(&self) -> &CachePoolInfoProto {
        self.info.as_ref().unwrap_or_else(|| CachePoolInfoProto::default_instance())
    }

    fn get_info_for_reflect(&self) -> &::protobuf::SingularPtrField<CachePoolInfoProto> {
        &self.info
    }

    fn mut_info_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CachePoolInfoProto> {
        &mut self.info
    }

    // required .hadoop.hdfs.CachePoolStatsProto stats = 2;

    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    pub fn has_stats(&self) -> bool {
        self.stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: CachePoolStatsProto) {
        self.stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats(&mut self) -> &mut CachePoolStatsProto {
        if self.stats.is_none() {
            self.stats.set_default();
        }
        self.stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_stats(&mut self) -> CachePoolStatsProto {
        self.stats.take().unwrap_or_else(|| CachePoolStatsProto::new())
    }

    pub fn get_stats(&self) -> &CachePoolStatsProto {
        self.stats.as_ref().unwrap_or_else(|| CachePoolStatsProto::default_instance())
    }

    fn get_stats_for_reflect(&self) -> &::protobuf::SingularPtrField<CachePoolStatsProto> {
        &self.stats
    }

    fn mut_stats_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CachePoolStatsProto> {
        &mut self.stats
    }
}

impl ::protobuf::Message for CachePoolEntryProto {
    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        }
        if self.stats.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.stats.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CachePoolEntryProto {
    fn new() -> CachePoolEntryProto {
        CachePoolEntryProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CachePoolEntryProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CachePoolInfoProto>>(
                    "info",
                    CachePoolEntryProto::get_info_for_reflect,
                    CachePoolEntryProto::mut_info_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CachePoolStatsProto>>(
                    "stats",
                    CachePoolEntryProto::get_stats_for_reflect,
                    CachePoolEntryProto::mut_stats_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CachePoolEntryProto>(
                    "CachePoolEntryProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CachePoolEntryProto {
    fn clear(&mut self) {
        self.clear_info();
        self.clear_stats();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CachePoolEntryProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CachePoolEntryProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFileLinkInfoRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetFileLinkInfoRequestProto {}

impl GetFileLinkInfoRequestProto {
    pub fn new() -> GetFileLinkInfoRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetFileLinkInfoRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetFileLinkInfoRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetFileLinkInfoRequestProto,
        };
        unsafe {
            instance.get(GetFileLinkInfoRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }
}

impl ::protobuf::Message for GetFileLinkInfoRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetFileLinkInfoRequestProto {
    fn new() -> GetFileLinkInfoRequestProto {
        GetFileLinkInfoRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetFileLinkInfoRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    GetFileLinkInfoRequestProto::get_src_for_reflect,
                    GetFileLinkInfoRequestProto::mut_src_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetFileLinkInfoRequestProto>(
                    "GetFileLinkInfoRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetFileLinkInfoRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFileLinkInfoRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFileLinkInfoRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFileLinkInfoResponseProto {
    // message fields
    fs: ::protobuf::SingularPtrField<super::hdfs::HdfsFileStatusProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetFileLinkInfoResponseProto {}

impl GetFileLinkInfoResponseProto {
    pub fn new() -> GetFileLinkInfoResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetFileLinkInfoResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetFileLinkInfoResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetFileLinkInfoResponseProto,
        };
        unsafe {
            instance.get(GetFileLinkInfoResponseProto::new)
        }
    }

    // optional .hadoop.hdfs.HdfsFileStatusProto fs = 1;

    pub fn clear_fs(&mut self) {
        self.fs.clear();
    }

    pub fn has_fs(&self) -> bool {
        self.fs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fs(&mut self, v: super::hdfs::HdfsFileStatusProto) {
        self.fs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fs(&mut self) -> &mut super::hdfs::HdfsFileStatusProto {
        if self.fs.is_none() {
            self.fs.set_default();
        }
        self.fs.as_mut().unwrap()
    }

    // Take field
    pub fn take_fs(&mut self) -> super::hdfs::HdfsFileStatusProto {
        self.fs.take().unwrap_or_else(|| super::hdfs::HdfsFileStatusProto::new())
    }

    pub fn get_fs(&self) -> &super::hdfs::HdfsFileStatusProto {
        self.fs.as_ref().unwrap_or_else(|| super::hdfs::HdfsFileStatusProto::default_instance())
    }

    fn get_fs_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::HdfsFileStatusProto> {
        &self.fs
    }

    fn mut_fs_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::HdfsFileStatusProto> {
        &mut self.fs
    }
}

impl ::protobuf::Message for GetFileLinkInfoResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.fs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.fs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.fs.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetFileLinkInfoResponseProto {
    fn new() -> GetFileLinkInfoResponseProto {
        GetFileLinkInfoResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetFileLinkInfoResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::HdfsFileStatusProto>>(
                    "fs",
                    GetFileLinkInfoResponseProto::get_fs_for_reflect,
                    GetFileLinkInfoResponseProto::mut_fs_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetFileLinkInfoResponseProto>(
                    "GetFileLinkInfoResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetFileLinkInfoResponseProto {
    fn clear(&mut self) {
        self.clear_fs();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFileLinkInfoResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFileLinkInfoResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetContentSummaryRequestProto {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetContentSummaryRequestProto {}

impl GetContentSummaryRequestProto {
    pub fn new() -> GetContentSummaryRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetContentSummaryRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetContentSummaryRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetContentSummaryRequestProto,
        };
        unsafe {
            instance.get(GetContentSummaryRequestProto::new)
        }
    }

    // required string path = 1;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_path_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.path
    }

    fn mut_path_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.path
    }
}

impl ::protobuf::Message for GetContentSummaryRequestProto {
    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetContentSummaryRequestProto {
    fn new() -> GetContentSummaryRequestProto {
        GetContentSummaryRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetContentSummaryRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    GetContentSummaryRequestProto::get_path_for_reflect,
                    GetContentSummaryRequestProto::mut_path_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetContentSummaryRequestProto>(
                    "GetContentSummaryRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetContentSummaryRequestProto {
    fn clear(&mut self) {
        self.clear_path();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetContentSummaryRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetContentSummaryRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetContentSummaryResponseProto {
    // message fields
    summary: ::protobuf::SingularPtrField<super::hdfs::ContentSummaryProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetContentSummaryResponseProto {}

impl GetContentSummaryResponseProto {
    pub fn new() -> GetContentSummaryResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetContentSummaryResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetContentSummaryResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetContentSummaryResponseProto,
        };
        unsafe {
            instance.get(GetContentSummaryResponseProto::new)
        }
    }

    // required .hadoop.hdfs.ContentSummaryProto summary = 1;

    pub fn clear_summary(&mut self) {
        self.summary.clear();
    }

    pub fn has_summary(&self) -> bool {
        self.summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_summary(&mut self, v: super::hdfs::ContentSummaryProto) {
        self.summary = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_summary(&mut self) -> &mut super::hdfs::ContentSummaryProto {
        if self.summary.is_none() {
            self.summary.set_default();
        }
        self.summary.as_mut().unwrap()
    }

    // Take field
    pub fn take_summary(&mut self) -> super::hdfs::ContentSummaryProto {
        self.summary.take().unwrap_or_else(|| super::hdfs::ContentSummaryProto::new())
    }

    pub fn get_summary(&self) -> &super::hdfs::ContentSummaryProto {
        self.summary.as_ref().unwrap_or_else(|| super::hdfs::ContentSummaryProto::default_instance())
    }

    fn get_summary_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::ContentSummaryProto> {
        &self.summary
    }

    fn mut_summary_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::ContentSummaryProto> {
        &mut self.summary
    }
}

impl ::protobuf::Message for GetContentSummaryResponseProto {
    fn is_initialized(&self) -> bool {
        if self.summary.is_none() {
            return false;
        }
        for v in &self.summary {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.summary)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.summary.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetContentSummaryResponseProto {
    fn new() -> GetContentSummaryResponseProto {
        GetContentSummaryResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetContentSummaryResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::ContentSummaryProto>>(
                    "summary",
                    GetContentSummaryResponseProto::get_summary_for_reflect,
                    GetContentSummaryResponseProto::mut_summary_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetContentSummaryResponseProto>(
                    "GetContentSummaryResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetContentSummaryResponseProto {
    fn clear(&mut self) {
        self.clear_summary();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetContentSummaryResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetContentSummaryResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetQuotaRequestProto {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    namespaceQuota: ::std::option::Option<u64>,
    diskspaceQuota: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SetQuotaRequestProto {}

impl SetQuotaRequestProto {
    pub fn new() -> SetQuotaRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetQuotaRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<SetQuotaRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetQuotaRequestProto,
        };
        unsafe {
            instance.get(SetQuotaRequestProto::new)
        }
    }

    // required string path = 1;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_path_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.path
    }

    fn mut_path_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.path
    }

    // required uint64 namespaceQuota = 2;

    pub fn clear_namespaceQuota(&mut self) {
        self.namespaceQuota = ::std::option::Option::None;
    }

    pub fn has_namespaceQuota(&self) -> bool {
        self.namespaceQuota.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespaceQuota(&mut self, v: u64) {
        self.namespaceQuota = ::std::option::Option::Some(v);
    }

    pub fn get_namespaceQuota(&self) -> u64 {
        self.namespaceQuota.unwrap_or(0)
    }

    fn get_namespaceQuota_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.namespaceQuota
    }

    fn mut_namespaceQuota_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.namespaceQuota
    }

    // required uint64 diskspaceQuota = 3;

    pub fn clear_diskspaceQuota(&mut self) {
        self.diskspaceQuota = ::std::option::Option::None;
    }

    pub fn has_diskspaceQuota(&self) -> bool {
        self.diskspaceQuota.is_some()
    }

    // Param is passed by value, moved
    pub fn set_diskspaceQuota(&mut self, v: u64) {
        self.diskspaceQuota = ::std::option::Option::Some(v);
    }

    pub fn get_diskspaceQuota(&self) -> u64 {
        self.diskspaceQuota.unwrap_or(0)
    }

    fn get_diskspaceQuota_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.diskspaceQuota
    }

    fn mut_diskspaceQuota_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.diskspaceQuota
    }
}

impl ::protobuf::Message for SetQuotaRequestProto {
    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        }
        if self.namespaceQuota.is_none() {
            return false;
        }
        if self.diskspaceQuota.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.namespaceQuota = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.diskspaceQuota = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.namespaceQuota {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.diskspaceQuota {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.namespaceQuota {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.diskspaceQuota {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetQuotaRequestProto {
    fn new() -> SetQuotaRequestProto {
        SetQuotaRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetQuotaRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    SetQuotaRequestProto::get_path_for_reflect,
                    SetQuotaRequestProto::mut_path_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "namespaceQuota",
                    SetQuotaRequestProto::get_namespaceQuota_for_reflect,
                    SetQuotaRequestProto::mut_namespaceQuota_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "diskspaceQuota",
                    SetQuotaRequestProto::get_diskspaceQuota_for_reflect,
                    SetQuotaRequestProto::mut_diskspaceQuota_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetQuotaRequestProto>(
                    "SetQuotaRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetQuotaRequestProto {
    fn clear(&mut self) {
        self.clear_path();
        self.clear_namespaceQuota();
        self.clear_diskspaceQuota();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetQuotaRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetQuotaRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetQuotaResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SetQuotaResponseProto {}

impl SetQuotaResponseProto {
    pub fn new() -> SetQuotaResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetQuotaResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<SetQuotaResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetQuotaResponseProto,
        };
        unsafe {
            instance.get(SetQuotaResponseProto::new)
        }
    }
}

impl ::protobuf::Message for SetQuotaResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetQuotaResponseProto {
    fn new() -> SetQuotaResponseProto {
        SetQuotaResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetQuotaResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SetQuotaResponseProto>(
                    "SetQuotaResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetQuotaResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetQuotaResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetQuotaResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FsyncRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    client: ::protobuf::SingularField<::std::string::String>,
    lastBlockLength: ::std::option::Option<i64>,
    fileId: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for FsyncRequestProto {}

impl FsyncRequestProto {
    pub fn new() -> FsyncRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static FsyncRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<FsyncRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FsyncRequestProto,
        };
        unsafe {
            instance.get(FsyncRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }

    // required string client = 2;

    pub fn clear_client(&mut self) {
        self.client.clear();
    }

    pub fn has_client(&self) -> bool {
        self.client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client(&mut self, v: ::std::string::String) {
        self.client = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client(&mut self) -> &mut ::std::string::String {
        if self.client.is_none() {
            self.client.set_default();
        }
        self.client.as_mut().unwrap()
    }

    // Take field
    pub fn take_client(&mut self) -> ::std::string::String {
        self.client.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_client(&self) -> &str {
        match self.client.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_client_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.client
    }

    fn mut_client_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.client
    }

    // optional sint64 lastBlockLength = 3;

    pub fn clear_lastBlockLength(&mut self) {
        self.lastBlockLength = ::std::option::Option::None;
    }

    pub fn has_lastBlockLength(&self) -> bool {
        self.lastBlockLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastBlockLength(&mut self, v: i64) {
        self.lastBlockLength = ::std::option::Option::Some(v);
    }

    pub fn get_lastBlockLength(&self) -> i64 {
        self.lastBlockLength.unwrap_or(-1i64)
    }

    fn get_lastBlockLength_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.lastBlockLength
    }

    fn mut_lastBlockLength_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.lastBlockLength
    }

    // optional uint64 fileId = 4;

    pub fn clear_fileId(&mut self) {
        self.fileId = ::std::option::Option::None;
    }

    pub fn has_fileId(&self) -> bool {
        self.fileId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileId(&mut self, v: u64) {
        self.fileId = ::std::option::Option::Some(v);
    }

    pub fn get_fileId(&self) -> u64 {
        self.fileId.unwrap_or(0u64)
    }

    fn get_fileId_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.fileId
    }

    fn mut_fileId_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.fileId
    }
}

impl ::protobuf::Message for FsyncRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.client.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.client)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.lastBlockLength = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fileId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.client.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.lastBlockLength {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, v);
        }
        if let Some(v) = self.fileId {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.client.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.lastBlockLength {
            os.write_sint64(3, v)?;
        }
        if let Some(v) = self.fileId {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for FsyncRequestProto {
    fn new() -> FsyncRequestProto {
        FsyncRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<FsyncRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    FsyncRequestProto::get_src_for_reflect,
                    FsyncRequestProto::mut_src_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "client",
                    FsyncRequestProto::get_client_for_reflect,
                    FsyncRequestProto::mut_client_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                    "lastBlockLength",
                    FsyncRequestProto::get_lastBlockLength_for_reflect,
                    FsyncRequestProto::mut_lastBlockLength_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fileId",
                    FsyncRequestProto::get_fileId_for_reflect,
                    FsyncRequestProto::mut_fileId_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FsyncRequestProto>(
                    "FsyncRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for FsyncRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_client();
        self.clear_lastBlockLength();
        self.clear_fileId();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FsyncRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FsyncRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FsyncResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for FsyncResponseProto {}

impl FsyncResponseProto {
    pub fn new() -> FsyncResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static FsyncResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<FsyncResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FsyncResponseProto,
        };
        unsafe {
            instance.get(FsyncResponseProto::new)
        }
    }
}

impl ::protobuf::Message for FsyncResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for FsyncResponseProto {
    fn new() -> FsyncResponseProto {
        FsyncResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<FsyncResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<FsyncResponseProto>(
                    "FsyncResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for FsyncResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FsyncResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FsyncResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetTimesRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    mtime: ::std::option::Option<u64>,
    atime: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SetTimesRequestProto {}

impl SetTimesRequestProto {
    pub fn new() -> SetTimesRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetTimesRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<SetTimesRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetTimesRequestProto,
        };
        unsafe {
            instance.get(SetTimesRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }

    // required uint64 mtime = 2;

    pub fn clear_mtime(&mut self) {
        self.mtime = ::std::option::Option::None;
    }

    pub fn has_mtime(&self) -> bool {
        self.mtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mtime(&mut self, v: u64) {
        self.mtime = ::std::option::Option::Some(v);
    }

    pub fn get_mtime(&self) -> u64 {
        self.mtime.unwrap_or(0)
    }

    fn get_mtime_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.mtime
    }

    fn mut_mtime_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.mtime
    }

    // required uint64 atime = 3;

    pub fn clear_atime(&mut self) {
        self.atime = ::std::option::Option::None;
    }

    pub fn has_atime(&self) -> bool {
        self.atime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_atime(&mut self, v: u64) {
        self.atime = ::std::option::Option::Some(v);
    }

    pub fn get_atime(&self) -> u64 {
        self.atime.unwrap_or(0)
    }

    fn get_atime_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.atime
    }

    fn mut_atime_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.atime
    }
}

impl ::protobuf::Message for SetTimesRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.mtime.is_none() {
            return false;
        }
        if self.atime.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.mtime = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.atime = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.mtime {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.atime {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.mtime {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.atime {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetTimesRequestProto {
    fn new() -> SetTimesRequestProto {
        SetTimesRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetTimesRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    SetTimesRequestProto::get_src_for_reflect,
                    SetTimesRequestProto::mut_src_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "mtime",
                    SetTimesRequestProto::get_mtime_for_reflect,
                    SetTimesRequestProto::mut_mtime_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "atime",
                    SetTimesRequestProto::get_atime_for_reflect,
                    SetTimesRequestProto::mut_atime_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetTimesRequestProto>(
                    "SetTimesRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetTimesRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_mtime();
        self.clear_atime();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetTimesRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetTimesRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetTimesResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SetTimesResponseProto {}

impl SetTimesResponseProto {
    pub fn new() -> SetTimesResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetTimesResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<SetTimesResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetTimesResponseProto,
        };
        unsafe {
            instance.get(SetTimesResponseProto::new)
        }
    }
}

impl ::protobuf::Message for SetTimesResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetTimesResponseProto {
    fn new() -> SetTimesResponseProto {
        SetTimesResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetTimesResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SetTimesResponseProto>(
                    "SetTimesResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetTimesResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetTimesResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetTimesResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateSymlinkRequestProto {
    // message fields
    target: ::protobuf::SingularField<::std::string::String>,
    link: ::protobuf::SingularField<::std::string::String>,
    dirPerm: ::protobuf::SingularPtrField<super::hdfs::FsPermissionProto>,
    createParent: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CreateSymlinkRequestProto {}

impl CreateSymlinkRequestProto {
    pub fn new() -> CreateSymlinkRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CreateSymlinkRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<CreateSymlinkRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateSymlinkRequestProto,
        };
        unsafe {
            instance.get(CreateSymlinkRequestProto::new)
        }
    }

    // required string target = 1;

    pub fn clear_target(&mut self) {
        self.target.clear();
    }

    pub fn has_target(&self) -> bool {
        self.target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: ::std::string::String) {
        self.target = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target(&mut self) -> &mut ::std::string::String {
        if self.target.is_none() {
            self.target.set_default();
        }
        self.target.as_mut().unwrap()
    }

    // Take field
    pub fn take_target(&mut self) -> ::std::string::String {
        self.target.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_target(&self) -> &str {
        match self.target.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_target_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.target
    }

    fn mut_target_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.target
    }

    // required string link = 2;

    pub fn clear_link(&mut self) {
        self.link.clear();
    }

    pub fn has_link(&self) -> bool {
        self.link.is_some()
    }

    // Param is passed by value, moved
    pub fn set_link(&mut self, v: ::std::string::String) {
        self.link = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_link(&mut self) -> &mut ::std::string::String {
        if self.link.is_none() {
            self.link.set_default();
        }
        self.link.as_mut().unwrap()
    }

    // Take field
    pub fn take_link(&mut self) -> ::std::string::String {
        self.link.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_link(&self) -> &str {
        match self.link.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_link_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.link
    }

    fn mut_link_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.link
    }

    // required .hadoop.hdfs.FsPermissionProto dirPerm = 3;

    pub fn clear_dirPerm(&mut self) {
        self.dirPerm.clear();
    }

    pub fn has_dirPerm(&self) -> bool {
        self.dirPerm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dirPerm(&mut self, v: super::hdfs::FsPermissionProto) {
        self.dirPerm = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dirPerm(&mut self) -> &mut super::hdfs::FsPermissionProto {
        if self.dirPerm.is_none() {
            self.dirPerm.set_default();
        }
        self.dirPerm.as_mut().unwrap()
    }

    // Take field
    pub fn take_dirPerm(&mut self) -> super::hdfs::FsPermissionProto {
        self.dirPerm.take().unwrap_or_else(|| super::hdfs::FsPermissionProto::new())
    }

    pub fn get_dirPerm(&self) -> &super::hdfs::FsPermissionProto {
        self.dirPerm.as_ref().unwrap_or_else(|| super::hdfs::FsPermissionProto::default_instance())
    }

    fn get_dirPerm_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::FsPermissionProto> {
        &self.dirPerm
    }

    fn mut_dirPerm_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::FsPermissionProto> {
        &mut self.dirPerm
    }

    // required bool createParent = 4;

    pub fn clear_createParent(&mut self) {
        self.createParent = ::std::option::Option::None;
    }

    pub fn has_createParent(&self) -> bool {
        self.createParent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_createParent(&mut self, v: bool) {
        self.createParent = ::std::option::Option::Some(v);
    }

    pub fn get_createParent(&self) -> bool {
        self.createParent.unwrap_or(false)
    }

    fn get_createParent_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.createParent
    }

    fn mut_createParent_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.createParent
    }
}

impl ::protobuf::Message for CreateSymlinkRequestProto {
    fn is_initialized(&self) -> bool {
        if self.target.is_none() {
            return false;
        }
        if self.link.is_none() {
            return false;
        }
        if self.dirPerm.is_none() {
            return false;
        }
        if self.createParent.is_none() {
            return false;
        }
        for v in &self.dirPerm {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.target)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.link)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dirPerm)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.createParent = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.target.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.link.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.dirPerm.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.createParent {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.target.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.link.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.dirPerm.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.createParent {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CreateSymlinkRequestProto {
    fn new() -> CreateSymlinkRequestProto {
        CreateSymlinkRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CreateSymlinkRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "target",
                    CreateSymlinkRequestProto::get_target_for_reflect,
                    CreateSymlinkRequestProto::mut_target_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "link",
                    CreateSymlinkRequestProto::get_link_for_reflect,
                    CreateSymlinkRequestProto::mut_link_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::FsPermissionProto>>(
                    "dirPerm",
                    CreateSymlinkRequestProto::get_dirPerm_for_reflect,
                    CreateSymlinkRequestProto::mut_dirPerm_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "createParent",
                    CreateSymlinkRequestProto::get_createParent_for_reflect,
                    CreateSymlinkRequestProto::mut_createParent_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateSymlinkRequestProto>(
                    "CreateSymlinkRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CreateSymlinkRequestProto {
    fn clear(&mut self) {
        self.clear_target();
        self.clear_link();
        self.clear_dirPerm();
        self.clear_createParent();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateSymlinkRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateSymlinkRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateSymlinkResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CreateSymlinkResponseProto {}

impl CreateSymlinkResponseProto {
    pub fn new() -> CreateSymlinkResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CreateSymlinkResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<CreateSymlinkResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateSymlinkResponseProto,
        };
        unsafe {
            instance.get(CreateSymlinkResponseProto::new)
        }
    }
}

impl ::protobuf::Message for CreateSymlinkResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CreateSymlinkResponseProto {
    fn new() -> CreateSymlinkResponseProto {
        CreateSymlinkResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CreateSymlinkResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CreateSymlinkResponseProto>(
                    "CreateSymlinkResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CreateSymlinkResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateSymlinkResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateSymlinkResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetLinkTargetRequestProto {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetLinkTargetRequestProto {}

impl GetLinkTargetRequestProto {
    pub fn new() -> GetLinkTargetRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetLinkTargetRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetLinkTargetRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetLinkTargetRequestProto,
        };
        unsafe {
            instance.get(GetLinkTargetRequestProto::new)
        }
    }

    // required string path = 1;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_path_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.path
    }

    fn mut_path_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.path
    }
}

impl ::protobuf::Message for GetLinkTargetRequestProto {
    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetLinkTargetRequestProto {
    fn new() -> GetLinkTargetRequestProto {
        GetLinkTargetRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetLinkTargetRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    GetLinkTargetRequestProto::get_path_for_reflect,
                    GetLinkTargetRequestProto::mut_path_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetLinkTargetRequestProto>(
                    "GetLinkTargetRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetLinkTargetRequestProto {
    fn clear(&mut self) {
        self.clear_path();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetLinkTargetRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLinkTargetRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetLinkTargetResponseProto {
    // message fields
    targetPath: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetLinkTargetResponseProto {}

impl GetLinkTargetResponseProto {
    pub fn new() -> GetLinkTargetResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetLinkTargetResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetLinkTargetResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetLinkTargetResponseProto,
        };
        unsafe {
            instance.get(GetLinkTargetResponseProto::new)
        }
    }

    // optional string targetPath = 1;

    pub fn clear_targetPath(&mut self) {
        self.targetPath.clear();
    }

    pub fn has_targetPath(&self) -> bool {
        self.targetPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_targetPath(&mut self, v: ::std::string::String) {
        self.targetPath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetPath(&mut self) -> &mut ::std::string::String {
        if self.targetPath.is_none() {
            self.targetPath.set_default();
        }
        self.targetPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_targetPath(&mut self) -> ::std::string::String {
        self.targetPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_targetPath(&self) -> &str {
        match self.targetPath.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_targetPath_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.targetPath
    }

    fn mut_targetPath_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.targetPath
    }
}

impl ::protobuf::Message for GetLinkTargetResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.targetPath)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.targetPath.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.targetPath.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetLinkTargetResponseProto {
    fn new() -> GetLinkTargetResponseProto {
        GetLinkTargetResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetLinkTargetResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "targetPath",
                    GetLinkTargetResponseProto::get_targetPath_for_reflect,
                    GetLinkTargetResponseProto::mut_targetPath_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetLinkTargetResponseProto>(
                    "GetLinkTargetResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetLinkTargetResponseProto {
    fn clear(&mut self) {
        self.clear_targetPath();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetLinkTargetResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLinkTargetResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateBlockForPipelineRequestProto {
    // message fields
    block: ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for UpdateBlockForPipelineRequestProto {}

impl UpdateBlockForPipelineRequestProto {
    pub fn new() -> UpdateBlockForPipelineRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static UpdateBlockForPipelineRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<UpdateBlockForPipelineRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdateBlockForPipelineRequestProto,
        };
        unsafe {
            instance.get(UpdateBlockForPipelineRequestProto::new)
        }
    }

    // required .hadoop.hdfs.ExtendedBlockProto block = 1;

    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    pub fn has_block(&self) -> bool {
        self.block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: super::hdfs::ExtendedBlockProto) {
        self.block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block(&mut self) -> &mut super::hdfs::ExtendedBlockProto {
        if self.block.is_none() {
            self.block.set_default();
        }
        self.block.as_mut().unwrap()
    }

    // Take field
    pub fn take_block(&mut self) -> super::hdfs::ExtendedBlockProto {
        self.block.take().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::new())
    }

    pub fn get_block(&self) -> &super::hdfs::ExtendedBlockProto {
        self.block.as_ref().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::default_instance())
    }

    fn get_block_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto> {
        &self.block
    }

    fn mut_block_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto> {
        &mut self.block
    }

    // required string clientName = 2;

    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_clientName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.clientName
    }

    fn mut_clientName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.clientName
    }
}

impl ::protobuf::Message for UpdateBlockForPipelineRequestProto {
    fn is_initialized(&self) -> bool {
        if self.block.is_none() {
            return false;
        }
        if self.clientName.is_none() {
            return false;
        }
        for v in &self.block {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.block)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.block.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for UpdateBlockForPipelineRequestProto {
    fn new() -> UpdateBlockForPipelineRequestProto {
        UpdateBlockForPipelineRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<UpdateBlockForPipelineRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::ExtendedBlockProto>>(
                    "block",
                    UpdateBlockForPipelineRequestProto::get_block_for_reflect,
                    UpdateBlockForPipelineRequestProto::mut_block_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "clientName",
                    UpdateBlockForPipelineRequestProto::get_clientName_for_reflect,
                    UpdateBlockForPipelineRequestProto::mut_clientName_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdateBlockForPipelineRequestProto>(
                    "UpdateBlockForPipelineRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for UpdateBlockForPipelineRequestProto {
    fn clear(&mut self) {
        self.clear_block();
        self.clear_clientName();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateBlockForPipelineRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateBlockForPipelineRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateBlockForPipelineResponseProto {
    // message fields
    block: ::protobuf::SingularPtrField<super::hdfs::LocatedBlockProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for UpdateBlockForPipelineResponseProto {}

impl UpdateBlockForPipelineResponseProto {
    pub fn new() -> UpdateBlockForPipelineResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static UpdateBlockForPipelineResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<UpdateBlockForPipelineResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdateBlockForPipelineResponseProto,
        };
        unsafe {
            instance.get(UpdateBlockForPipelineResponseProto::new)
        }
    }

    // required .hadoop.hdfs.LocatedBlockProto block = 1;

    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    pub fn has_block(&self) -> bool {
        self.block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: super::hdfs::LocatedBlockProto) {
        self.block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block(&mut self) -> &mut super::hdfs::LocatedBlockProto {
        if self.block.is_none() {
            self.block.set_default();
        }
        self.block.as_mut().unwrap()
    }

    // Take field
    pub fn take_block(&mut self) -> super::hdfs::LocatedBlockProto {
        self.block.take().unwrap_or_else(|| super::hdfs::LocatedBlockProto::new())
    }

    pub fn get_block(&self) -> &super::hdfs::LocatedBlockProto {
        self.block.as_ref().unwrap_or_else(|| super::hdfs::LocatedBlockProto::default_instance())
    }

    fn get_block_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::LocatedBlockProto> {
        &self.block
    }

    fn mut_block_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::LocatedBlockProto> {
        &mut self.block
    }
}

impl ::protobuf::Message for UpdateBlockForPipelineResponseProto {
    fn is_initialized(&self) -> bool {
        if self.block.is_none() {
            return false;
        }
        for v in &self.block {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.block)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.block.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for UpdateBlockForPipelineResponseProto {
    fn new() -> UpdateBlockForPipelineResponseProto {
        UpdateBlockForPipelineResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<UpdateBlockForPipelineResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::LocatedBlockProto>>(
                    "block",
                    UpdateBlockForPipelineResponseProto::get_block_for_reflect,
                    UpdateBlockForPipelineResponseProto::mut_block_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdateBlockForPipelineResponseProto>(
                    "UpdateBlockForPipelineResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for UpdateBlockForPipelineResponseProto {
    fn clear(&mut self) {
        self.clear_block();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateBlockForPipelineResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateBlockForPipelineResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdatePipelineRequestProto {
    // message fields
    clientName: ::protobuf::SingularField<::std::string::String>,
    oldBlock: ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto>,
    newBlock: ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto>,
    newNodes: ::protobuf::RepeatedField<super::hdfs::DatanodeIDProto>,
    storageIDs: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for UpdatePipelineRequestProto {}

impl UpdatePipelineRequestProto {
    pub fn new() -> UpdatePipelineRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static UpdatePipelineRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<UpdatePipelineRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdatePipelineRequestProto,
        };
        unsafe {
            instance.get(UpdatePipelineRequestProto::new)
        }
    }

    // required string clientName = 1;

    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_clientName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.clientName
    }

    fn mut_clientName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.clientName
    }

    // required .hadoop.hdfs.ExtendedBlockProto oldBlock = 2;

    pub fn clear_oldBlock(&mut self) {
        self.oldBlock.clear();
    }

    pub fn has_oldBlock(&self) -> bool {
        self.oldBlock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_oldBlock(&mut self, v: super::hdfs::ExtendedBlockProto) {
        self.oldBlock = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oldBlock(&mut self) -> &mut super::hdfs::ExtendedBlockProto {
        if self.oldBlock.is_none() {
            self.oldBlock.set_default();
        }
        self.oldBlock.as_mut().unwrap()
    }

    // Take field
    pub fn take_oldBlock(&mut self) -> super::hdfs::ExtendedBlockProto {
        self.oldBlock.take().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::new())
    }

    pub fn get_oldBlock(&self) -> &super::hdfs::ExtendedBlockProto {
        self.oldBlock.as_ref().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::default_instance())
    }

    fn get_oldBlock_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto> {
        &self.oldBlock
    }

    fn mut_oldBlock_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto> {
        &mut self.oldBlock
    }

    // required .hadoop.hdfs.ExtendedBlockProto newBlock = 3;

    pub fn clear_newBlock(&mut self) {
        self.newBlock.clear();
    }

    pub fn has_newBlock(&self) -> bool {
        self.newBlock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newBlock(&mut self, v: super::hdfs::ExtendedBlockProto) {
        self.newBlock = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_newBlock(&mut self) -> &mut super::hdfs::ExtendedBlockProto {
        if self.newBlock.is_none() {
            self.newBlock.set_default();
        }
        self.newBlock.as_mut().unwrap()
    }

    // Take field
    pub fn take_newBlock(&mut self) -> super::hdfs::ExtendedBlockProto {
        self.newBlock.take().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::new())
    }

    pub fn get_newBlock(&self) -> &super::hdfs::ExtendedBlockProto {
        self.newBlock.as_ref().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::default_instance())
    }

    fn get_newBlock_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto> {
        &self.newBlock
    }

    fn mut_newBlock_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto> {
        &mut self.newBlock
    }

    // repeated .hadoop.hdfs.DatanodeIDProto newNodes = 4;

    pub fn clear_newNodes(&mut self) {
        self.newNodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_newNodes(&mut self, v: ::protobuf::RepeatedField<super::hdfs::DatanodeIDProto>) {
        self.newNodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_newNodes(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::DatanodeIDProto> {
        &mut self.newNodes
    }

    // Take field
    pub fn take_newNodes(&mut self) -> ::protobuf::RepeatedField<super::hdfs::DatanodeIDProto> {
        ::std::mem::replace(&mut self.newNodes, ::protobuf::RepeatedField::new())
    }

    pub fn get_newNodes(&self) -> &[super::hdfs::DatanodeIDProto] {
        &self.newNodes
    }

    fn get_newNodes_for_reflect(&self) -> &::protobuf::RepeatedField<super::hdfs::DatanodeIDProto> {
        &self.newNodes
    }

    fn mut_newNodes_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::DatanodeIDProto> {
        &mut self.newNodes
    }

    // repeated string storageIDs = 5;

    pub fn clear_storageIDs(&mut self) {
        self.storageIDs.clear();
    }

    // Param is passed by value, moved
    pub fn set_storageIDs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.storageIDs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_storageIDs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.storageIDs
    }

    // Take field
    pub fn take_storageIDs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.storageIDs, ::protobuf::RepeatedField::new())
    }

    pub fn get_storageIDs(&self) -> &[::std::string::String] {
        &self.storageIDs
    }

    fn get_storageIDs_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.storageIDs
    }

    fn mut_storageIDs_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.storageIDs
    }
}

impl ::protobuf::Message for UpdatePipelineRequestProto {
    fn is_initialized(&self) -> bool {
        if self.clientName.is_none() {
            return false;
        }
        if self.oldBlock.is_none() {
            return false;
        }
        if self.newBlock.is_none() {
            return false;
        }
        for v in &self.oldBlock {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.newBlock {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.newNodes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.oldBlock)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.newBlock)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.newNodes)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.storageIDs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.oldBlock.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.newBlock.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.newNodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.storageIDs {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.oldBlock.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.newBlock.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.newNodes {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.storageIDs {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for UpdatePipelineRequestProto {
    fn new() -> UpdatePipelineRequestProto {
        UpdatePipelineRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<UpdatePipelineRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "clientName",
                    UpdatePipelineRequestProto::get_clientName_for_reflect,
                    UpdatePipelineRequestProto::mut_clientName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::ExtendedBlockProto>>(
                    "oldBlock",
                    UpdatePipelineRequestProto::get_oldBlock_for_reflect,
                    UpdatePipelineRequestProto::mut_oldBlock_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::ExtendedBlockProto>>(
                    "newBlock",
                    UpdatePipelineRequestProto::get_newBlock_for_reflect,
                    UpdatePipelineRequestProto::mut_newBlock_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DatanodeIDProto>>(
                    "newNodes",
                    UpdatePipelineRequestProto::get_newNodes_for_reflect,
                    UpdatePipelineRequestProto::mut_newNodes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "storageIDs",
                    UpdatePipelineRequestProto::get_storageIDs_for_reflect,
                    UpdatePipelineRequestProto::mut_storageIDs_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdatePipelineRequestProto>(
                    "UpdatePipelineRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for UpdatePipelineRequestProto {
    fn clear(&mut self) {
        self.clear_clientName();
        self.clear_oldBlock();
        self.clear_newBlock();
        self.clear_newNodes();
        self.clear_storageIDs();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdatePipelineRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdatePipelineRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdatePipelineResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for UpdatePipelineResponseProto {}

impl UpdatePipelineResponseProto {
    pub fn new() -> UpdatePipelineResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static UpdatePipelineResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<UpdatePipelineResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdatePipelineResponseProto,
        };
        unsafe {
            instance.get(UpdatePipelineResponseProto::new)
        }
    }
}

impl ::protobuf::Message for UpdatePipelineResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for UpdatePipelineResponseProto {
    fn new() -> UpdatePipelineResponseProto {
        UpdatePipelineResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<UpdatePipelineResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<UpdatePipelineResponseProto>(
                    "UpdatePipelineResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for UpdatePipelineResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdatePipelineResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdatePipelineResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetBalancerBandwidthRequestProto {
    // message fields
    bandwidth: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SetBalancerBandwidthRequestProto {}

impl SetBalancerBandwidthRequestProto {
    pub fn new() -> SetBalancerBandwidthRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetBalancerBandwidthRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<SetBalancerBandwidthRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetBalancerBandwidthRequestProto,
        };
        unsafe {
            instance.get(SetBalancerBandwidthRequestProto::new)
        }
    }

    // required int64 bandwidth = 1;

    pub fn clear_bandwidth(&mut self) {
        self.bandwidth = ::std::option::Option::None;
    }

    pub fn has_bandwidth(&self) -> bool {
        self.bandwidth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bandwidth(&mut self, v: i64) {
        self.bandwidth = ::std::option::Option::Some(v);
    }

    pub fn get_bandwidth(&self) -> i64 {
        self.bandwidth.unwrap_or(0)
    }

    fn get_bandwidth_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.bandwidth
    }

    fn mut_bandwidth_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.bandwidth
    }
}

impl ::protobuf::Message for SetBalancerBandwidthRequestProto {
    fn is_initialized(&self) -> bool {
        if self.bandwidth.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.bandwidth = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bandwidth {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bandwidth {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetBalancerBandwidthRequestProto {
    fn new() -> SetBalancerBandwidthRequestProto {
        SetBalancerBandwidthRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetBalancerBandwidthRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "bandwidth",
                    SetBalancerBandwidthRequestProto::get_bandwidth_for_reflect,
                    SetBalancerBandwidthRequestProto::mut_bandwidth_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetBalancerBandwidthRequestProto>(
                    "SetBalancerBandwidthRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetBalancerBandwidthRequestProto {
    fn clear(&mut self) {
        self.clear_bandwidth();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetBalancerBandwidthRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetBalancerBandwidthRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetBalancerBandwidthResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SetBalancerBandwidthResponseProto {}

impl SetBalancerBandwidthResponseProto {
    pub fn new() -> SetBalancerBandwidthResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetBalancerBandwidthResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<SetBalancerBandwidthResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetBalancerBandwidthResponseProto,
        };
        unsafe {
            instance.get(SetBalancerBandwidthResponseProto::new)
        }
    }
}

impl ::protobuf::Message for SetBalancerBandwidthResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetBalancerBandwidthResponseProto {
    fn new() -> SetBalancerBandwidthResponseProto {
        SetBalancerBandwidthResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetBalancerBandwidthResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SetBalancerBandwidthResponseProto>(
                    "SetBalancerBandwidthResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetBalancerBandwidthResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetBalancerBandwidthResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetBalancerBandwidthResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDataEncryptionKeyRequestProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetDataEncryptionKeyRequestProto {}

impl GetDataEncryptionKeyRequestProto {
    pub fn new() -> GetDataEncryptionKeyRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetDataEncryptionKeyRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetDataEncryptionKeyRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetDataEncryptionKeyRequestProto,
        };
        unsafe {
            instance.get(GetDataEncryptionKeyRequestProto::new)
        }
    }
}

impl ::protobuf::Message for GetDataEncryptionKeyRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetDataEncryptionKeyRequestProto {
    fn new() -> GetDataEncryptionKeyRequestProto {
        GetDataEncryptionKeyRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetDataEncryptionKeyRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<GetDataEncryptionKeyRequestProto>(
                    "GetDataEncryptionKeyRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetDataEncryptionKeyRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDataEncryptionKeyRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDataEncryptionKeyRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDataEncryptionKeyResponseProto {
    // message fields
    dataEncryptionKey: ::protobuf::SingularPtrField<super::hdfs::DataEncryptionKeyProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetDataEncryptionKeyResponseProto {}

impl GetDataEncryptionKeyResponseProto {
    pub fn new() -> GetDataEncryptionKeyResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetDataEncryptionKeyResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetDataEncryptionKeyResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetDataEncryptionKeyResponseProto,
        };
        unsafe {
            instance.get(GetDataEncryptionKeyResponseProto::new)
        }
    }

    // optional .hadoop.hdfs.DataEncryptionKeyProto dataEncryptionKey = 1;

    pub fn clear_dataEncryptionKey(&mut self) {
        self.dataEncryptionKey.clear();
    }

    pub fn has_dataEncryptionKey(&self) -> bool {
        self.dataEncryptionKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dataEncryptionKey(&mut self, v: super::hdfs::DataEncryptionKeyProto) {
        self.dataEncryptionKey = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dataEncryptionKey(&mut self) -> &mut super::hdfs::DataEncryptionKeyProto {
        if self.dataEncryptionKey.is_none() {
            self.dataEncryptionKey.set_default();
        }
        self.dataEncryptionKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_dataEncryptionKey(&mut self) -> super::hdfs::DataEncryptionKeyProto {
        self.dataEncryptionKey.take().unwrap_or_else(|| super::hdfs::DataEncryptionKeyProto::new())
    }

    pub fn get_dataEncryptionKey(&self) -> &super::hdfs::DataEncryptionKeyProto {
        self.dataEncryptionKey.as_ref().unwrap_or_else(|| super::hdfs::DataEncryptionKeyProto::default_instance())
    }

    fn get_dataEncryptionKey_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::DataEncryptionKeyProto> {
        &self.dataEncryptionKey
    }

    fn mut_dataEncryptionKey_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::DataEncryptionKeyProto> {
        &mut self.dataEncryptionKey
    }
}

impl ::protobuf::Message for GetDataEncryptionKeyResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.dataEncryptionKey {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dataEncryptionKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.dataEncryptionKey.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.dataEncryptionKey.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetDataEncryptionKeyResponseProto {
    fn new() -> GetDataEncryptionKeyResponseProto {
        GetDataEncryptionKeyResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetDataEncryptionKeyResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DataEncryptionKeyProto>>(
                    "dataEncryptionKey",
                    GetDataEncryptionKeyResponseProto::get_dataEncryptionKey_for_reflect,
                    GetDataEncryptionKeyResponseProto::mut_dataEncryptionKey_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetDataEncryptionKeyResponseProto>(
                    "GetDataEncryptionKeyResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetDataEncryptionKeyResponseProto {
    fn clear(&mut self) {
        self.clear_dataEncryptionKey();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDataEncryptionKeyResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDataEncryptionKeyResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateSnapshotRequestProto {
    // message fields
    snapshotRoot: ::protobuf::SingularField<::std::string::String>,
    snapshotName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CreateSnapshotRequestProto {}

impl CreateSnapshotRequestProto {
    pub fn new() -> CreateSnapshotRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CreateSnapshotRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<CreateSnapshotRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateSnapshotRequestProto,
        };
        unsafe {
            instance.get(CreateSnapshotRequestProto::new)
        }
    }

    // required string snapshotRoot = 1;

    pub fn clear_snapshotRoot(&mut self) {
        self.snapshotRoot.clear();
    }

    pub fn has_snapshotRoot(&self) -> bool {
        self.snapshotRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotRoot(&mut self, v: ::std::string::String) {
        self.snapshotRoot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotRoot(&mut self) -> &mut ::std::string::String {
        if self.snapshotRoot.is_none() {
            self.snapshotRoot.set_default();
        }
        self.snapshotRoot.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotRoot(&mut self) -> ::std::string::String {
        self.snapshotRoot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_snapshotRoot(&self) -> &str {
        match self.snapshotRoot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_snapshotRoot_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.snapshotRoot
    }

    fn mut_snapshotRoot_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.snapshotRoot
    }

    // optional string snapshotName = 2;

    pub fn clear_snapshotName(&mut self) {
        self.snapshotName.clear();
    }

    pub fn has_snapshotName(&self) -> bool {
        self.snapshotName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotName(&mut self, v: ::std::string::String) {
        self.snapshotName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotName(&mut self) -> &mut ::std::string::String {
        if self.snapshotName.is_none() {
            self.snapshotName.set_default();
        }
        self.snapshotName.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotName(&mut self) -> ::std::string::String {
        self.snapshotName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_snapshotName(&self) -> &str {
        match self.snapshotName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_snapshotName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.snapshotName
    }

    fn mut_snapshotName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.snapshotName
    }
}

impl ::protobuf::Message for CreateSnapshotRequestProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotRoot.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotRoot)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.snapshotName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.snapshotName.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CreateSnapshotRequestProto {
    fn new() -> CreateSnapshotRequestProto {
        CreateSnapshotRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CreateSnapshotRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "snapshotRoot",
                    CreateSnapshotRequestProto::get_snapshotRoot_for_reflect,
                    CreateSnapshotRequestProto::mut_snapshotRoot_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "snapshotName",
                    CreateSnapshotRequestProto::get_snapshotName_for_reflect,
                    CreateSnapshotRequestProto::mut_snapshotName_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateSnapshotRequestProto>(
                    "CreateSnapshotRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CreateSnapshotRequestProto {
    fn clear(&mut self) {
        self.clear_snapshotRoot();
        self.clear_snapshotName();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateSnapshotRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateSnapshotRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateSnapshotResponseProto {
    // message fields
    snapshotPath: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CreateSnapshotResponseProto {}

impl CreateSnapshotResponseProto {
    pub fn new() -> CreateSnapshotResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CreateSnapshotResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<CreateSnapshotResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateSnapshotResponseProto,
        };
        unsafe {
            instance.get(CreateSnapshotResponseProto::new)
        }
    }

    // required string snapshotPath = 1;

    pub fn clear_snapshotPath(&mut self) {
        self.snapshotPath.clear();
    }

    pub fn has_snapshotPath(&self) -> bool {
        self.snapshotPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotPath(&mut self, v: ::std::string::String) {
        self.snapshotPath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotPath(&mut self) -> &mut ::std::string::String {
        if self.snapshotPath.is_none() {
            self.snapshotPath.set_default();
        }
        self.snapshotPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotPath(&mut self) -> ::std::string::String {
        self.snapshotPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_snapshotPath(&self) -> &str {
        match self.snapshotPath.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_snapshotPath_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.snapshotPath
    }

    fn mut_snapshotPath_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.snapshotPath
    }
}

impl ::protobuf::Message for CreateSnapshotResponseProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotPath.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotPath)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshotPath.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshotPath.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CreateSnapshotResponseProto {
    fn new() -> CreateSnapshotResponseProto {
        CreateSnapshotResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CreateSnapshotResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "snapshotPath",
                    CreateSnapshotResponseProto::get_snapshotPath_for_reflect,
                    CreateSnapshotResponseProto::mut_snapshotPath_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateSnapshotResponseProto>(
                    "CreateSnapshotResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CreateSnapshotResponseProto {
    fn clear(&mut self) {
        self.clear_snapshotPath();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateSnapshotResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateSnapshotResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RenameSnapshotRequestProto {
    // message fields
    snapshotRoot: ::protobuf::SingularField<::std::string::String>,
    snapshotOldName: ::protobuf::SingularField<::std::string::String>,
    snapshotNewName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RenameSnapshotRequestProto {}

impl RenameSnapshotRequestProto {
    pub fn new() -> RenameSnapshotRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RenameSnapshotRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RenameSnapshotRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RenameSnapshotRequestProto,
        };
        unsafe {
            instance.get(RenameSnapshotRequestProto::new)
        }
    }

    // required string snapshotRoot = 1;

    pub fn clear_snapshotRoot(&mut self) {
        self.snapshotRoot.clear();
    }

    pub fn has_snapshotRoot(&self) -> bool {
        self.snapshotRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotRoot(&mut self, v: ::std::string::String) {
        self.snapshotRoot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotRoot(&mut self) -> &mut ::std::string::String {
        if self.snapshotRoot.is_none() {
            self.snapshotRoot.set_default();
        }
        self.snapshotRoot.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotRoot(&mut self) -> ::std::string::String {
        self.snapshotRoot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_snapshotRoot(&self) -> &str {
        match self.snapshotRoot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_snapshotRoot_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.snapshotRoot
    }

    fn mut_snapshotRoot_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.snapshotRoot
    }

    // required string snapshotOldName = 2;

    pub fn clear_snapshotOldName(&mut self) {
        self.snapshotOldName.clear();
    }

    pub fn has_snapshotOldName(&self) -> bool {
        self.snapshotOldName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotOldName(&mut self, v: ::std::string::String) {
        self.snapshotOldName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotOldName(&mut self) -> &mut ::std::string::String {
        if self.snapshotOldName.is_none() {
            self.snapshotOldName.set_default();
        }
        self.snapshotOldName.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotOldName(&mut self) -> ::std::string::String {
        self.snapshotOldName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_snapshotOldName(&self) -> &str {
        match self.snapshotOldName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_snapshotOldName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.snapshotOldName
    }

    fn mut_snapshotOldName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.snapshotOldName
    }

    // required string snapshotNewName = 3;

    pub fn clear_snapshotNewName(&mut self) {
        self.snapshotNewName.clear();
    }

    pub fn has_snapshotNewName(&self) -> bool {
        self.snapshotNewName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotNewName(&mut self, v: ::std::string::String) {
        self.snapshotNewName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotNewName(&mut self) -> &mut ::std::string::String {
        if self.snapshotNewName.is_none() {
            self.snapshotNewName.set_default();
        }
        self.snapshotNewName.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotNewName(&mut self) -> ::std::string::String {
        self.snapshotNewName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_snapshotNewName(&self) -> &str {
        match self.snapshotNewName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_snapshotNewName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.snapshotNewName
    }

    fn mut_snapshotNewName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.snapshotNewName
    }
}

impl ::protobuf::Message for RenameSnapshotRequestProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotRoot.is_none() {
            return false;
        }
        if self.snapshotOldName.is_none() {
            return false;
        }
        if self.snapshotNewName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotRoot)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotOldName)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotNewName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.snapshotOldName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.snapshotNewName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.snapshotOldName.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.snapshotNewName.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RenameSnapshotRequestProto {
    fn new() -> RenameSnapshotRequestProto {
        RenameSnapshotRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RenameSnapshotRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "snapshotRoot",
                    RenameSnapshotRequestProto::get_snapshotRoot_for_reflect,
                    RenameSnapshotRequestProto::mut_snapshotRoot_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "snapshotOldName",
                    RenameSnapshotRequestProto::get_snapshotOldName_for_reflect,
                    RenameSnapshotRequestProto::mut_snapshotOldName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "snapshotNewName",
                    RenameSnapshotRequestProto::get_snapshotNewName_for_reflect,
                    RenameSnapshotRequestProto::mut_snapshotNewName_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RenameSnapshotRequestProto>(
                    "RenameSnapshotRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RenameSnapshotRequestProto {
    fn clear(&mut self) {
        self.clear_snapshotRoot();
        self.clear_snapshotOldName();
        self.clear_snapshotNewName();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RenameSnapshotRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RenameSnapshotRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RenameSnapshotResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RenameSnapshotResponseProto {}

impl RenameSnapshotResponseProto {
    pub fn new() -> RenameSnapshotResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RenameSnapshotResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RenameSnapshotResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RenameSnapshotResponseProto,
        };
        unsafe {
            instance.get(RenameSnapshotResponseProto::new)
        }
    }
}

impl ::protobuf::Message for RenameSnapshotResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RenameSnapshotResponseProto {
    fn new() -> RenameSnapshotResponseProto {
        RenameSnapshotResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RenameSnapshotResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RenameSnapshotResponseProto>(
                    "RenameSnapshotResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RenameSnapshotResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RenameSnapshotResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RenameSnapshotResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AllowSnapshotRequestProto {
    // message fields
    snapshotRoot: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for AllowSnapshotRequestProto {}

impl AllowSnapshotRequestProto {
    pub fn new() -> AllowSnapshotRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AllowSnapshotRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<AllowSnapshotRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AllowSnapshotRequestProto,
        };
        unsafe {
            instance.get(AllowSnapshotRequestProto::new)
        }
    }

    // required string snapshotRoot = 1;

    pub fn clear_snapshotRoot(&mut self) {
        self.snapshotRoot.clear();
    }

    pub fn has_snapshotRoot(&self) -> bool {
        self.snapshotRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotRoot(&mut self, v: ::std::string::String) {
        self.snapshotRoot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotRoot(&mut self) -> &mut ::std::string::String {
        if self.snapshotRoot.is_none() {
            self.snapshotRoot.set_default();
        }
        self.snapshotRoot.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotRoot(&mut self) -> ::std::string::String {
        self.snapshotRoot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_snapshotRoot(&self) -> &str {
        match self.snapshotRoot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_snapshotRoot_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.snapshotRoot
    }

    fn mut_snapshotRoot_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.snapshotRoot
    }
}

impl ::protobuf::Message for AllowSnapshotRequestProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotRoot.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotRoot)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AllowSnapshotRequestProto {
    fn new() -> AllowSnapshotRequestProto {
        AllowSnapshotRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<AllowSnapshotRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "snapshotRoot",
                    AllowSnapshotRequestProto::get_snapshotRoot_for_reflect,
                    AllowSnapshotRequestProto::mut_snapshotRoot_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AllowSnapshotRequestProto>(
                    "AllowSnapshotRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AllowSnapshotRequestProto {
    fn clear(&mut self) {
        self.clear_snapshotRoot();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AllowSnapshotRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllowSnapshotRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AllowSnapshotResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for AllowSnapshotResponseProto {}

impl AllowSnapshotResponseProto {
    pub fn new() -> AllowSnapshotResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AllowSnapshotResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<AllowSnapshotResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AllowSnapshotResponseProto,
        };
        unsafe {
            instance.get(AllowSnapshotResponseProto::new)
        }
    }
}

impl ::protobuf::Message for AllowSnapshotResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AllowSnapshotResponseProto {
    fn new() -> AllowSnapshotResponseProto {
        AllowSnapshotResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<AllowSnapshotResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<AllowSnapshotResponseProto>(
                    "AllowSnapshotResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AllowSnapshotResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AllowSnapshotResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllowSnapshotResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DisallowSnapshotRequestProto {
    // message fields
    snapshotRoot: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for DisallowSnapshotRequestProto {}

impl DisallowSnapshotRequestProto {
    pub fn new() -> DisallowSnapshotRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DisallowSnapshotRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<DisallowSnapshotRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DisallowSnapshotRequestProto,
        };
        unsafe {
            instance.get(DisallowSnapshotRequestProto::new)
        }
    }

    // required string snapshotRoot = 1;

    pub fn clear_snapshotRoot(&mut self) {
        self.snapshotRoot.clear();
    }

    pub fn has_snapshotRoot(&self) -> bool {
        self.snapshotRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotRoot(&mut self, v: ::std::string::String) {
        self.snapshotRoot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotRoot(&mut self) -> &mut ::std::string::String {
        if self.snapshotRoot.is_none() {
            self.snapshotRoot.set_default();
        }
        self.snapshotRoot.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotRoot(&mut self) -> ::std::string::String {
        self.snapshotRoot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_snapshotRoot(&self) -> &str {
        match self.snapshotRoot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_snapshotRoot_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.snapshotRoot
    }

    fn mut_snapshotRoot_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.snapshotRoot
    }
}

impl ::protobuf::Message for DisallowSnapshotRequestProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotRoot.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotRoot)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DisallowSnapshotRequestProto {
    fn new() -> DisallowSnapshotRequestProto {
        DisallowSnapshotRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<DisallowSnapshotRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "snapshotRoot",
                    DisallowSnapshotRequestProto::get_snapshotRoot_for_reflect,
                    DisallowSnapshotRequestProto::mut_snapshotRoot_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DisallowSnapshotRequestProto>(
                    "DisallowSnapshotRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DisallowSnapshotRequestProto {
    fn clear(&mut self) {
        self.clear_snapshotRoot();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DisallowSnapshotRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisallowSnapshotRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DisallowSnapshotResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for DisallowSnapshotResponseProto {}

impl DisallowSnapshotResponseProto {
    pub fn new() -> DisallowSnapshotResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DisallowSnapshotResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<DisallowSnapshotResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DisallowSnapshotResponseProto,
        };
        unsafe {
            instance.get(DisallowSnapshotResponseProto::new)
        }
    }
}

impl ::protobuf::Message for DisallowSnapshotResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DisallowSnapshotResponseProto {
    fn new() -> DisallowSnapshotResponseProto {
        DisallowSnapshotResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<DisallowSnapshotResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<DisallowSnapshotResponseProto>(
                    "DisallowSnapshotResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DisallowSnapshotResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DisallowSnapshotResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisallowSnapshotResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteSnapshotRequestProto {
    // message fields
    snapshotRoot: ::protobuf::SingularField<::std::string::String>,
    snapshotName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for DeleteSnapshotRequestProto {}

impl DeleteSnapshotRequestProto {
    pub fn new() -> DeleteSnapshotRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DeleteSnapshotRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<DeleteSnapshotRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteSnapshotRequestProto,
        };
        unsafe {
            instance.get(DeleteSnapshotRequestProto::new)
        }
    }

    // required string snapshotRoot = 1;

    pub fn clear_snapshotRoot(&mut self) {
        self.snapshotRoot.clear();
    }

    pub fn has_snapshotRoot(&self) -> bool {
        self.snapshotRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotRoot(&mut self, v: ::std::string::String) {
        self.snapshotRoot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotRoot(&mut self) -> &mut ::std::string::String {
        if self.snapshotRoot.is_none() {
            self.snapshotRoot.set_default();
        }
        self.snapshotRoot.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotRoot(&mut self) -> ::std::string::String {
        self.snapshotRoot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_snapshotRoot(&self) -> &str {
        match self.snapshotRoot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_snapshotRoot_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.snapshotRoot
    }

    fn mut_snapshotRoot_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.snapshotRoot
    }

    // required string snapshotName = 2;

    pub fn clear_snapshotName(&mut self) {
        self.snapshotName.clear();
    }

    pub fn has_snapshotName(&self) -> bool {
        self.snapshotName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotName(&mut self, v: ::std::string::String) {
        self.snapshotName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotName(&mut self) -> &mut ::std::string::String {
        if self.snapshotName.is_none() {
            self.snapshotName.set_default();
        }
        self.snapshotName.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotName(&mut self) -> ::std::string::String {
        self.snapshotName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_snapshotName(&self) -> &str {
        match self.snapshotName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_snapshotName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.snapshotName
    }

    fn mut_snapshotName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.snapshotName
    }
}

impl ::protobuf::Message for DeleteSnapshotRequestProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotRoot.is_none() {
            return false;
        }
        if self.snapshotName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotRoot)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.snapshotName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.snapshotName.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DeleteSnapshotRequestProto {
    fn new() -> DeleteSnapshotRequestProto {
        DeleteSnapshotRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<DeleteSnapshotRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "snapshotRoot",
                    DeleteSnapshotRequestProto::get_snapshotRoot_for_reflect,
                    DeleteSnapshotRequestProto::mut_snapshotRoot_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "snapshotName",
                    DeleteSnapshotRequestProto::get_snapshotName_for_reflect,
                    DeleteSnapshotRequestProto::mut_snapshotName_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteSnapshotRequestProto>(
                    "DeleteSnapshotRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DeleteSnapshotRequestProto {
    fn clear(&mut self) {
        self.clear_snapshotRoot();
        self.clear_snapshotName();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteSnapshotRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteSnapshotRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteSnapshotResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for DeleteSnapshotResponseProto {}

impl DeleteSnapshotResponseProto {
    pub fn new() -> DeleteSnapshotResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DeleteSnapshotResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<DeleteSnapshotResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteSnapshotResponseProto,
        };
        unsafe {
            instance.get(DeleteSnapshotResponseProto::new)
        }
    }
}

impl ::protobuf::Message for DeleteSnapshotResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DeleteSnapshotResponseProto {
    fn new() -> DeleteSnapshotResponseProto {
        DeleteSnapshotResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<DeleteSnapshotResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<DeleteSnapshotResponseProto>(
                    "DeleteSnapshotResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DeleteSnapshotResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteSnapshotResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteSnapshotResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CheckAccessRequestProto {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    mode: ::std::option::Option<super::acl::AclEntryProto_FsActionProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CheckAccessRequestProto {}

impl CheckAccessRequestProto {
    pub fn new() -> CheckAccessRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CheckAccessRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<CheckAccessRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CheckAccessRequestProto,
        };
        unsafe {
            instance.get(CheckAccessRequestProto::new)
        }
    }

    // required string path = 1;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_path_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.path
    }

    fn mut_path_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.path
    }

    // required .hadoop.hdfs.AclEntryProto.FsActionProto mode = 2;

    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: super::acl::AclEntryProto_FsActionProto) {
        self.mode = ::std::option::Option::Some(v);
    }

    pub fn get_mode(&self) -> super::acl::AclEntryProto_FsActionProto {
        self.mode.unwrap_or(super::acl::AclEntryProto_FsActionProto::NONE)
    }

    fn get_mode_for_reflect(&self) -> &::std::option::Option<super::acl::AclEntryProto_FsActionProto> {
        &self.mode
    }

    fn mut_mode_for_reflect(&mut self) -> &mut ::std::option::Option<super::acl::AclEntryProto_FsActionProto> {
        &mut self.mode
    }
}

impl ::protobuf::Message for CheckAccessRequestProto {
    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        }
        if self.mode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.mode = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.mode {
            os.write_enum(2, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CheckAccessRequestProto {
    fn new() -> CheckAccessRequestProto {
        CheckAccessRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CheckAccessRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    CheckAccessRequestProto::get_path_for_reflect,
                    CheckAccessRequestProto::mut_path_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::acl::AclEntryProto_FsActionProto>>(
                    "mode",
                    CheckAccessRequestProto::get_mode_for_reflect,
                    CheckAccessRequestProto::mut_mode_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CheckAccessRequestProto>(
                    "CheckAccessRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CheckAccessRequestProto {
    fn clear(&mut self) {
        self.clear_path();
        self.clear_mode();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckAccessRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckAccessRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CheckAccessResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CheckAccessResponseProto {}

impl CheckAccessResponseProto {
    pub fn new() -> CheckAccessResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CheckAccessResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<CheckAccessResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CheckAccessResponseProto,
        };
        unsafe {
            instance.get(CheckAccessResponseProto::new)
        }
    }
}

impl ::protobuf::Message for CheckAccessResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CheckAccessResponseProto {
    fn new() -> CheckAccessResponseProto {
        CheckAccessResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CheckAccessResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CheckAccessResponseProto>(
                    "CheckAccessResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CheckAccessResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckAccessResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckAccessResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetCurrentEditLogTxidRequestProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetCurrentEditLogTxidRequestProto {}

impl GetCurrentEditLogTxidRequestProto {
    pub fn new() -> GetCurrentEditLogTxidRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetCurrentEditLogTxidRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetCurrentEditLogTxidRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetCurrentEditLogTxidRequestProto,
        };
        unsafe {
            instance.get(GetCurrentEditLogTxidRequestProto::new)
        }
    }
}

impl ::protobuf::Message for GetCurrentEditLogTxidRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetCurrentEditLogTxidRequestProto {
    fn new() -> GetCurrentEditLogTxidRequestProto {
        GetCurrentEditLogTxidRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetCurrentEditLogTxidRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<GetCurrentEditLogTxidRequestProto>(
                    "GetCurrentEditLogTxidRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetCurrentEditLogTxidRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetCurrentEditLogTxidRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCurrentEditLogTxidRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetCurrentEditLogTxidResponseProto {
    // message fields
    txid: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetCurrentEditLogTxidResponseProto {}

impl GetCurrentEditLogTxidResponseProto {
    pub fn new() -> GetCurrentEditLogTxidResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetCurrentEditLogTxidResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetCurrentEditLogTxidResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetCurrentEditLogTxidResponseProto,
        };
        unsafe {
            instance.get(GetCurrentEditLogTxidResponseProto::new)
        }
    }

    // required int64 txid = 1;

    pub fn clear_txid(&mut self) {
        self.txid = ::std::option::Option::None;
    }

    pub fn has_txid(&self) -> bool {
        self.txid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txid(&mut self, v: i64) {
        self.txid = ::std::option::Option::Some(v);
    }

    pub fn get_txid(&self) -> i64 {
        self.txid.unwrap_or(0)
    }

    fn get_txid_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.txid
    }

    fn mut_txid_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.txid
    }
}

impl ::protobuf::Message for GetCurrentEditLogTxidResponseProto {
    fn is_initialized(&self) -> bool {
        if self.txid.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.txid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.txid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.txid {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetCurrentEditLogTxidResponseProto {
    fn new() -> GetCurrentEditLogTxidResponseProto {
        GetCurrentEditLogTxidResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetCurrentEditLogTxidResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "txid",
                    GetCurrentEditLogTxidResponseProto::get_txid_for_reflect,
                    GetCurrentEditLogTxidResponseProto::mut_txid_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetCurrentEditLogTxidResponseProto>(
                    "GetCurrentEditLogTxidResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetCurrentEditLogTxidResponseProto {
    fn clear(&mut self) {
        self.clear_txid();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetCurrentEditLogTxidResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCurrentEditLogTxidResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetEditsFromTxidRequestProto {
    // message fields
    txid: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetEditsFromTxidRequestProto {}

impl GetEditsFromTxidRequestProto {
    pub fn new() -> GetEditsFromTxidRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetEditsFromTxidRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetEditsFromTxidRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetEditsFromTxidRequestProto,
        };
        unsafe {
            instance.get(GetEditsFromTxidRequestProto::new)
        }
    }

    // required int64 txid = 1;

    pub fn clear_txid(&mut self) {
        self.txid = ::std::option::Option::None;
    }

    pub fn has_txid(&self) -> bool {
        self.txid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txid(&mut self, v: i64) {
        self.txid = ::std::option::Option::Some(v);
    }

    pub fn get_txid(&self) -> i64 {
        self.txid.unwrap_or(0)
    }

    fn get_txid_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.txid
    }

    fn mut_txid_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.txid
    }
}

impl ::protobuf::Message for GetEditsFromTxidRequestProto {
    fn is_initialized(&self) -> bool {
        if self.txid.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.txid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.txid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.txid {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetEditsFromTxidRequestProto {
    fn new() -> GetEditsFromTxidRequestProto {
        GetEditsFromTxidRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetEditsFromTxidRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "txid",
                    GetEditsFromTxidRequestProto::get_txid_for_reflect,
                    GetEditsFromTxidRequestProto::mut_txid_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetEditsFromTxidRequestProto>(
                    "GetEditsFromTxidRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetEditsFromTxidRequestProto {
    fn clear(&mut self) {
        self.clear_txid();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetEditsFromTxidRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetEditsFromTxidRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetEditsFromTxidResponseProto {
    // message fields
    eventsList: ::protobuf::SingularPtrField<super::inotify::EventsListProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetEditsFromTxidResponseProto {}

impl GetEditsFromTxidResponseProto {
    pub fn new() -> GetEditsFromTxidResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetEditsFromTxidResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetEditsFromTxidResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetEditsFromTxidResponseProto,
        };
        unsafe {
            instance.get(GetEditsFromTxidResponseProto::new)
        }
    }

    // required .hadoop.hdfs.EventsListProto eventsList = 1;

    pub fn clear_eventsList(&mut self) {
        self.eventsList.clear();
    }

    pub fn has_eventsList(&self) -> bool {
        self.eventsList.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventsList(&mut self, v: super::inotify::EventsListProto) {
        self.eventsList = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eventsList(&mut self) -> &mut super::inotify::EventsListProto {
        if self.eventsList.is_none() {
            self.eventsList.set_default();
        }
        self.eventsList.as_mut().unwrap()
    }

    // Take field
    pub fn take_eventsList(&mut self) -> super::inotify::EventsListProto {
        self.eventsList.take().unwrap_or_else(|| super::inotify::EventsListProto::new())
    }

    pub fn get_eventsList(&self) -> &super::inotify::EventsListProto {
        self.eventsList.as_ref().unwrap_or_else(|| super::inotify::EventsListProto::default_instance())
    }

    fn get_eventsList_for_reflect(&self) -> &::protobuf::SingularPtrField<super::inotify::EventsListProto> {
        &self.eventsList
    }

    fn mut_eventsList_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::inotify::EventsListProto> {
        &mut self.eventsList
    }
}

impl ::protobuf::Message for GetEditsFromTxidResponseProto {
    fn is_initialized(&self) -> bool {
        if self.eventsList.is_none() {
            return false;
        }
        for v in &self.eventsList {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.eventsList)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.eventsList.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.eventsList.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetEditsFromTxidResponseProto {
    fn new() -> GetEditsFromTxidResponseProto {
        GetEditsFromTxidResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetEditsFromTxidResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::inotify::EventsListProto>>(
                    "eventsList",
                    GetEditsFromTxidResponseProto::get_eventsList_for_reflect,
                    GetEditsFromTxidResponseProto::mut_eventsList_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetEditsFromTxidResponseProto>(
                    "GetEditsFromTxidResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetEditsFromTxidResponseProto {
    fn clear(&mut self) {
        self.clear_eventsList();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetEditsFromTxidResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetEditsFromTxidResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CreateFlagProto {
    CREATE = 1,
    OVERWRITE = 2,
    APPEND = 4,
    LAZY_PERSIST = 16,
}

impl ::protobuf::ProtobufEnum for CreateFlagProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CreateFlagProto> {
        match value {
            1 => ::std::option::Option::Some(CreateFlagProto::CREATE),
            2 => ::std::option::Option::Some(CreateFlagProto::OVERWRITE),
            4 => ::std::option::Option::Some(CreateFlagProto::APPEND),
            16 => ::std::option::Option::Some(CreateFlagProto::LAZY_PERSIST),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CreateFlagProto] = &[
            CreateFlagProto::CREATE,
            CreateFlagProto::OVERWRITE,
            CreateFlagProto::APPEND,
            CreateFlagProto::LAZY_PERSIST,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CreateFlagProto>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CreateFlagProto", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CreateFlagProto {
}

impl ::protobuf::reflect::ProtobufValue for CreateFlagProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DatanodeReportTypeProto {
    ALL = 1,
    LIVE = 2,
    DEAD = 3,
    DECOMMISSIONING = 4,
}

impl ::protobuf::ProtobufEnum for DatanodeReportTypeProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DatanodeReportTypeProto> {
        match value {
            1 => ::std::option::Option::Some(DatanodeReportTypeProto::ALL),
            2 => ::std::option::Option::Some(DatanodeReportTypeProto::LIVE),
            3 => ::std::option::Option::Some(DatanodeReportTypeProto::DEAD),
            4 => ::std::option::Option::Some(DatanodeReportTypeProto::DECOMMISSIONING),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DatanodeReportTypeProto] = &[
            DatanodeReportTypeProto::ALL,
            DatanodeReportTypeProto::LIVE,
            DatanodeReportTypeProto::DEAD,
            DatanodeReportTypeProto::DECOMMISSIONING,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<DatanodeReportTypeProto>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DatanodeReportTypeProto", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DatanodeReportTypeProto {
}

impl ::protobuf::reflect::ProtobufValue for DatanodeReportTypeProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SafeModeActionProto {
    SAFEMODE_LEAVE = 1,
    SAFEMODE_ENTER = 2,
    SAFEMODE_GET = 3,
}

impl ::protobuf::ProtobufEnum for SafeModeActionProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SafeModeActionProto> {
        match value {
            1 => ::std::option::Option::Some(SafeModeActionProto::SAFEMODE_LEAVE),
            2 => ::std::option::Option::Some(SafeModeActionProto::SAFEMODE_ENTER),
            3 => ::std::option::Option::Some(SafeModeActionProto::SAFEMODE_GET),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SafeModeActionProto] = &[
            SafeModeActionProto::SAFEMODE_LEAVE,
            SafeModeActionProto::SAFEMODE_ENTER,
            SafeModeActionProto::SAFEMODE_GET,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<SafeModeActionProto>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("SafeModeActionProto", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SafeModeActionProto {
}

impl ::protobuf::reflect::ProtobufValue for SafeModeActionProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RollingUpgradeActionProto {
    QUERY = 1,
    START = 2,
    FINALIZE = 3,
}

impl ::protobuf::ProtobufEnum for RollingUpgradeActionProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RollingUpgradeActionProto> {
        match value {
            1 => ::std::option::Option::Some(RollingUpgradeActionProto::QUERY),
            2 => ::std::option::Option::Some(RollingUpgradeActionProto::START),
            3 => ::std::option::Option::Some(RollingUpgradeActionProto::FINALIZE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RollingUpgradeActionProto] = &[
            RollingUpgradeActionProto::QUERY,
            RollingUpgradeActionProto::START,
            RollingUpgradeActionProto::FINALIZE,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<RollingUpgradeActionProto>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("RollingUpgradeActionProto", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for RollingUpgradeActionProto {
}

impl ::protobuf::reflect::ProtobufValue for RollingUpgradeActionProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CacheFlagProto {
    FORCE = 1,
}

impl ::protobuf::ProtobufEnum for CacheFlagProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CacheFlagProto> {
        match value {
            1 => ::std::option::Option::Some(CacheFlagProto::FORCE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CacheFlagProto] = &[
            CacheFlagProto::FORCE,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CacheFlagProto>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CacheFlagProto", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CacheFlagProto {
}

impl ::protobuf::reflect::ProtobufValue for CacheFlagProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1cClientNamenodeProtocol.proto\x12\x0bhadoop.hdfs\x1a\x0eSecurity.pr\
    oto\x1a\nhdfs.proto\x1a\tacl.proto\x1a\x0bxattr.proto\x1a\x10encryption.\
    proto\x1a\rinotify.proto\"L\n\x1dGetBlockLocationsRequestProto\x12\x0b\n\
    \x03src\x18\x01\x20\x02(\t\x12\x0e\n\x06offset\x18\x02\x20\x02(\x04\x12\
    \x0e\n\x06length\x18\x03\x20\x02(\x04\"T\n\x1eGetBlockLocationsResponseP\
    roto\x122\n\tlocations\x18\x01\x20\x01(\x0b2\x1f.hadoop.hdfs.LocatedBloc\
    ksProto\"\x1f\n\x1dGetServerDefaultsRequestProto\"\\\n\x1eGetServerDefau\
    ltsResponseProto\x12:\n\x0eserverDefaults\x18\x01\x20\x02(\x0b2\".hadoop\
    .hdfs.FsServerDefaultsProto\"\xff\x01\n\x12CreateRequestProto\x12\x0b\n\
    \x03src\x18\x01\x20\x02(\t\x12.\n\x06masked\x18\x02\x20\x02(\x0b2\x1e.ha\
    doop.hdfs.FsPermissionProto\x12\x12\n\nclientName\x18\x03\x20\x02(\t\x12\
    \x12\n\ncreateFlag\x18\x04\x20\x02(\r\x12\x14\n\x0ccreateParent\x18\x05\
    \x20\x02(\x08\x12\x13\n\x0breplication\x18\x06\x20\x02(\r\x12\x11\n\tblo\
    ckSize\x18\x07\x20\x02(\x04\x12F\n\x15cryptoProtocolVersion\x18\x08\x20\
    \x03(\x0e2'.hadoop.hdfs.CryptoProtocolVersionProto\"C\n\x13CreateRespons\
    eProto\x12,\n\x02fs\x18\x01\x20\x01(\x0b2\x20.hadoop.hdfs.HdfsFileStatus\
    Proto\"5\n\x12AppendRequestProto\x12\x0b\n\x03src\x18\x01\x20\x02(\t\x12\
    \x12\n\nclientName\x18\x02\x20\x02(\t\"D\n\x13AppendResponseProto\x12-\n\
    \x05block\x18\x01\x20\x01(\x0b2\x1e.hadoop.hdfs.LocatedBlockProto\">\n\
    \x1aSetReplicationRequestProto\x12\x0b\n\x03src\x18\x01\x20\x02(\t\x12\
    \x13\n\x0breplication\x18\x02\x20\x02(\r\"-\n\x1bSetReplicationResponseP\
    roto\x12\x0e\n\x06result\x18\x01\x20\x02(\x08\"?\n\x1cSetStoragePolicyRe\
    questProto\x12\x0b\n\x03src\x18\x01\x20\x02(\t\x12\x12\n\npolicyName\x18\
    \x02\x20\x02(\t\"\x1f\n\x1dSetStoragePolicyResponseProto\"\x20\n\x1eGetS\
    toragePoliciesRequestProto\"Y\n\x1fGetStoragePoliciesResponseProto\x126\
    \n\x08policies\x18\x01\x20\x03(\x0b2$.hadoop.hdfs.BlockStoragePolicyProt\
    o\"\\\n\x19SetPermissionRequestProto\x12\x0b\n\x03src\x18\x01\x20\x02(\t\
    \x122\n\npermission\x18\x02\x20\x02(\x0b2\x1e.hadoop.hdfs.FsPermissionPr\
    oto\"\x1c\n\x1aSetPermissionResponseProto\"H\n\x14SetOwnerRequestProto\
    \x12\x0b\n\x03src\x18\x01\x20\x02(\t\x12\x10\n\x08username\x18\x02\x20\
    \x01(\t\x12\x11\n\tgroupname\x18\x03\x20\x01(\t\"\x17\n\x15SetOwnerRespo\
    nseProto\"v\n\x18AbandonBlockRequestProto\x12*\n\x01b\x18\x01\x20\x02(\
    \x0b2\x1f.hadoop.hdfs.ExtendedBlockProto\x12\x0b\n\x03src\x18\x02\x20\
    \x02(\t\x12\x0e\n\x06holder\x18\x03\x20\x02(\t\x12\x11\n\x06fileId\x18\
    \x04\x20\x01(\x04:\x010\"\x1b\n\x19AbandonBlockResponseProto\"\xc9\x01\n\
    \x14AddBlockRequestProto\x12\x0b\n\x03src\x18\x01\x20\x02(\t\x12\x12\n\n\
    clientName\x18\x02\x20\x02(\t\x121\n\x08previous\x18\x03\x20\x01(\x0b2\
    \x1f.hadoop.hdfs.ExtendedBlockProto\x124\n\x0cexcludeNodes\x18\x04\x20\
    \x03(\x0b2\x1e.hadoop.hdfs.DatanodeInfoProto\x12\x11\n\x06fileId\x18\x05\
    \x20\x01(\x04:\x010\x12\x14\n\x0cfavoredNodes\x18\x06\x20\x03(\t\"F\n\
    \x15AddBlockResponseProto\x12-\n\x05block\x18\x01\x20\x02(\x0b2\x1e.hado\
    op.hdfs.LocatedBlockProto\"\xa4\x02\n!GetAdditionalDatanodeRequestProto\
    \x12\x0b\n\x03src\x18\x01\x20\x02(\t\x12,\n\x03blk\x18\x02\x20\x02(\x0b2\
    \x1f.hadoop.hdfs.ExtendedBlockProto\x121\n\texistings\x18\x03\x20\x03(\
    \x0b2\x1e.hadoop.hdfs.DatanodeInfoProto\x120\n\x08excludes\x18\x04\x20\
    \x03(\x0b2\x1e.hadoop.hdfs.DatanodeInfoProto\x12\x1a\n\x12numAdditionalN\
    odes\x18\x05\x20\x02(\r\x12\x12\n\nclientName\x18\x06\x20\x02(\t\x12\x1c\
    \n\x14existingStorageUuids\x18\x07\x20\x03(\t\x12\x11\n\x06fileId\x18\
    \x08\x20\x01(\x04:\x010\"S\n\"GetAdditionalDatanodeResponseProto\x12-\n\
    \x05block\x18\x01\x20\x02(\x0b2\x1e.hadoop.hdfs.LocatedBlockProto\"y\n\
    \x14CompleteRequestProto\x12\x0b\n\x03src\x18\x01\x20\x02(\t\x12\x12\n\n\
    clientName\x18\x02\x20\x02(\t\x12-\n\x04last\x18\x03\x20\x01(\x0b2\x1f.h\
    adoop.hdfs.ExtendedBlockProto\x12\x11\n\x06fileId\x18\x04\x20\x01(\x04:\
    \x010\"'\n\x15CompleteResponseProto\x12\x0e\n\x06result\x18\x01\x20\x02(\
    \x08\"M\n\x1bReportBadBlocksRequestProto\x12.\n\x06blocks\x18\x01\x20\
    \x03(\x0b2\x1e.hadoop.hdfs.LocatedBlockProto\"\x1e\n\x1cReportBadBlocksR\
    esponseProto\"/\n\x12ConcatRequestProto\x12\x0b\n\x03trg\x18\x01\x20\x02\
    (\t\x12\x0c\n\x04srcs\x18\x02\x20\x03(\t\"\x15\n\x13ConcatResponseProto\
    \".\n\x12RenameRequestProto\x12\x0b\n\x03src\x18\x01\x20\x02(\t\x12\x0b\
    \n\x03dst\x18\x02\x20\x02(\t\"%\n\x13RenameResponseProto\x12\x0e\n\x06re\
    sult\x18\x01\x20\x02(\x08\"F\n\x13Rename2RequestProto\x12\x0b\n\x03src\
    \x18\x01\x20\x02(\t\x12\x0b\n\x03dst\x18\x02\x20\x02(\t\x12\x15\n\roverw\
    riteDest\x18\x03\x20\x02(\x08\"\x16\n\x14Rename2ResponseProto\"4\n\x12De\
    leteRequestProto\x12\x0b\n\x03src\x18\x01\x20\x02(\t\x12\x11\n\trecursiv\
    e\x18\x02\x20\x02(\x08\"%\n\x13DeleteResponseProto\x12\x0e\n\x06result\
    \x18\x01\x20\x02(\x08\"g\n\x12MkdirsRequestProto\x12\x0b\n\x03src\x18\
    \x01\x20\x02(\t\x12.\n\x06masked\x18\x02\x20\x02(\x0b2\x1e.hadoop.hdfs.F\
    sPermissionProto\x12\x14\n\x0ccreateParent\x18\x03\x20\x02(\x08\"%\n\x13\
    MkdirsResponseProto\x12\x0e\n\x06result\x18\x01\x20\x02(\x08\"O\n\x16Get\
    ListingRequestProto\x12\x0b\n\x03src\x18\x01\x20\x02(\t\x12\x12\n\nstart\
    After\x18\x02\x20\x02(\x0c\x12\x14\n\x0cneedLocation\x18\x03\x20\x02(\
    \x08\"N\n\x17GetListingResponseProto\x123\n\x07dirList\x18\x01\x20\x01(\
    \x0b2\".hadoop.hdfs.DirectoryListingProto\"(\n&GetSnapshottableDirListin\
    gRequestProto\"x\n'GetSnapshottableDirListingResponseProto\x12M\n\x14sna\
    pshottableDirList\x18\x01\x20\x01(\x0b2/.hadoop.hdfs.SnapshottableDirect\
    oryListingProto\"c\n!GetSnapshotDiffReportRequestProto\x12\x14\n\x0csnap\
    shotRoot\x18\x01\x20\x02(\t\x12\x14\n\x0cfromSnapshot\x18\x02\x20\x02(\t\
    \x12\x12\n\ntoSnapshot\x18\x03\x20\x02(\t\"^\n\"GetSnapshotDiffReportRes\
    ponseProto\x128\n\ndiffReport\x18\x01\x20\x02(\x0b2$.hadoop.hdfs.Snapsho\
    tDiffReportProto\",\n\x16RenewLeaseRequestProto\x12\x12\n\nclientName\
    \x18\x01\x20\x02(\t\"\x19\n\x17RenewLeaseResponseProto\";\n\x18RecoverLe\
    aseRequestProto\x12\x0b\n\x03src\x18\x01\x20\x02(\t\x12\x12\n\nclientNam\
    e\x18\x02\x20\x02(\t\"+\n\x19RecoverLeaseResponseProto\x12\x0e\n\x06resu\
    lt\x18\x01\x20\x02(\x08\"\x19\n\x17GetFsStatusRequestProto\"\x96\x01\n\
    \x17GetFsStatsResponseProto\x12\x10\n\x08capacity\x18\x01\x20\x02(\x04\
    \x12\x0c\n\x04used\x18\x02\x20\x02(\x04\x12\x11\n\tremaining\x18\x03\x20\
    \x02(\x04\x12\x18\n\x10under_replicated\x18\x04\x20\x02(\x04\x12\x16\n\
    \x0ecorrupt_blocks\x18\x05\x20\x02(\x04\x12\x16\n\x0emissing_blocks\x18\
    \x06\x20\x02(\x04\"S\n\x1dGetDatanodeReportRequestProto\x122\n\x04type\
    \x18\x01\x20\x02(\x0e2$.hadoop.hdfs.DatanodeReportTypeProto\"L\n\x1eGetD\
    atanodeReportResponseProto\x12*\n\x02di\x18\x01\x20\x03(\x0b2\x1e.hadoop\
    .hdfs.DatanodeInfoProto\"Z\n$GetDatanodeStorageReportRequestProto\x122\n\
    \x04type\x18\x01\x20\x02(\x0e2$.hadoop.hdfs.DatanodeReportTypeProto\"\
    \x8b\x01\n\x1aDatanodeStorageReportProto\x124\n\x0cdatanodeInfo\x18\x01\
    \x20\x02(\x0b2\x1e.hadoop.hdfs.DatanodeInfoProto\x127\n\x0estorageReport\
    s\x18\x02\x20\x03(\x0b2\x1f.hadoop.hdfs.StorageReportProto\"p\n%GetDatan\
    odeStorageReportResponseProto\x12G\n\x16datanodeStorageReports\x18\x01\
    \x20\x03(\x0b2'.hadoop.hdfs.DatanodeStorageReportProto\"5\n!GetPreferred\
    BlockSizeRequestProto\x12\x10\n\x08filename\x18\x01\x20\x02(\t\"3\n\"Get\
    PreferredBlockSizeResponseProto\x12\r\n\x05bsize\x18\x01\x20\x02(\x04\"c\
    \n\x17SetSafeModeRequestProto\x120\n\x06action\x18\x01\x20\x02(\x0e2\x20\
    .hadoop.hdfs.SafeModeActionProto\x12\x16\n\x07checked\x18\x02\x20\x01(\
    \x08:\x05false\"*\n\x18SetSafeModeResponseProto\x12\x0e\n\x06result\x18\
    \x01\x20\x02(\x08\"\x1b\n\x19SaveNamespaceRequestProto\"\x1c\n\x1aSaveNa\
    mespaceResponseProto\"\x17\n\x15RollEditsRequestProto\"0\n\x16RollEditsR\
    esponseProto\x12\x16\n\x0enewSegmentTxId\x18\x01\x20\x02(\x04\"/\n\x20Re\
    storeFailedStorageRequestProto\x12\x0b\n\x03arg\x18\x01\x20\x02(\t\"3\n!\
    RestoreFailedStorageResponseProto\x12\x0e\n\x06result\x18\x01\x20\x02(\
    \x08\"\x1a\n\x18RefreshNodesRequestProto\"\x1b\n\x19RefreshNodesResponse\
    Proto\"\x1d\n\x1bFinalizeUpgradeRequestProto\"\x1e\n\x1cFinalizeUpgradeR\
    esponseProto\"T\n\x1aRollingUpgradeRequestProto\x126\n\x06action\x18\x01\
    \x20\x02(\x0e2&.hadoop.hdfs.RollingUpgradeActionProto\"\x99\x01\n\x17Rol\
    lingUpgradeInfoProto\x126\n\x06status\x18\x01\x20\x02(\x0b2&.hadoop.hdfs\
    .RollingUpgradeStatusProto\x12\x11\n\tstartTime\x18\x02\x20\x02(\x04\x12\
    \x14\n\x0cfinalizeTime\x18\x03\x20\x02(\x04\x12\x1d\n\x15createdRollback\
    Images\x18\x04\x20\x02(\x08\"_\n\x1bRollingUpgradeResponseProto\x12@\n\
    \x12rollingUpgradeInfo\x18\x01\x20\x01(\x0b2$.hadoop.hdfs.RollingUpgrade\
    InfoProto\"A\n!ListCorruptFileBlocksRequestProto\x12\x0c\n\x04path\x18\
    \x01\x20\x02(\t\x12\x0e\n\x06cookie\x18\x02\x20\x01(\t\"Z\n\"ListCorrupt\
    FileBlocksResponseProto\x124\n\x07corrupt\x18\x01\x20\x02(\x0b2#.hadoop.\
    hdfs.CorruptFileBlocksProto\"(\n\x14MetaSaveRequestProto\x12\x10\n\x08fi\
    lename\x18\x01\x20\x02(\t\"\x17\n\x15MetaSaveResponseProto\"&\n\x17GetFi\
    leInfoRequestProto\x12\x0b\n\x03src\x18\x01\x20\x02(\t\"H\n\x18GetFileIn\
    foResponseProto\x12,\n\x02fs\x18\x01\x20\x01(\x0b2\x20.hadoop.hdfs.HdfsF\
    ileStatusProto\"'\n\x18IsFileClosedRequestProto\x12\x0b\n\x03src\x18\x01\
    \x20\x02(\t\"+\n\x19IsFileClosedResponseProto\x12\x0e\n\x06result\x18\
    \x01\x20\x02(\x08\"\x9a\x01\n\x17CacheDirectiveInfoProto\x12\n\n\x02id\
    \x18\x01\x20\x01(\x03\x12\x0c\n\x04path\x18\x02\x20\x01(\t\x12\x13\n\x0b\
    replication\x18\x03\x20\x01(\r\x12\x0c\n\x04pool\x18\x04\x20\x01(\t\x12B\
    \n\nexpiration\x18\x05\x20\x01(\x0b2..hadoop.hdfs.CacheDirectiveInfoExpi\
    rationProto\"G\n!CacheDirectiveInfoExpirationProto\x12\x0e\n\x06millis\
    \x18\x01\x20\x02(\x03\x12\x12\n\nisRelative\x18\x02\x20\x02(\x08\"\x82\
    \x01\n\x18CacheDirectiveStatsProto\x12\x13\n\x0bbytesNeeded\x18\x01\x20\
    \x02(\x03\x12\x13\n\x0bbytesCached\x18\x02\x20\x02(\x03\x12\x13\n\x0bfil\
    esNeeded\x18\x03\x20\x02(\x03\x12\x13\n\x0bfilesCached\x18\x04\x20\x02(\
    \x03\x12\x12\n\nhasExpired\x18\x05\x20\x02(\x08\"g\n\x1dAddCacheDirectiv\
    eRequestProto\x122\n\x04info\x18\x01\x20\x02(\x0b2$.hadoop.hdfs.CacheDir\
    ectiveInfoProto\x12\x12\n\ncacheFlags\x18\x02\x20\x01(\r\",\n\x1eAddCach\
    eDirectiveResponseProto\x12\n\n\x02id\x18\x01\x20\x02(\x03\"j\n\x20Modif\
    yCacheDirectiveRequestProto\x122\n\x04info\x18\x01\x20\x02(\x0b2$.hadoop\
    .hdfs.CacheDirectiveInfoProto\x12\x12\n\ncacheFlags\x18\x02\x20\x01(\r\"\
    #\n!ModifyCacheDirectiveResponseProto\".\n\x20RemoveCacheDirectiveReques\
    tProto\x12\n\n\x02id\x18\x01\x20\x02(\x03\"#\n!RemoveCacheDirectiveRespo\
    nseProto\"g\n\x1fListCacheDirectivesRequestProto\x12\x0e\n\x06prevId\x18\
    \x01\x20\x02(\x03\x124\n\x06filter\x18\x02\x20\x02(\x0b2$.hadoop.hdfs.Ca\
    cheDirectiveInfoProto\"\x84\x01\n\x18CacheDirectiveEntryProto\x122\n\x04\
    info\x18\x01\x20\x02(\x0b2$.hadoop.hdfs.CacheDirectiveInfoProto\x124\n\
    \x05stats\x18\x02\x20\x02(\x0b2%.hadoop.hdfs.CacheDirectiveStatsProto\"l\
    \n\x20ListCacheDirectivesResponseProto\x127\n\x08elements\x18\x01\x20\
    \x03(\x0b2%.hadoop.hdfs.CacheDirectiveEntryProto\x12\x0f\n\x07hasMore\
    \x18\x02\x20\x02(\x08\"\x84\x01\n\x12CachePoolInfoProto\x12\x10\n\x08poo\
    lName\x18\x01\x20\x01(\t\x12\x11\n\townerName\x18\x02\x20\x01(\t\x12\x11\
    \n\tgroupName\x18\x03\x20\x01(\t\x12\x0c\n\x04mode\x18\x04\x20\x01(\x05\
    \x12\r\n\x05limit\x18\x05\x20\x01(\x03\x12\x19\n\x11maxRelativeExpiry\
    \x18\x06\x20\x01(\x03\"\x81\x01\n\x13CachePoolStatsProto\x12\x13\n\x0bby\
    tesNeeded\x18\x01\x20\x02(\x03\x12\x13\n\x0bbytesCached\x18\x02\x20\x02(\
    \x03\x12\x16\n\x0ebytesOverlimit\x18\x03\x20\x02(\x03\x12\x13\n\x0bfiles\
    Needed\x18\x04\x20\x02(\x03\x12\x13\n\x0bfilesCached\x18\x05\x20\x02(\
    \x03\"I\n\x18AddCachePoolRequestProto\x12-\n\x04info\x18\x01\x20\x02(\
    \x0b2\x1f.hadoop.hdfs.CachePoolInfoProto\"\x1b\n\x19AddCachePoolResponse\
    Proto\"L\n\x1bModifyCachePoolRequestProto\x12-\n\x04info\x18\x01\x20\x02\
    (\x0b2\x1f.hadoop.hdfs.CachePoolInfoProto\"\x1e\n\x1cModifyCachePoolResp\
    onseProto\"/\n\x1bRemoveCachePoolRequestProto\x12\x10\n\x08poolName\x18\
    \x01\x20\x02(\t\"\x1e\n\x1cRemoveCachePoolResponseProto\"2\n\x1aListCach\
    ePoolsRequestProto\x12\x14\n\x0cprevPoolName\x18\x01\x20\x02(\t\"a\n\x1b\
    ListCachePoolsResponseProto\x121\n\x07entries\x18\x01\x20\x03(\x0b2\x20.\
    hadoop.hdfs.CachePoolEntryProto\x12\x0f\n\x07hasMore\x18\x02\x20\x02(\
    \x08\"u\n\x13CachePoolEntryProto\x12-\n\x04info\x18\x01\x20\x02(\x0b2\
    \x1f.hadoop.hdfs.CachePoolInfoProto\x12/\n\x05stats\x18\x02\x20\x02(\x0b\
    2\x20.hadoop.hdfs.CachePoolStatsProto\"*\n\x1bGetFileLinkInfoRequestProt\
    o\x12\x0b\n\x03src\x18\x01\x20\x02(\t\"L\n\x1cGetFileLinkInfoResponsePro\
    to\x12,\n\x02fs\x18\x01\x20\x01(\x0b2\x20.hadoop.hdfs.HdfsFileStatusProt\
    o\"-\n\x1dGetContentSummaryRequestProto\x12\x0c\n\x04path\x18\x01\x20\
    \x02(\t\"S\n\x1eGetContentSummaryResponseProto\x121\n\x07summary\x18\x01\
    \x20\x02(\x0b2\x20.hadoop.hdfs.ContentSummaryProto\"T\n\x14SetQuotaReque\
    stProto\x12\x0c\n\x04path\x18\x01\x20\x02(\t\x12\x16\n\x0enamespaceQuota\
    \x18\x02\x20\x02(\x04\x12\x16\n\x0ediskspaceQuota\x18\x03\x20\x02(\x04\"\
    \x17\n\x15SetQuotaResponseProto\"`\n\x11FsyncRequestProto\x12\x0b\n\x03s\
    rc\x18\x01\x20\x02(\t\x12\x0e\n\x06client\x18\x02\x20\x02(\t\x12\x1b\n\
    \x0flastBlockLength\x18\x03\x20\x01(\x12:\x02-1\x12\x11\n\x06fileId\x18\
    \x04\x20\x01(\x04:\x010\"\x14\n\x12FsyncResponseProto\"A\n\x14SetTimesRe\
    questProto\x12\x0b\n\x03src\x18\x01\x20\x02(\t\x12\r\n\x05mtime\x18\x02\
    \x20\x02(\x04\x12\r\n\x05atime\x18\x03\x20\x02(\x04\"\x17\n\x15SetTimesR\
    esponseProto\"\x80\x01\n\x19CreateSymlinkRequestProto\x12\x0e\n\x06targe\
    t\x18\x01\x20\x02(\t\x12\x0c\n\x04link\x18\x02\x20\x02(\t\x12/\n\x07dirP\
    erm\x18\x03\x20\x02(\x0b2\x1e.hadoop.hdfs.FsPermissionProto\x12\x14\n\
    \x0ccreateParent\x18\x04\x20\x02(\x08\"\x1c\n\x1aCreateSymlinkResponsePr\
    oto\")\n\x19GetLinkTargetRequestProto\x12\x0c\n\x04path\x18\x01\x20\x02(\
    \t\"0\n\x1aGetLinkTargetResponseProto\x12\x12\n\ntargetPath\x18\x01\x20\
    \x01(\t\"h\n\"UpdateBlockForPipelineRequestProto\x12.\n\x05block\x18\x01\
    \x20\x02(\x0b2\x1f.hadoop.hdfs.ExtendedBlockProto\x12\x12\n\nclientName\
    \x18\x02\x20\x02(\t\"T\n#UpdateBlockForPipelineResponseProto\x12-\n\x05b\
    lock\x18\x01\x20\x02(\x0b2\x1e.hadoop.hdfs.LocatedBlockProto\"\xda\x01\n\
    \x1aUpdatePipelineRequestProto\x12\x12\n\nclientName\x18\x01\x20\x02(\t\
    \x121\n\x08oldBlock\x18\x02\x20\x02(\x0b2\x1f.hadoop.hdfs.ExtendedBlockP\
    roto\x121\n\x08newBlock\x18\x03\x20\x02(\x0b2\x1f.hadoop.hdfs.ExtendedBl\
    ockProto\x12.\n\x08newNodes\x18\x04\x20\x03(\x0b2\x1c.hadoop.hdfs.Datano\
    deIDProto\x12\x12\n\nstorageIDs\x18\x05\x20\x03(\t\"\x1d\n\x1bUpdatePipe\
    lineResponseProto\"5\n\x20SetBalancerBandwidthRequestProto\x12\x11\n\tba\
    ndwidth\x18\x01\x20\x02(\x03\"#\n!SetBalancerBandwidthResponseProto\"\"\
    \n\x20GetDataEncryptionKeyRequestProto\"c\n!GetDataEncryptionKeyResponse\
    Proto\x12>\n\x11dataEncryptionKey\x18\x01\x20\x01(\x0b2#.hadoop.hdfs.Dat\
    aEncryptionKeyProto\"H\n\x1aCreateSnapshotRequestProto\x12\x14\n\x0csnap\
    shotRoot\x18\x01\x20\x02(\t\x12\x14\n\x0csnapshotName\x18\x02\x20\x01(\t\
    \"3\n\x1bCreateSnapshotResponseProto\x12\x14\n\x0csnapshotPath\x18\x01\
    \x20\x02(\t\"d\n\x1aRenameSnapshotRequestProto\x12\x14\n\x0csnapshotRoot\
    \x18\x01\x20\x02(\t\x12\x17\n\x0fsnapshotOldName\x18\x02\x20\x02(\t\x12\
    \x17\n\x0fsnapshotNewName\x18\x03\x20\x02(\t\"\x1d\n\x1bRenameSnapshotRe\
    sponseProto\"1\n\x19AllowSnapshotRequestProto\x12\x14\n\x0csnapshotRoot\
    \x18\x01\x20\x02(\t\"\x1c\n\x1aAllowSnapshotResponseProto\"4\n\x1cDisall\
    owSnapshotRequestProto\x12\x14\n\x0csnapshotRoot\x18\x01\x20\x02(\t\"\
    \x1f\n\x1dDisallowSnapshotResponseProto\"H\n\x1aDeleteSnapshotRequestPro\
    to\x12\x14\n\x0csnapshotRoot\x18\x01\x20\x02(\t\x12\x14\n\x0csnapshotNam\
    e\x18\x02\x20\x02(\t\"\x1d\n\x1bDeleteSnapshotResponseProto\"_\n\x17Chec\
    kAccessRequestProto\x12\x0c\n\x04path\x18\x01\x20\x02(\t\x126\n\x04mode\
    \x18\x02\x20\x02(\x0e2(.hadoop.hdfs.AclEntryProto.FsActionProto\"\x1a\n\
    \x18CheckAccessResponseProto\"#\n!GetCurrentEditLogTxidRequestProto\"2\n\
    \"GetCurrentEditLogTxidResponseProto\x12\x0c\n\x04txid\x18\x01\x20\x02(\
    \x03\",\n\x1cGetEditsFromTxidRequestProto\x12\x0c\n\x04txid\x18\x01\x20\
    \x02(\x03\"Q\n\x1dGetEditsFromTxidResponseProto\x120\n\neventsList\x18\
    \x01\x20\x02(\x0b2\x1c.hadoop.hdfs.EventsListProto*J\n\x0fCreateFlagProt\
    o\x12\n\n\x06CREATE\x10\x01\x12\r\n\tOVERWRITE\x10\x02\x12\n\n\x06APPEND\
    \x10\x04\x12\x10\n\x0cLAZY_PERSIST\x10\x10*K\n\x17DatanodeReportTypeProt\
    o\x12\x07\n\x03ALL\x10\x01\x12\x08\n\x04LIVE\x10\x02\x12\x08\n\x04DEAD\
    \x10\x03\x12\x13\n\x0fDECOMMISSIONING\x10\x04*O\n\x13SafeModeActionProto\
    \x12\x12\n\x0eSAFEMODE_LEAVE\x10\x01\x12\x12\n\x0eSAFEMODE_ENTER\x10\x02\
    \x12\x10\n\x0cSAFEMODE_GET\x10\x03*?\n\x19RollingUpgradeActionProto\x12\
    \t\n\x05QUERY\x10\x01\x12\t\n\x05START\x10\x02\x12\x0c\n\x08FINALIZE\x10\
    \x03*\x1b\n\x0eCacheFlagProto\x12\t\n\x05FORCE\x10\x012\xdd@\n\x16Client\
    NamenodeProtocol\x12l\n\x11getBlockLocations\x12*.hadoop.hdfs.GetBlockLo\
    cationsRequestProto\x1a+.hadoop.hdfs.GetBlockLocationsResponseProto\x12l\
    \n\x11getServerDefaults\x12*.hadoop.hdfs.GetServerDefaultsRequestProto\
    \x1a+.hadoop.hdfs.GetServerDefaultsResponseProto\x12K\n\x06create\x12\
    \x1f.hadoop.hdfs.CreateRequestProto\x1a\x20.hadoop.hdfs.CreateResponsePr\
    oto\x12K\n\x06append\x12\x1f.hadoop.hdfs.AppendRequestProto\x1a\x20.hado\
    op.hdfs.AppendResponseProto\x12c\n\x0esetReplication\x12'.hadoop.hdfs.Se\
    tReplicationRequestProto\x1a(.hadoop.hdfs.SetReplicationResponseProto\
    \x12i\n\x10setStoragePolicy\x12).hadoop.hdfs.SetStoragePolicyRequestProt\
    o\x1a*.hadoop.hdfs.SetStoragePolicyResponseProto\x12o\n\x12getStoragePol\
    icies\x12+.hadoop.hdfs.GetStoragePoliciesRequestProto\x1a,.hadoop.hdfs.G\
    etStoragePoliciesResponseProto\x12`\n\rsetPermission\x12&.hadoop.hdfs.Se\
    tPermissionRequestProto\x1a'.hadoop.hdfs.SetPermissionResponseProto\x12Q\
    \n\x08setOwner\x12!.hadoop.hdfs.SetOwnerRequestProto\x1a\".hadoop.hdfs.S\
    etOwnerResponseProto\x12]\n\x0cabandonBlock\x12%.hadoop.hdfs.AbandonBloc\
    kRequestProto\x1a&.hadoop.hdfs.AbandonBlockResponseProto\x12Q\n\x08addBl\
    ock\x12!.hadoop.hdfs.AddBlockRequestProto\x1a\".hadoop.hdfs.AddBlockResp\
    onseProto\x12x\n\x15getAdditionalDatanode\x12..hadoop.hdfs.GetAdditional\
    DatanodeRequestProto\x1a/.hadoop.hdfs.GetAdditionalDatanodeResponseProto\
    \x12Q\n\x08complete\x12!.hadoop.hdfs.CompleteRequestProto\x1a\".hadoop.h\
    dfs.CompleteResponseProto\x12f\n\x0freportBadBlocks\x12(.hadoop.hdfs.Rep\
    ortBadBlocksRequestProto\x1a).hadoop.hdfs.ReportBadBlocksResponseProto\
    \x12K\n\x06concat\x12\x1f.hadoop.hdfs.ConcatRequestProto\x1a\x20.hadoop.\
    hdfs.ConcatResponseProto\x12K\n\x06rename\x12\x1f.hadoop.hdfs.RenameRequ\
    estProto\x1a\x20.hadoop.hdfs.RenameResponseProto\x12N\n\x07rename2\x12\
    \x20.hadoop.hdfs.Rename2RequestProto\x1a!.hadoop.hdfs.Rename2ResponsePro\
    to\x12K\n\x06delete\x12\x1f.hadoop.hdfs.DeleteRequestProto\x1a\x20.hadoo\
    p.hdfs.DeleteResponseProto\x12K\n\x06mkdirs\x12\x1f.hadoop.hdfs.MkdirsRe\
    questProto\x1a\x20.hadoop.hdfs.MkdirsResponseProto\x12W\n\ngetListing\
    \x12#.hadoop.hdfs.GetListingRequestProto\x1a$.hadoop.hdfs.GetListingResp\
    onseProto\x12W\n\nrenewLease\x12#.hadoop.hdfs.RenewLeaseRequestProto\x1a\
    $.hadoop.hdfs.RenewLeaseResponseProto\x12]\n\x0crecoverLease\x12%.hadoop\
    .hdfs.RecoverLeaseRequestProto\x1a&.hadoop.hdfs.RecoverLeaseResponseProt\
    o\x12X\n\ngetFsStats\x12$.hadoop.hdfs.GetFsStatusRequestProto\x1a$.hadoo\
    p.hdfs.GetFsStatsResponseProto\x12l\n\x11getDatanodeReport\x12*.hadoop.h\
    dfs.GetDatanodeReportRequestProto\x1a+.hadoop.hdfs.GetDatanodeReportResp\
    onseProto\x12\x81\x01\n\x18getDatanodeStorageReport\x121.hadoop.hdfs.Get\
    DatanodeStorageReportRequestProto\x1a2.hadoop.hdfs.GetDatanodeStorageRep\
    ortResponseProto\x12x\n\x15getPreferredBlockSize\x12..hadoop.hdfs.GetPre\
    ferredBlockSizeRequestProto\x1a/.hadoop.hdfs.GetPreferredBlockSizeRespon\
    seProto\x12Z\n\x0bsetSafeMode\x12$.hadoop.hdfs.SetSafeModeRequestProto\
    \x1a%.hadoop.hdfs.SetSafeModeResponseProto\x12`\n\rsaveNamespace\x12&.ha\
    doop.hdfs.SaveNamespaceRequestProto\x1a'.hadoop.hdfs.SaveNamespaceRespon\
    seProto\x12T\n\trollEdits\x12\".hadoop.hdfs.RollEditsRequestProto\x1a#.h\
    adoop.hdfs.RollEditsResponseProto\x12u\n\x14restoreFailedStorage\x12-.ha\
    doop.hdfs.RestoreFailedStorageRequestProto\x1a..hadoop.hdfs.RestoreFaile\
    dStorageResponseProto\x12]\n\x0crefreshNodes\x12%.hadoop.hdfs.RefreshNod\
    esRequestProto\x1a&.hadoop.hdfs.RefreshNodesResponseProto\x12f\n\x0ffina\
    lizeUpgrade\x12(.hadoop.hdfs.FinalizeUpgradeRequestProto\x1a).hadoop.hdf\
    s.FinalizeUpgradeResponseProto\x12c\n\x0erollingUpgrade\x12'.hadoop.hdfs\
    .RollingUpgradeRequestProto\x1a(.hadoop.hdfs.RollingUpgradeResponseProto\
    \x12x\n\x15listCorruptFileBlocks\x12..hadoop.hdfs.ListCorruptFileBlocksR\
    equestProto\x1a/.hadoop.hdfs.ListCorruptFileBlocksResponseProto\x12Q\n\
    \x08metaSave\x12!.hadoop.hdfs.MetaSaveRequestProto\x1a\".hadoop.hdfs.Met\
    aSaveResponseProto\x12Z\n\x0bgetFileInfo\x12$.hadoop.hdfs.GetFileInfoReq\
    uestProto\x1a%.hadoop.hdfs.GetFileInfoResponseProto\x12l\n\x11addCacheDi\
    rective\x12*.hadoop.hdfs.AddCacheDirectiveRequestProto\x1a+.hadoop.hdfs.\
    AddCacheDirectiveResponseProto\x12u\n\x14modifyCacheDirective\x12-.hadoo\
    p.hdfs.ModifyCacheDirectiveRequestProto\x1a..hadoop.hdfs.ModifyCacheDire\
    ctiveResponseProto\x12u\n\x14removeCacheDirective\x12-.hadoop.hdfs.Remov\
    eCacheDirectiveRequestProto\x1a..hadoop.hdfs.RemoveCacheDirectiveRespons\
    eProto\x12r\n\x13listCacheDirectives\x12,.hadoop.hdfs.ListCacheDirective\
    sRequestProto\x1a-.hadoop.hdfs.ListCacheDirectivesResponseProto\x12]\n\
    \x0caddCachePool\x12%.hadoop.hdfs.AddCachePoolRequestProto\x1a&.hadoop.h\
    dfs.AddCachePoolResponseProto\x12f\n\x0fmodifyCachePool\x12(.hadoop.hdfs\
    .ModifyCachePoolRequestProto\x1a).hadoop.hdfs.ModifyCachePoolResponsePro\
    to\x12f\n\x0fremoveCachePool\x12(.hadoop.hdfs.RemoveCachePoolRequestProt\
    o\x1a).hadoop.hdfs.RemoveCachePoolResponseProto\x12c\n\x0elistCachePools\
    \x12'.hadoop.hdfs.ListCachePoolsRequestProto\x1a(.hadoop.hdfs.ListCacheP\
    oolsResponseProto\x12f\n\x0fgetFileLinkInfo\x12(.hadoop.hdfs.GetFileLink\
    InfoRequestProto\x1a).hadoop.hdfs.GetFileLinkInfoResponseProto\x12l\n\
    \x11getContentSummary\x12*.hadoop.hdfs.GetContentSummaryRequestProto\x1a\
    +.hadoop.hdfs.GetContentSummaryResponseProto\x12Q\n\x08setQuota\x12!.had\
    oop.hdfs.SetQuotaRequestProto\x1a\".hadoop.hdfs.SetQuotaResponseProto\
    \x12H\n\x05fsync\x12\x1e.hadoop.hdfs.FsyncRequestProto\x1a\x1f.hadoop.hd\
    fs.FsyncResponseProto\x12Q\n\x08setTimes\x12!.hadoop.hdfs.SetTimesReques\
    tProto\x1a\".hadoop.hdfs.SetTimesResponseProto\x12`\n\rcreateSymlink\x12\
    &.hadoop.hdfs.CreateSymlinkRequestProto\x1a'.hadoop.hdfs.CreateSymlinkRe\
    sponseProto\x12`\n\rgetLinkTarget\x12&.hadoop.hdfs.GetLinkTargetRequestP\
    roto\x1a'.hadoop.hdfs.GetLinkTargetResponseProto\x12{\n\x16updateBlockFo\
    rPipeline\x12/.hadoop.hdfs.UpdateBlockForPipelineRequestProto\x1a0.hadoo\
    p.hdfs.UpdateBlockForPipelineResponseProto\x12c\n\x0eupdatePipeline\x12'\
    .hadoop.hdfs.UpdatePipelineRequestProto\x1a(.hadoop.hdfs.UpdatePipelineR\
    esponseProto\x12s\n\x12getDelegationToken\x12-.hadoop.common.GetDelegati\
    onTokenRequestProto\x1a..hadoop.common.GetDelegationTokenResponseProto\
    \x12y\n\x14renewDelegationToken\x12/.hadoop.common.RenewDelegationTokenR\
    equestProto\x1a0.hadoop.common.RenewDelegationTokenResponseProto\x12|\n\
    \x15cancelDelegationToken\x120.hadoop.common.CancelDelegationTokenReques\
    tProto\x1a1.hadoop.common.CancelDelegationTokenResponseProto\x12u\n\x14s\
    etBalancerBandwidth\x12-.hadoop.hdfs.SetBalancerBandwidthRequestProto\
    \x1a..hadoop.hdfs.SetBalancerBandwidthResponseProto\x12u\n\x14getDataEnc\
    ryptionKey\x12-.hadoop.hdfs.GetDataEncryptionKeyRequestProto\x1a..hadoop\
    .hdfs.GetDataEncryptionKeyResponseProto\x12c\n\x0ecreateSnapshot\x12'.ha\
    doop.hdfs.CreateSnapshotRequestProto\x1a(.hadoop.hdfs.CreateSnapshotResp\
    onseProto\x12c\n\x0erenameSnapshot\x12'.hadoop.hdfs.RenameSnapshotReques\
    tProto\x1a(.hadoop.hdfs.RenameSnapshotResponseProto\x12`\n\rallowSnapsho\
    t\x12&.hadoop.hdfs.AllowSnapshotRequestProto\x1a'.hadoop.hdfs.AllowSnaps\
    hotResponseProto\x12i\n\x10disallowSnapshot\x12).hadoop.hdfs.DisallowSna\
    pshotRequestProto\x1a*.hadoop.hdfs.DisallowSnapshotResponseProto\x12\x87\
    \x01\n\x1agetSnapshottableDirListing\x123.hadoop.hdfs.GetSnapshottableDi\
    rListingRequestProto\x1a4.hadoop.hdfs.GetSnapshottableDirListingResponse\
    Proto\x12c\n\x0edeleteSnapshot\x12'.hadoop.hdfs.DeleteSnapshotRequestPro\
    to\x1a(.hadoop.hdfs.DeleteSnapshotResponseProto\x12x\n\x15getSnapshotDif\
    fReport\x12..hadoop.hdfs.GetSnapshotDiffReportRequestProto\x1a/.hadoop.h\
    dfs.GetSnapshotDiffReportResponseProto\x12]\n\x0cisFileClosed\x12%.hadoo\
    p.hdfs.IsFileClosedRequestProto\x1a&.hadoop.hdfs.IsFileClosedResponsePro\
    to\x12i\n\x10modifyAclEntries\x12).hadoop.hdfs.ModifyAclEntriesRequestPr\
    oto\x1a*.hadoop.hdfs.ModifyAclEntriesResponseProto\x12i\n\x10removeAclEn\
    tries\x12).hadoop.hdfs.RemoveAclEntriesRequestProto\x1a*.hadoop.hdfs.Rem\
    oveAclEntriesResponseProto\x12i\n\x10removeDefaultAcl\x12).hadoop.hdfs.R\
    emoveDefaultAclRequestProto\x1a*.hadoop.hdfs.RemoveDefaultAclResponsePro\
    to\x12T\n\tremoveAcl\x12\".hadoop.hdfs.RemoveAclRequestProto\x1a#.hadoop\
    .hdfs.RemoveAclResponseProto\x12K\n\x06setAcl\x12\x1f.hadoop.hdfs.SetAcl\
    RequestProto\x1a\x20.hadoop.hdfs.SetAclResponseProto\x12]\n\x0cgetAclSta\
    tus\x12%.hadoop.hdfs.GetAclStatusRequestProto\x1a&.hadoop.hdfs.GetAclSta\
    tusResponseProto\x12Q\n\x08setXAttr\x12!.hadoop.hdfs.SetXAttrRequestProt\
    o\x1a\".hadoop.hdfs.SetXAttrResponseProto\x12T\n\tgetXAttrs\x12\".hadoop\
    .hdfs.GetXAttrsRequestProto\x1a#.hadoop.hdfs.GetXAttrsResponseProto\x12W\
    \n\nlistXAttrs\x12#.hadoop.hdfs.ListXAttrsRequestProto\x1a$.hadoop.hdfs.\
    ListXAttrsResponseProto\x12Z\n\x0bremoveXAttr\x12$.hadoop.hdfs.RemoveXAt\
    trRequestProto\x1a%.hadoop.hdfs.RemoveXAttrResponseProto\x12Z\n\x0bcheck\
    Access\x12$.hadoop.hdfs.CheckAccessRequestProto\x1a%.hadoop.hdfs.CheckAc\
    cessResponseProto\x12u\n\x14createEncryptionZone\x12-.hadoop.hdfs.Create\
    EncryptionZoneRequestProto\x1a..hadoop.hdfs.CreateEncryptionZoneResponse\
    Proto\x12r\n\x13listEncryptionZones\x12,.hadoop.hdfs.ListEncryptionZones\
    RequestProto\x1a-.hadoop.hdfs.ListEncryptionZonesResponseProto\x12]\n\
    \x0cgetEZForPath\x12%.hadoop.hdfs.GetEZForPathRequestProto\x1a&.hadoop.h\
    dfs.GetEZForPathResponseProto\x12x\n\x15getCurrentEditLogTxid\x12..hadoo\
    p.hdfs.GetCurrentEditLogTxidRequestProto\x1a/.hadoop.hdfs.GetCurrentEdit\
    LogTxidResponseProto\x12i\n\x10getEditsFromTxid\x12).hadoop.hdfs.GetEdit\
    sFromTxidRequestProto\x1a*.hadoop.hdfs.GetEditsFromTxidResponseProtoBK\n\
    %org.apache.hadoop.hdfs.protocol.protoB\x1cClientNamenodeProtocolProtos\
    \xa0\x01\x01\x88\x01\x01\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
